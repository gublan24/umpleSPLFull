/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package cruise.umple.compiler;
import java.util.*;
import cruise.umple.util.*;

/**
 * Fragment source file: Umple_Code.ump
 * Line : 1311
 * Fragment source file: Umple_Code.ump
 * Line : 1566
 * ---------------------------------------------------------------------------------------------
 * ------------------------------------class end------------------------------------------------
 * ---------------------------------------------------------------------------------------------
 * ---------------------------------------------------------------------------------------------
 * ------------------------------------class start----------------------------------------------
 * ---------------------------------------------------------------------------------------------
 * In Umple_Code.ump: Methods for computing complex properties
 * Fragment source file: Umple_CodeClass.ump
 * Line : 119
 * Fragment source file: Umple_CodeClass.ump
 * Line : 162
 * An UmpleClass can contain attributes, associations, state machines and methods.
 * It can also have various other information such as a key (to identify uniqueness),
 * code to inject into generated code, and comments. It can be tagged with various
 * patterns, such as 'singleton', meaning that there can only be one instance,
 * and abstract, meaning it can't have any instances.
 * ----------------------------------------------------------
 * Handle the existing templates in the current umple model.
 * class UmpleModel {
 * UmpleTemplate getUmpleTemplate(String name){
 * for (UmpleTemplate aTemplate : getUmpleTemplates())
 * {
 * if (aTemplate.getName().equals(name))
 * {
 * return aTemplate;
 * }
 * }
 * return null;
 * }
 * 
 * public UmpleTemplate addUmpleTemplate(String name)
 * {
 * UmpleTemplate newTemplate = getUmpleTemplate(name);
 * if (newTemplate == null)
 * {
 * newTemplate = new UmpleTemplate(name, this);
 * addUmpleTemplate(newTemplate);
 * }
 * return newTemplate;
 * }
 * }
 * ----------------------------------------------------------
 * An umple template contains a map for emittable strings
 */
// line 44 "../../../../src/Umple_Code_StateMachine.ump"
// line 59 "../../../../src/Umple_Code_StateMachine.ump"
// line 358 "../../../../src/StateMachine.ump"
// line 306 "../../../../src/Umple_Code_Trait.ump"
// line 55 "../../../../src/Umple_CodeClass.ump"
// line 219 "../../../../src/Trait_refactored.ump"
// line 61 "../../../../src/Trace_refactored.ump"
// line 24 "../../../../src/UmpleFilterModel.ump"
// line 644 "../../../../src/Umple.ump"
// line 18 "../../../../src/Test_Code.ump"
// line 23 "../../../../src/Trace.ump"
// line 18 "../../../../src/Structure.ump"
// line 45 "../../../../src/Template.ump"
public class UmpleClass extends UmpleClassifier
{ 
  //------------------------
  // STATIC VARIABLES
  //------------------------
 
private static final Integer CounterLimit = 25;


  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //UmpleClass Attributes
  private int propagateCounter;
  private boolean filteredin;
  private boolean hasProxyPattern;
  private boolean needsDefaultInterface;
  private boolean isDistributed;
  private boolean isInternalSerializable;
  private boolean isDefaultInterfaceRemoteRMI;
  private int level;
  private boolean isInitialized;
  private boolean isAbstract;
  private boolean isSingleton;
  private List<Association> associations;
  private List<Method> unimplementedMethods;
  private Key key;

  /**
   * Specifies whether or not the Umple class is immutable.
   */
  private boolean iAmImmutable;
  private boolean ancestorIsImmutable;
  private boolean isStatic;
  private List<String> disableAutogeneratedMethodList;
  private List<PortBindingInformation> portBindingInformation;
  private boolean portClass;
  private List<TemplateMethod> emitMethods;
  private Map<String,TemplateAttributeParser> templateEmitStringMap;

  //UmpleClass Associations
  private List<Method> stateDependentMethods;
  private List<CodeInjection> codeInjections;
  private List<UmpleEnumeration> enums;
  private List<Precondition> preConds;
  private List<Postcondition> postConds;
  private List<UmpleTestCase> umpleTestCases;
  private List<TestSequence> testSequences;
  private List<TestInit> testInits;
  private List<ConstraintTree> constraintTrees;
  private UmpleClass extendsClass;
  private List<UmpleClass> innerClasses;
  private List<UmpleTrait> extendsTraits;
  private List<UmpleTemplate> extendsTemplates;
  private List<UmpleInterface> parentInterface;
  private UniqueIdentifier uniqueIdentifier;
  private List<Attribute> attributes;
  private List<AssociationVariable> associationVariables;
  private List<Comment> comments;
  private List<GeneralTPApplied> generalTPApplieds;
  private List<TraceDirective> traceDirectives;
  private List<TraceCase> traceCases;
  private List<Port> ports;
  private List<ActiveMethod> activeMethods;
  private List<PortBinding> portBindings;
  private List<TemplateField> templateFields;
  private List<StateMachine> stateMachines;
  private CompositeStructureTokenAnalyzer compositeStructureTokenAnalyzer;
  private TemplateTokenAnalyzer templateTokenAnalyzer;
  private List<UmpleClass> subclasses;
  private UmpleClass outerClass;
  private List<ClassDependencyNode> classDependencyNodes;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public UmpleClass(String aName, UmpleModel aSourceModel)
  {
    super(aName, aSourceModel);
    propagateCounter = CounterLimit;
    filteredin = false;
    hasProxyPattern = false;
    needsDefaultInterface = false;
    isDistributed = false;
    isInternalSerializable = false;
    isDefaultInterfaceRemoteRMI = false;
    level = 0;
    isInitialized = false;
    isAbstract = false;
    isSingleton = false;
    associations = new ArrayList<Association>();
    unimplementedMethods = new ArrayList<Method>();
    key = new Key();
    iAmImmutable = false;
    ancestorIsImmutable = false;
    isStatic = false;
    disableAutogeneratedMethodList = new ArrayList<String>();
    portBindingInformation = new ArrayList<PortBindingInformation>();
    portClass = false;
    emitMethods = new ArrayList<TemplateMethod>();
    templateEmitStringMap = new HashMap<String,TemplateAttributeParser>();
    stateDependentMethods = new ArrayList<Method>();
    codeInjections = new ArrayList<CodeInjection>();
    enums = new ArrayList<UmpleEnumeration>();
    preConds = new ArrayList<Precondition>();
    postConds = new ArrayList<Postcondition>();
    umpleTestCases = new ArrayList<UmpleTestCase>();
    testSequences = new ArrayList<TestSequence>();
    testInits = new ArrayList<TestInit>();
    constraintTrees = new ArrayList<ConstraintTree>();
    innerClasses = new ArrayList<UmpleClass>();
    extendsTraits = new ArrayList<UmpleTrait>();
    extendsTemplates = new ArrayList<UmpleTemplate>();
    parentInterface = new ArrayList<UmpleInterface>();
    attributes = new ArrayList<Attribute>();
    associationVariables = new ArrayList<AssociationVariable>();
    comments = new ArrayList<Comment>();
    generalTPApplieds = new ArrayList<GeneralTPApplied>();
    traceDirectives = new ArrayList<TraceDirective>();
    traceCases = new ArrayList<TraceCase>();
    ports = new ArrayList<Port>();
    activeMethods = new ArrayList<ActiveMethod>();
    portBindings = new ArrayList<PortBinding>();
    templateFields = new ArrayList<TemplateField>();
    stateMachines = new ArrayList<StateMachine>();
    subclasses = new ArrayList<UmpleClass>();
    classDependencyNodes = new ArrayList<ClassDependencyNode>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setPropagateCounter(int aPropagateCounter)
  {
    boolean wasSet = false;
    propagateCounter = aPropagateCounter;
    wasSet = true;
    return wasSet;
  }

  public boolean setFilteredin(boolean aFilteredin)
  {
    boolean wasSet = false;
    filteredin = aFilteredin;
    wasSet = true;
    return wasSet;
  }

  public boolean setHasProxyPattern(boolean aHasProxyPattern)
  {
    boolean wasSet = false;
    hasProxyPattern = aHasProxyPattern;
    wasSet = true;
    return wasSet;
  }

  public boolean setNeedsDefaultInterface(boolean aNeedsDefaultInterface)
  {
    boolean wasSet = false;
    needsDefaultInterface = aNeedsDefaultInterface;
    wasSet = true;
    return wasSet;
  }

  public boolean setIsDistributed(boolean aIsDistributed)
  {
    boolean wasSet = false;
    isDistributed = aIsDistributed;
    wasSet = true;
    return wasSet;
  }

  public boolean setIsInternalSerializable(boolean aIsInternalSerializable)
  {
    boolean wasSet = false;
    isInternalSerializable = aIsInternalSerializable;
    wasSet = true;
    return wasSet;
  }

  public boolean setIsDefaultInterfaceRemoteRMI(boolean aIsDefaultInterfaceRemoteRMI)
  {
    boolean wasSet = false;
    isDefaultInterfaceRemoteRMI = aIsDefaultInterfaceRemoteRMI;
    wasSet = true;
    return wasSet;
  }

  public boolean setLevel(int aLevel)
  {
    boolean wasSet = false;
    level = aLevel;
    wasSet = true;
    return wasSet;
  }

  public boolean setIsInitialized(boolean aIsInitialized)
  {
    boolean wasSet = false;
    isInitialized = aIsInitialized;
    wasSet = true;
    return wasSet;
  }

  public boolean setIsAbstract(boolean aIsAbstract)
  {
    boolean wasSet = false;
    isAbstract = aIsAbstract;
    wasSet = true;
    return wasSet;
  }

  public boolean setIsSingleton(boolean aIsSingleton)
  {
    boolean wasSet = false;
    isSingleton = aIsSingleton;
    wasSet = true;
    return wasSet;
  }
  /* Code from template attribute_SetMany */
  public boolean addAssociation(Association aAssociation)
  {
    boolean wasAdded = false;
    wasAdded = associations.add(aAssociation);
    return wasAdded;
  }

  public boolean removeAssociation(Association aAssociation)
  {
    boolean wasRemoved = false;
    wasRemoved = associations.remove(aAssociation);
    return wasRemoved;
  }
  /* Code from template attribute_SetMany */
  public boolean addUnimplementedMethod(Method aUnimplementedMethod)
  {
    boolean wasAdded = false;
    wasAdded = unimplementedMethods.add(aUnimplementedMethod);
    return wasAdded;
  }

  public boolean removeUnimplementedMethod(Method aUnimplementedMethod)
  {
    boolean wasRemoved = false;
    wasRemoved = unimplementedMethods.remove(aUnimplementedMethod);
    return wasRemoved;
  }

  public boolean setKey(Key aKey)
  {
    boolean wasSet = false;
    key = aKey;
    wasSet = true;
    return wasSet;
  }

  public boolean setIsStatic(boolean aIsStatic)
  {
    boolean wasSet = false;
    isStatic = aIsStatic;
    wasSet = true;
    return wasSet;
  }
  /* Code from template attribute_SetMany */
  public boolean addDisableAutogeneratedMethodList(String aDisableAutogeneratedMethodList)
  {
    boolean wasAdded = false;
    wasAdded = disableAutogeneratedMethodList.add(aDisableAutogeneratedMethodList);
    return wasAdded;
  }

  public boolean removeDisableAutogeneratedMethodList(String aDisableAutogeneratedMethodList)
  {
    boolean wasRemoved = false;
    wasRemoved = disableAutogeneratedMethodList.remove(aDisableAutogeneratedMethodList);
    return wasRemoved;
  }
  /* Code from template attribute_SetMany */
  public boolean addPortBindingInformation(PortBindingInformation aPortBindingInformation)
  {
    boolean wasAdded = false;
    wasAdded = portBindingInformation.add(aPortBindingInformation);
    return wasAdded;
  }

  public boolean removePortBindingInformation(PortBindingInformation aPortBindingInformation)
  {
    boolean wasRemoved = false;
    wasRemoved = portBindingInformation.remove(aPortBindingInformation);
    return wasRemoved;
  }

  public boolean setPortClass(boolean aPortClass)
  {
    boolean wasSet = false;
    portClass = aPortClass;
    wasSet = true;
    return wasSet;
  }
  /* Code from template attribute_SetMany */
  public boolean addEmitMethod(TemplateMethod aEmitMethod)
  {
    boolean wasAdded = false;
    wasAdded = emitMethods.add(aEmitMethod);
    return wasAdded;
  }

  public boolean removeEmitMethod(TemplateMethod aEmitMethod)
  {
    boolean wasRemoved = false;
    wasRemoved = emitMethods.remove(aEmitMethod);
    return wasRemoved;
  }

  public boolean setTemplateEmitStringMap(Map<String,TemplateAttributeParser> aTemplateEmitStringMap)
  {
    boolean wasSet = false;
    templateEmitStringMap = aTemplateEmitStringMap;
    wasSet = true;
    return wasSet;
  }

  /**
   * Arbitary Limit
   */
  public int getPropagateCounter()
  {
    return propagateCounter;
  }

  /**
   * Specifies whether or not in the filter
   */
  public boolean getFilteredin()
  {
    return filteredin;
  }

  public boolean getHasProxyPattern()
  {
    return hasProxyPattern;
  }

  public boolean getNeedsDefaultInterface()
  {
    return needsDefaultInterface;
  }

  public boolean getIsDistributed()
  {
    return isDistributed;
  }

  public boolean getIsInternalSerializable()
  {
    return isInternalSerializable;
  }

  public boolean getIsDefaultInterfaceRemoteRMI()
  {
    return isDefaultInterfaceRemoteRMI;
  }

  /**
   * dependency handling attributes
   */
  public int getLevel()
  {
    return level;
  }

  public boolean getIsInitialized()
  {
    return isInitialized;
  }

  /**
   * Specifies whether or not the Umple class is an abstract class.
   */
  public boolean getIsAbstract()
  {
    return isAbstract;
  }

  /**
   * Specifies whether or not the Umple class is a singleton.
   */
  public boolean getIsSingleton()
  {
    return isSingleton;
  }
  /* Code from template attribute_GetMany */
  public Association getAssociation(int index)
  {
    Association aAssociation = associations.get(index);
    return aAssociation;
  }

  public Association[] getAssociations()
  {
    Association[] newAssociations = associations.toArray(new Association[associations.size()]);
    return newAssociations;
  }

  public int numberOfAssociations()
  {
    int number = associations.size();
    return number;
  }

  public boolean hasAssociations()
  {
    boolean has = associations.size() > 0;
    return has;
  }

  public int indexOfAssociation(Association aAssociation)
  {
    int index = associations.indexOf(aAssociation);
    return index;
  }
  /* Code from template attribute_GetMany */
  public Method getUnimplementedMethod(int index)
  {
    Method aUnimplementedMethod = unimplementedMethods.get(index);
    return aUnimplementedMethod;
  }

  public Method[] getUnimplementedMethods()
  {
    Method[] newUnimplementedMethods = unimplementedMethods.toArray(new Method[unimplementedMethods.size()]);
    return newUnimplementedMethods;
  }

  public int numberOfUnimplementedMethods()
  {
    int number = unimplementedMethods.size();
    return number;
  }

  public boolean hasUnimplementedMethods()
  {
    boolean has = unimplementedMethods.size() > 0;
    return has;
  }

  public int indexOfUnimplementedMethod(Method aUnimplementedMethod)
  {
    int index = unimplementedMethods.indexOf(aUnimplementedMethod);
    return index;
  }

  public Key getKey()
  {
    return key;
  }

  public boolean getIsStatic()
  {
    return isStatic;
  }
  /* Code from template attribute_GetMany */
  public String getDisableAutogeneratedMethodList(int index)
  {
    String aDisableAutogeneratedMethodList = disableAutogeneratedMethodList.get(index);
    return aDisableAutogeneratedMethodList;
  }

  public String[] getDisableAutogeneratedMethodList()
  {
    String[] newDisableAutogeneratedMethodList = disableAutogeneratedMethodList.toArray(new String[disableAutogeneratedMethodList.size()]);
    return newDisableAutogeneratedMethodList;
  }

  public int numberOfDisableAutogeneratedMethodList()
  {
    int number = disableAutogeneratedMethodList.size();
    return number;
  }

  public boolean hasDisableAutogeneratedMethodList()
  {
    boolean has = disableAutogeneratedMethodList.size() > 0;
    return has;
  }

  public int indexOfDisableAutogeneratedMethodList(String aDisableAutogeneratedMethodList)
  {
    int index = disableAutogeneratedMethodList.indexOf(aDisableAutogeneratedMethodList);
    return index;
  }
  /* Code from template attribute_GetMany */
  public PortBindingInformation getPortBindingInformation(int index)
  {
    PortBindingInformation aPortBindingInformation = portBindingInformation.get(index);
    return aPortBindingInformation;
  }

  public PortBindingInformation[] getPortBindingInformation()
  {
    PortBindingInformation[] newPortBindingInformation = portBindingInformation.toArray(new PortBindingInformation[portBindingInformation.size()]);
    return newPortBindingInformation;
  }

  public int numberOfPortBindingInformation()
  {
    int number = portBindingInformation.size();
    return number;
  }

  public boolean hasPortBindingInformation()
  {
    boolean has = portBindingInformation.size() > 0;
    return has;
  }

  public int indexOfPortBindingInformation(PortBindingInformation aPortBindingInformation)
  {
    int index = portBindingInformation.indexOf(aPortBindingInformation);
    return index;
  }

  public boolean getPortClass()
  {
    return portClass;
  }
  /* Code from template attribute_GetMany */
  public TemplateMethod getEmitMethod(int index)
  {
    TemplateMethod aEmitMethod = emitMethods.get(index);
    return aEmitMethod;
  }

  public TemplateMethod[] getEmitMethods()
  {
    TemplateMethod[] newEmitMethods = emitMethods.toArray(new TemplateMethod[emitMethods.size()]);
    return newEmitMethods;
  }

  public int numberOfEmitMethods()
  {
    int number = emitMethods.size();
    return number;
  }

  public boolean hasEmitMethods()
  {
    boolean has = emitMethods.size() > 0;
    return has;
  }

  public int indexOfEmitMethod(TemplateMethod aEmitMethod)
  {
    int index = emitMethods.indexOf(aEmitMethod);
    return index;
  }

  public Map<String,TemplateAttributeParser> getTemplateEmitStringMap()
  {
    return templateEmitStringMap;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isFilteredin()
  {
    return filteredin;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isHasProxyPattern()
  {
    return hasProxyPattern;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isNeedsDefaultInterface()
  {
    return needsDefaultInterface;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isIsDistributed()
  {
    return isDistributed;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isIsInternalSerializable()
  {
    return isInternalSerializable;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isIsDefaultInterfaceRemoteRMI()
  {
    return isDefaultInterfaceRemoteRMI;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isIsInitialized()
  {
    return isInitialized;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isIsAbstract()
  {
    return isAbstract;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isIsSingleton()
  {
    return isSingleton;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isPortClass()
  {
    return portClass;
  }
  /* Code from template association_GetMany */
  public Method getStateDependentMethod(int index)
  {
    Method aStateDependentMethod = stateDependentMethods.get(index);
    return aStateDependentMethod;
  }

  public List<Method> getStateDependentMethods()
  {
    List<Method> newStateDependentMethods = Collections.unmodifiableList(stateDependentMethods);
    return newStateDependentMethods;
  }

  public int numberOfStateDependentMethods()
  {
    int number = stateDependentMethods.size();
    return number;
  }

  public boolean hasStateDependentMethods()
  {
    boolean has = stateDependentMethods.size() > 0;
    return has;
  }

  public int indexOfStateDependentMethod(Method aStateDependentMethod)
  {
    int index = stateDependentMethods.indexOf(aStateDependentMethod);
    return index;
  }
  /* Code from template association_GetMany */
  public CodeInjection getCodeInjection(int index)
  {
    CodeInjection aCodeInjection = codeInjections.get(index);
    return aCodeInjection;
  }

  public List<CodeInjection> getCodeInjections()
  {
    List<CodeInjection> newCodeInjections = Collections.unmodifiableList(codeInjections);
    return newCodeInjections;
  }

  public int numberOfCodeInjections()
  {
    int number = codeInjections.size();
    return number;
  }

  public boolean hasCodeInjections()
  {
    boolean has = codeInjections.size() > 0;
    return has;
  }

  public int indexOfCodeInjection(CodeInjection aCodeInjection)
  {
    int index = codeInjections.indexOf(aCodeInjection);
    return index;
  }
  /* Code from template association_GetMany */
  public UmpleEnumeration getEnum(int index)
  {
    UmpleEnumeration aEnum = enums.get(index);
    return aEnum;
  }

  /**
   * Enumerations that belong to the Umple Class
   */
  public List<UmpleEnumeration> getEnums()
  {
    List<UmpleEnumeration> newEnums = Collections.unmodifiableList(enums);
    return newEnums;
  }

  public int numberOfEnums()
  {
    int number = enums.size();
    return number;
  }

  public boolean hasEnums()
  {
    boolean has = enums.size() > 0;
    return has;
  }

  public int indexOfEnum(UmpleEnumeration aEnum)
  {
    int index = enums.indexOf(aEnum);
    return index;
  }
  /* Code from template association_GetMany */
  public Precondition getPreCond(int index)
  {
    Precondition aPreCond = preConds.get(index);
    return aPreCond;
  }

  /**
   * The possible Preconditions related to the Umple Class
   */
  public List<Precondition> getPreConds()
  {
    List<Precondition> newPreConds = Collections.unmodifiableList(preConds);
    return newPreConds;
  }

  public int numberOfPreConds()
  {
    int number = preConds.size();
    return number;
  }

  public boolean hasPreConds()
  {
    boolean has = preConds.size() > 0;
    return has;
  }

  public int indexOfPreCond(Precondition aPreCond)
  {
    int index = preConds.indexOf(aPreCond);
    return index;
  }
  /* Code from template association_GetMany */
  public Postcondition getPostCond(int index)
  {
    Postcondition aPostCond = postConds.get(index);
    return aPostCond;
  }

  /**
   * The possible Preconditions related to the Umple Class
   */
  public List<Postcondition> getPostConds()
  {
    List<Postcondition> newPostConds = Collections.unmodifiableList(postConds);
    return newPostConds;
  }

  public int numberOfPostConds()
  {
    int number = postConds.size();
    return number;
  }

  public boolean hasPostConds()
  {
    boolean has = postConds.size() > 0;
    return has;
  }

  public int indexOfPostCond(Postcondition aPostCond)
  {
    int index = postConds.indexOf(aPostCond);
    return index;
  }
  /* Code from template association_GetMany */
  public UmpleTestCase getUmpleTestCase(int index)
  {
    UmpleTestCase aUmpleTestCase = umpleTestCases.get(index);
    return aUmpleTestCase;
  }

  /**
   * Umple Test Case at the class level
   */
  public List<UmpleTestCase> getUmpleTestCases()
  {
    List<UmpleTestCase> newUmpleTestCases = Collections.unmodifiableList(umpleTestCases);
    return newUmpleTestCases;
  }

  public int numberOfUmpleTestCases()
  {
    int number = umpleTestCases.size();
    return number;
  }

  public boolean hasUmpleTestCases()
  {
    boolean has = umpleTestCases.size() > 0;
    return has;
  }

  public int indexOfUmpleTestCase(UmpleTestCase aUmpleTestCase)
  {
    int index = umpleTestCases.indexOf(aUmpleTestCase);
    return index;
  }
  /* Code from template association_GetMany */
  public TestSequence getTestSequence(int index)
  {
    TestSequence aTestSequence = testSequences.get(index);
    return aTestSequence;
  }

  /**
   * class test sequence for testcases
   */
  public List<TestSequence> getTestSequences()
  {
    List<TestSequence> newTestSequences = Collections.unmodifiableList(testSequences);
    return newTestSequences;
  }

  public int numberOfTestSequences()
  {
    int number = testSequences.size();
    return number;
  }

  public boolean hasTestSequences()
  {
    boolean has = testSequences.size() > 0;
    return has;
  }

  public int indexOfTestSequence(TestSequence aTestSequence)
  {
    int index = testSequences.indexOf(aTestSequence);
    return index;
  }
  /* Code from template association_GetMany */
  public TestInit getTestInit(int index)
  {
    TestInit aTestInit = testInits.get(index);
    return aTestInit;
  }

  /**
   * class test initialization: inits at the top level
   */
  public List<TestInit> getTestInits()
  {
    List<TestInit> newTestInits = Collections.unmodifiableList(testInits);
    return newTestInits;
  }

  public int numberOfTestInits()
  {
    int number = testInits.size();
    return number;
  }

  public boolean hasTestInits()
  {
    boolean has = testInits.size() > 0;
    return has;
  }

  public int indexOfTestInit(TestInit aTestInit)
  {
    int index = testInits.indexOf(aTestInit);
    return index;
  }
  /* Code from template association_GetMany */
  public ConstraintTree getConstraintTree(int index)
  {
    ConstraintTree aConstraintTree = constraintTrees.get(index);
    return aConstraintTree;
  }

  /**
   * The possible Constraints related to the Umple Class
   */
  public List<ConstraintTree> getConstraintTrees()
  {
    List<ConstraintTree> newConstraintTrees = Collections.unmodifiableList(constraintTrees);
    return newConstraintTrees;
  }

  public int numberOfConstraintTrees()
  {
    int number = constraintTrees.size();
    return number;
  }

  public boolean hasConstraintTrees()
  {
    boolean has = constraintTrees.size() > 0;
    return has;
  }

  public int indexOfConstraintTree(ConstraintTree aConstraintTree)
  {
    int index = constraintTrees.indexOf(aConstraintTree);
    return index;
  }
  /* Code from template association_GetOne */
  public UmpleClass getExtendsClass()
  {
    return extendsClass;
  }

  public boolean hasExtendsClass()
  {
    boolean has = extendsClass != null;
    return has;
  }
  /* Code from template association_GetMany */
  public UmpleClass getInnerClass(int index)
  {
    UmpleClass aInnerClass = innerClasses.get(index);
    return aInnerClass;
  }

  /**
   * isStatic if the inner class is static
   * The inner classes contained within the Umple class.
   */
  public List<UmpleClass> getInnerClasses()
  {
    List<UmpleClass> newInnerClasses = Collections.unmodifiableList(innerClasses);
    return newInnerClasses;
  }

  public int numberOfInnerClasses()
  {
    int number = innerClasses.size();
    return number;
  }

  public boolean hasInnerClasses()
  {
    boolean has = innerClasses.size() > 0;
    return has;
  }

  public int indexOfInnerClass(UmpleClass aInnerClass)
  {
    int index = innerClasses.indexOf(aInnerClass);
    return index;
  }
  /* Code from template association_GetMany */
  public UmpleTrait getExtendsTrait(int index)
  {
    UmpleTrait aExtendsTrait = extendsTraits.get(index);
    return aExtendsTrait;
  }

  public List<UmpleTrait> getExtendsTraits()
  {
    List<UmpleTrait> newExtendsTraits = Collections.unmodifiableList(extendsTraits);
    return newExtendsTraits;
  }

  public int numberOfExtendsTraits()
  {
    int number = extendsTraits.size();
    return number;
  }

  public boolean hasExtendsTraits()
  {
    boolean has = extendsTraits.size() > 0;
    return has;
  }

  public int indexOfExtendsTrait(UmpleTrait aExtendsTrait)
  {
    int index = extendsTraits.indexOf(aExtendsTrait);
    return index;
  }
  /* Code from template association_GetMany */
  public UmpleTemplate getExtendsTemplate(int index)
  {
    UmpleTemplate aExtendsTemplate = extendsTemplates.get(index);
    return aExtendsTemplate;
  }

  public List<UmpleTemplate> getExtendsTemplates()
  {
    List<UmpleTemplate> newExtendsTemplates = Collections.unmodifiableList(extendsTemplates);
    return newExtendsTemplates;
  }

  public int numberOfExtendsTemplates()
  {
    int number = extendsTemplates.size();
    return number;
  }

  public boolean hasExtendsTemplates()
  {
    boolean has = extendsTemplates.size() > 0;
    return has;
  }

  public int indexOfExtendsTemplate(UmpleTemplate aExtendsTemplate)
  {
    int index = extendsTemplates.indexOf(aExtendsTemplate);
    return index;
  }
  /* Code from template association_GetMany */
  public UmpleInterface getParentInterface(int index)
  {
    UmpleInterface aParentInterface = parentInterface.get(index);
    return aParentInterface;
  }

  public List<UmpleInterface> getParentInterface()
  {
    List<UmpleInterface> newParentInterface = Collections.unmodifiableList(parentInterface);
    return newParentInterface;
  }

  public int numberOfParentInterface()
  {
    int number = parentInterface.size();
    return number;
  }

  public boolean hasParentInterface()
  {
    boolean has = parentInterface.size() > 0;
    return has;
  }

  public int indexOfParentInterface(UmpleInterface aParentInterface)
  {
    int index = parentInterface.indexOf(aParentInterface);
    return index;
  }
  /* Code from template association_GetOne */
  public UniqueIdentifier getUniqueIdentifier()
  {
    return uniqueIdentifier;
  }

  public boolean hasUniqueIdentifier()
  {
    boolean has = uniqueIdentifier != null;
    return has;
  }
  /* Code from template association_GetMany */
  public Attribute getAttribute(int index)
  {
    Attribute aAttribute = attributes.get(index);
    return aAttribute;
  }

  /**
   * The attributes contained within the Umple class.
   */
  public List<Attribute> getAttributes()
  {
    List<Attribute> newAttributes = Collections.unmodifiableList(attributes);
    return newAttributes;
  }

  public int numberOfAttributes()
  {
    int number = attributes.size();
    return number;
  }

  public boolean hasAttributes()
  {
    boolean has = attributes.size() > 0;
    return has;
  }

  public int indexOfAttribute(Attribute aAttribute)
  {
    int index = attributes.indexOf(aAttribute);
    return index;
  }
  /* Code from template association_GetMany */
  public AssociationVariable getAssociationVariable(int index)
  {
    AssociationVariable aAssociationVariable = associationVariables.get(index);
    return aAssociationVariable;
  }

  /**
   * The associations contained within the Umple class.
   */
  public List<AssociationVariable> getAssociationVariables()
  {
    List<AssociationVariable> newAssociationVariables = Collections.unmodifiableList(associationVariables);
    return newAssociationVariables;
  }

  public int numberOfAssociationVariables()
  {
    int number = associationVariables.size();
    return number;
  }

  public boolean hasAssociationVariables()
  {
    boolean has = associationVariables.size() > 0;
    return has;
  }

  public int indexOfAssociationVariable(AssociationVariable aAssociationVariable)
  {
    int index = associationVariables.indexOf(aAssociationVariable);
    return index;
  }
  /* Code from template association_GetMany */
  public Comment getComment(int index)
  {
    Comment aComment = comments.get(index);
    return aComment;
  }

  /**
   * The comments associated with the Umple Class (such as the Javadoc above it).
   */
  public List<Comment> getComments()
  {
    List<Comment> newComments = Collections.unmodifiableList(comments);
    return newComments;
  }

  public int numberOfComments()
  {
    int number = comments.size();
    return number;
  }

  public boolean hasComments()
  {
    boolean has = comments.size() > 0;
    return has;
  }

  public int indexOfComment(Comment aComment)
  {
    int index = comments.indexOf(aComment);
    return index;
  }
  /* Code from template association_GetMany */
  public GeneralTPApplied getGeneralTPApplied(int index)
  {
    GeneralTPApplied aGeneralTPApplied = generalTPApplieds.get(index);
    return aGeneralTPApplied;
  }

  /**
   * This is used to assign inheritance parameters.
   */
  public List<GeneralTPApplied> getGeneralTPApplieds()
  {
    List<GeneralTPApplied> newGeneralTPApplieds = Collections.unmodifiableList(generalTPApplieds);
    return newGeneralTPApplieds;
  }

  public int numberOfGeneralTPApplieds()
  {
    int number = generalTPApplieds.size();
    return number;
  }

  public boolean hasGeneralTPApplieds()
  {
    boolean has = generalTPApplieds.size() > 0;
    return has;
  }

  public int indexOfGeneralTPApplied(GeneralTPApplied aGeneralTPApplied)
  {
    int index = generalTPApplieds.indexOf(aGeneralTPApplied);
    return index;
  }
  /* Code from template association_GetMany */
  public TraceDirective getTraceDirective(int index)
  {
    TraceDirective aTraceDirective = traceDirectives.get(index);
    return aTraceDirective;
  }

  public List<TraceDirective> getTraceDirectives()
  {
    List<TraceDirective> newTraceDirectives = Collections.unmodifiableList(traceDirectives);
    return newTraceDirectives;
  }

  public int numberOfTraceDirectives()
  {
    int number = traceDirectives.size();
    return number;
  }

  public boolean hasTraceDirectives()
  {
    boolean has = traceDirectives.size() > 0;
    return has;
  }

  public int indexOfTraceDirective(TraceDirective aTraceDirective)
  {
    int index = traceDirectives.indexOf(aTraceDirective);
    return index;
  }
  /* Code from template association_GetMany */
  public TraceCase getTraceCase(int index)
  {
    TraceCase aTraceCase = traceCases.get(index);
    return aTraceCase;
  }

  public List<TraceCase> getTraceCases()
  {
    List<TraceCase> newTraceCases = Collections.unmodifiableList(traceCases);
    return newTraceCases;
  }

  public int numberOfTraceCases()
  {
    int number = traceCases.size();
    return number;
  }

  public boolean hasTraceCases()
  {
    boolean has = traceCases.size() > 0;
    return has;
  }

  public int indexOfTraceCase(TraceCase aTraceCase)
  {
    int index = traceCases.indexOf(aTraceCase);
    return index;
  }
  /* Code from template association_GetMany */
  public Port getPort(int index)
  {
    Port aPort = ports.get(index);
    return aPort;
  }

  public List<Port> getPorts()
  {
    List<Port> newPorts = Collections.unmodifiableList(ports);
    return newPorts;
  }

  public int numberOfPorts()
  {
    int number = ports.size();
    return number;
  }

  public boolean hasPorts()
  {
    boolean has = ports.size() > 0;
    return has;
  }

  public int indexOfPort(Port aPort)
  {
    int index = ports.indexOf(aPort);
    return index;
  }
  /* Code from template association_GetMany */
  public ActiveMethod getActiveMethod(int index)
  {
    ActiveMethod aActiveMethod = activeMethods.get(index);
    return aActiveMethod;
  }

  public List<ActiveMethod> getActiveMethods()
  {
    List<ActiveMethod> newActiveMethods = Collections.unmodifiableList(activeMethods);
    return newActiveMethods;
  }

  public int numberOfActiveMethods()
  {
    int number = activeMethods.size();
    return number;
  }

  public boolean hasActiveMethods()
  {
    boolean has = activeMethods.size() > 0;
    return has;
  }

  public int indexOfActiveMethod(ActiveMethod aActiveMethod)
  {
    int index = activeMethods.indexOf(aActiveMethod);
    return index;
  }
  /* Code from template association_GetMany */
  public PortBinding getPortBinding(int index)
  {
    PortBinding aPortBinding = portBindings.get(index);
    return aPortBinding;
  }

  public List<PortBinding> getPortBindings()
  {
    List<PortBinding> newPortBindings = Collections.unmodifiableList(portBindings);
    return newPortBindings;
  }

  public int numberOfPortBindings()
  {
    int number = portBindings.size();
    return number;
  }

  public boolean hasPortBindings()
  {
    boolean has = portBindings.size() > 0;
    return has;
  }

  public int indexOfPortBinding(PortBinding aPortBinding)
  {
    int index = portBindings.indexOf(aPortBinding);
    return index;
  }
  /* Code from template association_GetMany */
  public TemplateField getTemplateField(int index)
  {
    TemplateField aTemplateField = templateFields.get(index);
    return aTemplateField;
  }

  public List<TemplateField> getTemplateFields()
  {
    List<TemplateField> newTemplateFields = Collections.unmodifiableList(templateFields);
    return newTemplateFields;
  }

  public int numberOfTemplateFields()
  {
    int number = templateFields.size();
    return number;
  }

  public boolean hasTemplateFields()
  {
    boolean has = templateFields.size() > 0;
    return has;
  }

  public int indexOfTemplateField(TemplateField aTemplateField)
  {
    int index = templateFields.indexOf(aTemplateField);
    return index;
  }
  /* Code from template association_GetMany */
  public StateMachine getStateMachine(int index)
  {
    StateMachine aStateMachine = stateMachines.get(index);
    return aStateMachine;
  }

  public List<StateMachine> getStateMachines()
  {
    List<StateMachine> newStateMachines = Collections.unmodifiableList(stateMachines);
    return newStateMachines;
  }

  public int numberOfStateMachines()
  {
    int number = stateMachines.size();
    return number;
  }

  public boolean hasStateMachines()
  {
    boolean has = stateMachines.size() > 0;
    return has;
  }

  public int indexOfStateMachine(StateMachine aStateMachine)
  {
    int index = stateMachines.indexOf(aStateMachine);
    return index;
  }
  /* Code from template association_GetOne */
  public CompositeStructureTokenAnalyzer getCompositeStructureTokenAnalyzer()
  {
    return compositeStructureTokenAnalyzer;
  }

  public boolean hasCompositeStructureTokenAnalyzer()
  {
    boolean has = compositeStructureTokenAnalyzer != null;
    return has;
  }
  /* Code from template association_GetOne */
  public TemplateTokenAnalyzer getTemplateTokenAnalyzer()
  {
    return templateTokenAnalyzer;
  }

  public boolean hasTemplateTokenAnalyzer()
  {
    boolean has = templateTokenAnalyzer != null;
    return has;
  }
  /* Code from template association_GetMany */
  public UmpleClass getSubclass(int index)
  {
    UmpleClass aSubclass = subclasses.get(index);
    return aSubclass;
  }

  public List<UmpleClass> getSubclasses()
  {
    List<UmpleClass> newSubclasses = Collections.unmodifiableList(subclasses);
    return newSubclasses;
  }

  public int numberOfSubclasses()
  {
    int number = subclasses.size();
    return number;
  }

  public boolean hasSubclasses()
  {
    boolean has = subclasses.size() > 0;
    return has;
  }

  public int indexOfSubclass(UmpleClass aSubclass)
  {
    int index = subclasses.indexOf(aSubclass);
    return index;
  }
  /* Code from template association_GetOne */
  public UmpleClass getOuterClass()
  {
    return outerClass;
  }

  public boolean hasOuterClass()
  {
    boolean has = outerClass != null;
    return has;
  }
  /* Code from template association_GetMany */
  public ClassDependencyNode getClassDependencyNode(int index)
  {
    ClassDependencyNode aClassDependencyNode = classDependencyNodes.get(index);
    return aClassDependencyNode;
  }

  public List<ClassDependencyNode> getClassDependencyNodes()
  {
    List<ClassDependencyNode> newClassDependencyNodes = Collections.unmodifiableList(classDependencyNodes);
    return newClassDependencyNodes;
  }

  public int numberOfClassDependencyNodes()
  {
    int number = classDependencyNodes.size();
    return number;
  }

  public boolean hasClassDependencyNodes()
  {
    boolean has = classDependencyNodes.size() > 0;
    return has;
  }

  public int indexOfClassDependencyNode(ClassDependencyNode aClassDependencyNode)
  {
    int index = classDependencyNodes.indexOf(aClassDependencyNode);
    return index;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfStateDependentMethods()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addStateDependentMethod(Method aStateDependentMethod)
  {
    boolean wasAdded = false;
    if (stateDependentMethods.contains(aStateDependentMethod)) { return false; }
    UmpleClass existingUmpleClass = aStateDependentMethod.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aStateDependentMethod.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeStateDependentMethod(aStateDependentMethod);
      addStateDependentMethod(aStateDependentMethod);
    }
    else
    {
      stateDependentMethods.add(aStateDependentMethod);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeStateDependentMethod(Method aStateDependentMethod)
  {
    boolean wasRemoved = false;
    if (stateDependentMethods.contains(aStateDependentMethod))
    {
      stateDependentMethods.remove(aStateDependentMethod);
      aStateDependentMethod.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addStateDependentMethodAt(Method aStateDependentMethod, int index)
  {  
    boolean wasAdded = false;
    if(addStateDependentMethod(aStateDependentMethod))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfStateDependentMethods()) { index = numberOfStateDependentMethods() - 1; }
      stateDependentMethods.remove(aStateDependentMethod);
      stateDependentMethods.add(index, aStateDependentMethod);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveStateDependentMethodAt(Method aStateDependentMethod, int index)
  {
    boolean wasAdded = false;
    if(stateDependentMethods.contains(aStateDependentMethod))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfStateDependentMethods()) { index = numberOfStateDependentMethods() - 1; }
      stateDependentMethods.remove(aStateDependentMethod);
      stateDependentMethods.add(index, aStateDependentMethod);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addStateDependentMethodAt(aStateDependentMethod, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfCodeInjections()
  {
    return 0;
  }
  /* Code from template association_AddUnidirectionalMany */
  public boolean addCodeInjection(CodeInjection aCodeInjection)
  {
    boolean wasAdded = false;
    if (codeInjections.contains(aCodeInjection)) { return false; }
    codeInjections.add(aCodeInjection);
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeCodeInjection(CodeInjection aCodeInjection)
  {
    boolean wasRemoved = false;
    if (codeInjections.contains(aCodeInjection))
    {
      codeInjections.remove(aCodeInjection);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addCodeInjectionAt(CodeInjection aCodeInjection, int index)
  {  
    boolean wasAdded = false;
    if(addCodeInjection(aCodeInjection))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfCodeInjections()) { index = numberOfCodeInjections() - 1; }
      codeInjections.remove(aCodeInjection);
      codeInjections.add(index, aCodeInjection);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveCodeInjectionAt(CodeInjection aCodeInjection, int index)
  {
    boolean wasAdded = false;
    if(codeInjections.contains(aCodeInjection))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfCodeInjections()) { index = numberOfCodeInjections() - 1; }
      codeInjections.remove(aCodeInjection);
      codeInjections.add(index, aCodeInjection);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addCodeInjectionAt(aCodeInjection, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfEnums()
  {
    return 0;
  }
  /* Code from template association_AddUnidirectionalMany */
  public boolean addEnum(UmpleEnumeration aEnum)
  {
    boolean wasAdded = false;
    if (enums.contains(aEnum)) { return false; }
    enums.add(aEnum);
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeEnum(UmpleEnumeration aEnum)
  {
    boolean wasRemoved = false;
    if (enums.contains(aEnum))
    {
      enums.remove(aEnum);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addEnumAt(UmpleEnumeration aEnum, int index)
  {  
    boolean wasAdded = false;
    if(addEnum(aEnum))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfEnums()) { index = numberOfEnums() - 1; }
      enums.remove(aEnum);
      enums.add(index, aEnum);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveEnumAt(UmpleEnumeration aEnum, int index)
  {
    boolean wasAdded = false;
    if(enums.contains(aEnum))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfEnums()) { index = numberOfEnums() - 1; }
      enums.remove(aEnum);
      enums.add(index, aEnum);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addEnumAt(aEnum, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfPreConds()
  {
    return 0;
  }
  /* Code from template association_AddUnidirectionalMany */
  public boolean addPreCond(Precondition aPreCond)
  {
    boolean wasAdded = false;
    if (preConds.contains(aPreCond)) { return false; }
    preConds.add(aPreCond);
    wasAdded = true;
    return wasAdded;
  }

  public boolean removePreCond(Precondition aPreCond)
  {
    boolean wasRemoved = false;
    if (preConds.contains(aPreCond))
    {
      preConds.remove(aPreCond);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addPreCondAt(Precondition aPreCond, int index)
  {  
    boolean wasAdded = false;
    if(addPreCond(aPreCond))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPreConds()) { index = numberOfPreConds() - 1; }
      preConds.remove(aPreCond);
      preConds.add(index, aPreCond);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMovePreCondAt(Precondition aPreCond, int index)
  {
    boolean wasAdded = false;
    if(preConds.contains(aPreCond))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPreConds()) { index = numberOfPreConds() - 1; }
      preConds.remove(aPreCond);
      preConds.add(index, aPreCond);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addPreCondAt(aPreCond, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfPostConds()
  {
    return 0;
  }
  /* Code from template association_AddUnidirectionalMany */
  public boolean addPostCond(Postcondition aPostCond)
  {
    boolean wasAdded = false;
    if (postConds.contains(aPostCond)) { return false; }
    postConds.add(aPostCond);
    wasAdded = true;
    return wasAdded;
  }

  public boolean removePostCond(Postcondition aPostCond)
  {
    boolean wasRemoved = false;
    if (postConds.contains(aPostCond))
    {
      postConds.remove(aPostCond);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addPostCondAt(Postcondition aPostCond, int index)
  {  
    boolean wasAdded = false;
    if(addPostCond(aPostCond))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPostConds()) { index = numberOfPostConds() - 1; }
      postConds.remove(aPostCond);
      postConds.add(index, aPostCond);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMovePostCondAt(Postcondition aPostCond, int index)
  {
    boolean wasAdded = false;
    if(postConds.contains(aPostCond))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPostConds()) { index = numberOfPostConds() - 1; }
      postConds.remove(aPostCond);
      postConds.add(index, aPostCond);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addPostCondAt(aPostCond, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfUmpleTestCases()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addUmpleTestCase(UmpleTestCase aUmpleTestCase)
  {
    boolean wasAdded = false;
    if (umpleTestCases.contains(aUmpleTestCase)) { return false; }
    UmpleClass existingUmpleClass = aUmpleTestCase.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aUmpleTestCase.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeUmpleTestCase(aUmpleTestCase);
      addUmpleTestCase(aUmpleTestCase);
    }
    else
    {
      umpleTestCases.add(aUmpleTestCase);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeUmpleTestCase(UmpleTestCase aUmpleTestCase)
  {
    boolean wasRemoved = false;
    if (umpleTestCases.contains(aUmpleTestCase))
    {
      umpleTestCases.remove(aUmpleTestCase);
      aUmpleTestCase.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addUmpleTestCaseAt(UmpleTestCase aUmpleTestCase, int index)
  {  
    boolean wasAdded = false;
    if(addUmpleTestCase(aUmpleTestCase))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfUmpleTestCases()) { index = numberOfUmpleTestCases() - 1; }
      umpleTestCases.remove(aUmpleTestCase);
      umpleTestCases.add(index, aUmpleTestCase);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveUmpleTestCaseAt(UmpleTestCase aUmpleTestCase, int index)
  {
    boolean wasAdded = false;
    if(umpleTestCases.contains(aUmpleTestCase))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfUmpleTestCases()) { index = numberOfUmpleTestCases() - 1; }
      umpleTestCases.remove(aUmpleTestCase);
      umpleTestCases.add(index, aUmpleTestCase);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addUmpleTestCaseAt(aUmpleTestCase, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfTestSequences()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addTestSequence(TestSequence aTestSequence)
  {
    boolean wasAdded = false;
    if (testSequences.contains(aTestSequence)) { return false; }
    UmpleClass existingUmpleClass = aTestSequence.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aTestSequence.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeTestSequence(aTestSequence);
      addTestSequence(aTestSequence);
    }
    else
    {
      testSequences.add(aTestSequence);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeTestSequence(TestSequence aTestSequence)
  {
    boolean wasRemoved = false;
    if (testSequences.contains(aTestSequence))
    {
      testSequences.remove(aTestSequence);
      aTestSequence.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addTestSequenceAt(TestSequence aTestSequence, int index)
  {  
    boolean wasAdded = false;
    if(addTestSequence(aTestSequence))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTestSequences()) { index = numberOfTestSequences() - 1; }
      testSequences.remove(aTestSequence);
      testSequences.add(index, aTestSequence);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveTestSequenceAt(TestSequence aTestSequence, int index)
  {
    boolean wasAdded = false;
    if(testSequences.contains(aTestSequence))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTestSequences()) { index = numberOfTestSequences() - 1; }
      testSequences.remove(aTestSequence);
      testSequences.add(index, aTestSequence);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addTestSequenceAt(aTestSequence, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfTestInits()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addTestInit(TestInit aTestInit)
  {
    boolean wasAdded = false;
    if (testInits.contains(aTestInit)) { return false; }
    UmpleClass existingUmpleClass = aTestInit.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aTestInit.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeTestInit(aTestInit);
      addTestInit(aTestInit);
    }
    else
    {
      testInits.add(aTestInit);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeTestInit(TestInit aTestInit)
  {
    boolean wasRemoved = false;
    if (testInits.contains(aTestInit))
    {
      testInits.remove(aTestInit);
      aTestInit.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addTestInitAt(TestInit aTestInit, int index)
  {  
    boolean wasAdded = false;
    if(addTestInit(aTestInit))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTestInits()) { index = numberOfTestInits() - 1; }
      testInits.remove(aTestInit);
      testInits.add(index, aTestInit);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveTestInitAt(TestInit aTestInit, int index)
  {
    boolean wasAdded = false;
    if(testInits.contains(aTestInit))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTestInits()) { index = numberOfTestInits() - 1; }
      testInits.remove(aTestInit);
      testInits.add(index, aTestInit);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addTestInitAt(aTestInit, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfConstraintTrees()
  {
    return 0;
  }
  /* Code from template association_AddUnidirectionalMany */
  public boolean addConstraintTree(ConstraintTree aConstraintTree)
  {
    boolean wasAdded = false;
    if (constraintTrees.contains(aConstraintTree)) { return false; }
    constraintTrees.add(aConstraintTree);
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeConstraintTree(ConstraintTree aConstraintTree)
  {
    boolean wasRemoved = false;
    if (constraintTrees.contains(aConstraintTree))
    {
      constraintTrees.remove(aConstraintTree);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addConstraintTreeAt(ConstraintTree aConstraintTree, int index)
  {  
    boolean wasAdded = false;
    if(addConstraintTree(aConstraintTree))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfConstraintTrees()) { index = numberOfConstraintTrees() - 1; }
      constraintTrees.remove(aConstraintTree);
      constraintTrees.add(index, aConstraintTree);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveConstraintTreeAt(ConstraintTree aConstraintTree, int index)
  {
    boolean wasAdded = false;
    if(constraintTrees.contains(aConstraintTree))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfConstraintTrees()) { index = numberOfConstraintTrees() - 1; }
      constraintTrees.remove(aConstraintTree);
      constraintTrees.add(index, aConstraintTree);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addConstraintTreeAt(aConstraintTree, index);
    }
    return wasAdded;
  }
  /* Code from template association_SetOptionalOneToMany */
  public boolean setExtendsClass(UmpleClass aExtendsClass)
  {
    boolean wasSet = false;
    // line 737 "../../../../src/Umple.ump"
    if (!enforceImmutabilityInheritanceRules(aExtendsClass)) { return false; }
    // END OF UMPLE BEFORE INJECTION
    UmpleClass existingExtendsClass = extendsClass;
    extendsClass = aExtendsClass;
    if (existingExtendsClass != null && !existingExtendsClass.equals(aExtendsClass))
    {
      existingExtendsClass.removeSubclass(this);
    }
    if (aExtendsClass != null)
    {
      aExtendsClass.addSubclass(this);
    }
    wasSet = true;
    // line 72 "../../../../src/Umple_CodeClass.ump"
    if(aExtendsClass!=null&&aExtendsClass.getMethods()!=null)
        for(Method method:aExtendsClass.getMethods())
        {
          if(this.hasMethod(method))
          {
            Method aMethod = this.getMethod(method);
    
            if(aMethod.getMethodBody().getExtraCode("")==null||"".equals(aMethod.getMethodBody().getExtraCode("")))
            {
              aMethod.getMethodBody().setExtraCode("",method.getMethodBody().getExtraCode(""));
              while(aMethod.hasMethodParameters())
              {
                aMethod.removeMethodParameter(aMethod.getMethodParameter(0));
              }
              for(MethodParameter mp:method.getMethodParameters())
              {
                aMethod.addMethodParameter(mp);
              }
              if(!"".equals(aMethod.getMethodBody().getExtraCode("")))
              {
                aMethod.setIsImplemented(false);
              }
            }
          }
        }
    // END OF UMPLE AFTER INJECTION
    return wasSet;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfInnerClasses()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addInnerClass(UmpleClass aInnerClass)
  {
    boolean wasAdded = false;
    if (innerClasses.contains(aInnerClass)) { return false; }
    UmpleClass existingOuterClass = aInnerClass.getOuterClass();
    if (existingOuterClass == null)
    {
      aInnerClass.setOuterClass(this);
    }
    else if (!this.equals(existingOuterClass))
    {
      existingOuterClass.removeInnerClass(aInnerClass);
      addInnerClass(aInnerClass);
    }
    else
    {
      innerClasses.add(aInnerClass);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeInnerClass(UmpleClass aInnerClass)
  {
    boolean wasRemoved = false;
    if (innerClasses.contains(aInnerClass))
    {
      innerClasses.remove(aInnerClass);
      aInnerClass.setOuterClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addInnerClassAt(UmpleClass aInnerClass, int index)
  {  
    boolean wasAdded = false;
    if(addInnerClass(aInnerClass))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfInnerClasses()) { index = numberOfInnerClasses() - 1; }
      innerClasses.remove(aInnerClass);
      innerClasses.add(index, aInnerClass);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveInnerClassAt(UmpleClass aInnerClass, int index)
  {
    boolean wasAdded = false;
    if(innerClasses.contains(aInnerClass))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfInnerClasses()) { index = numberOfInnerClasses() - 1; }
      innerClasses.remove(aInnerClass);
      innerClasses.add(index, aInnerClass);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addInnerClassAt(aInnerClass, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfExtendsTraits()
  {
    return 0;
  }
  /* Code from template association_AddManyToManyMethod */
  public boolean addExtendsTrait(UmpleTrait aExtendsTrait)
  {
    boolean wasAdded = false;
    if (extendsTraits.contains(aExtendsTrait)) { return false; }
    extendsTraits.add(aExtendsTrait);
    if (aExtendsTrait.indexOfSubClass(this) != -1)
    {
      wasAdded = true;
    }
    else
    {
      wasAdded = aExtendsTrait.addSubClass(this);
      if (!wasAdded)
      {
        extendsTraits.remove(aExtendsTrait);
      }
    }
    return wasAdded;
  }
  /* Code from template association_RemoveMany */
  public boolean removeExtendsTrait(UmpleTrait aExtendsTrait)
  {
    boolean wasRemoved = false;
    if (!extendsTraits.contains(aExtendsTrait))
    {
      return wasRemoved;
    }

    int oldIndex = extendsTraits.indexOf(aExtendsTrait);
    extendsTraits.remove(oldIndex);
    if (aExtendsTrait.indexOfSubClass(this) == -1)
    {
      wasRemoved = true;
    }
    else
    {
      wasRemoved = aExtendsTrait.removeSubClass(this);
      if (!wasRemoved)
      {
        extendsTraits.add(oldIndex,aExtendsTrait);
      }
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addExtendsTraitAt(UmpleTrait aExtendsTrait, int index)
  {  
    boolean wasAdded = false;
    if(addExtendsTrait(aExtendsTrait))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfExtendsTraits()) { index = numberOfExtendsTraits() - 1; }
      extendsTraits.remove(aExtendsTrait);
      extendsTraits.add(index, aExtendsTrait);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveExtendsTraitAt(UmpleTrait aExtendsTrait, int index)
  {
    boolean wasAdded = false;
    if(extendsTraits.contains(aExtendsTrait))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfExtendsTraits()) { index = numberOfExtendsTraits() - 1; }
      extendsTraits.remove(aExtendsTrait);
      extendsTraits.add(index, aExtendsTrait);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addExtendsTraitAt(aExtendsTrait, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfExtendsTemplates()
  {
    return 0;
  }
  /* Code from template association_AddManyToManyMethod */
  public boolean addExtendsTemplate(UmpleTemplate aExtendsTemplate)
  {
    boolean wasAdded = false;
    if (extendsTemplates.contains(aExtendsTemplate)) { return false; }
    extendsTemplates.add(aExtendsTemplate);
    if (aExtendsTemplate.indexOfSubClass(this) != -1)
    {
      wasAdded = true;
    }
    else
    {
      wasAdded = aExtendsTemplate.addSubClass(this);
      if (!wasAdded)
      {
        extendsTemplates.remove(aExtendsTemplate);
      }
    }
    return wasAdded;
  }
  /* Code from template association_RemoveMany */
  public boolean removeExtendsTemplate(UmpleTemplate aExtendsTemplate)
  {
    boolean wasRemoved = false;
    if (!extendsTemplates.contains(aExtendsTemplate))
    {
      return wasRemoved;
    }

    int oldIndex = extendsTemplates.indexOf(aExtendsTemplate);
    extendsTemplates.remove(oldIndex);
    if (aExtendsTemplate.indexOfSubClass(this) == -1)
    {
      wasRemoved = true;
    }
    else
    {
      wasRemoved = aExtendsTemplate.removeSubClass(this);
      if (!wasRemoved)
      {
        extendsTemplates.add(oldIndex,aExtendsTemplate);
      }
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addExtendsTemplateAt(UmpleTemplate aExtendsTemplate, int index)
  {  
    boolean wasAdded = false;
    if(addExtendsTemplate(aExtendsTemplate))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfExtendsTemplates()) { index = numberOfExtendsTemplates() - 1; }
      extendsTemplates.remove(aExtendsTemplate);
      extendsTemplates.add(index, aExtendsTemplate);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveExtendsTemplateAt(UmpleTemplate aExtendsTemplate, int index)
  {
    boolean wasAdded = false;
    if(extendsTemplates.contains(aExtendsTemplate))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfExtendsTemplates()) { index = numberOfExtendsTemplates() - 1; }
      extendsTemplates.remove(aExtendsTemplate);
      extendsTemplates.add(index, aExtendsTemplate);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addExtendsTemplateAt(aExtendsTemplate, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfParentInterface()
  {
    return 0;
  }
  /* Code from template association_AddUnidirectionalMany */
  public boolean addParentInterface(UmpleInterface aParentInterface)
  {
    boolean wasAdded = false;
    if (parentInterface.contains(aParentInterface)) { return false; }
    parentInterface.add(aParentInterface);
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeParentInterface(UmpleInterface aParentInterface)
  {
    boolean wasRemoved = false;
    if (parentInterface.contains(aParentInterface))
    {
      parentInterface.remove(aParentInterface);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addParentInterfaceAt(UmpleInterface aParentInterface, int index)
  {  
    boolean wasAdded = false;
    if(addParentInterface(aParentInterface))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfParentInterface()) { index = numberOfParentInterface() - 1; }
      parentInterface.remove(aParentInterface);
      parentInterface.add(index, aParentInterface);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveParentInterfaceAt(UmpleInterface aParentInterface, int index)
  {
    boolean wasAdded = false;
    if(parentInterface.contains(aParentInterface))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfParentInterface()) { index = numberOfParentInterface() - 1; }
      parentInterface.remove(aParentInterface);
      parentInterface.add(index, aParentInterface);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addParentInterfaceAt(aParentInterface, index);
    }
    return wasAdded;
  }
  /* Code from template association_SetUnidirectionalOptionalOne */
  public boolean setUniqueIdentifier(UniqueIdentifier aNewUniqueIdentifier)
  {
    boolean wasSet = false;
    uniqueIdentifier = aNewUniqueIdentifier;
    wasSet = true;
    return wasSet;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfAttributes()
  {
    return 0;
  }
  /* Code from template association_AddManyToOne */
  public Attribute addAttribute(String aName, String aType, String aModifier, String aValue, boolean aIsAutounique)
  {
    return new Attribute(aName, aType, aModifier, aValue, aIsAutounique, this);
  }

  public boolean addAttribute(Attribute aAttribute)
  {
    boolean wasAdded = false;
    if (attributes.contains(aAttribute)) { return false; }
    UmpleClass existingUmpleClass = aAttribute.getUmpleClass();
    boolean isNewUmpleClass = existingUmpleClass != null && !this.equals(existingUmpleClass);
    if (isNewUmpleClass)
    {
      aAttribute.setUmpleClass(this);
    }
    else
    {
      attributes.add(aAttribute);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeAttribute(Attribute aAttribute)
  {
    boolean wasRemoved = false;
    //Unable to remove aAttribute, as it must always have a umpleClass
    if (!this.equals(aAttribute.getUmpleClass()))
    {
      attributes.remove(aAttribute);
      wasRemoved = true;
    }
    // line 713 "../../../../src/Umple_CodeClass.ump"
    if (wasRemoved)
      	{
      		this.removeAttributeFromAutogeneratedConstructor(aAttribute);
      	}
    // END OF UMPLE AFTER INJECTION
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addAttributeAt(Attribute aAttribute, int index)
  {  
    boolean wasAdded = false;
    if(addAttribute(aAttribute))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAttributes()) { index = numberOfAttributes() - 1; }
      attributes.remove(aAttribute);
      attributes.add(index, aAttribute);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveAttributeAt(Attribute aAttribute, int index)
  {
    boolean wasAdded = false;
    if(attributes.contains(aAttribute))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAttributes()) { index = numberOfAttributes() - 1; }
      attributes.remove(aAttribute);
      attributes.add(index, aAttribute);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addAttributeAt(aAttribute, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfAssociationVariables()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addAssociationVariable(AssociationVariable aAssociationVariable)
  {
    boolean wasAdded = false;
    // line 735 "../../../../src/Umple.ump"
    if (!immutabilityAssociationRulesSatisfied(aAssociationVariable, this.isImmutable())) { return false; }
    // END OF UMPLE BEFORE INJECTION
    if (associationVariables.contains(aAssociationVariable)) { return false; }
    UmpleClass existingUmpleClass = aAssociationVariable.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aAssociationVariable.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeAssociationVariable(aAssociationVariable);
      addAssociationVariable(aAssociationVariable);
    }
    else
    {
      associationVariables.add(aAssociationVariable);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeAssociationVariable(AssociationVariable aAssociationVariable)
  {
    boolean wasRemoved = false;
    if (associationVariables.contains(aAssociationVariable))
    {
      associationVariables.remove(aAssociationVariable);
      aAssociationVariable.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addAssociationVariableAt(AssociationVariable aAssociationVariable, int index)
  {  
    boolean wasAdded = false;
    if(addAssociationVariable(aAssociationVariable))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAssociationVariables()) { index = numberOfAssociationVariables() - 1; }
      associationVariables.remove(aAssociationVariable);
      associationVariables.add(index, aAssociationVariable);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveAssociationVariableAt(AssociationVariable aAssociationVariable, int index)
  {
    boolean wasAdded = false;
    if(associationVariables.contains(aAssociationVariable))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAssociationVariables()) { index = numberOfAssociationVariables() - 1; }
      associationVariables.remove(aAssociationVariable);
      associationVariables.add(index, aAssociationVariable);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addAssociationVariableAt(aAssociationVariable, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfComments()
  {
    return 0;
  }
  /* Code from template association_AddUnidirectionalMany */
  public boolean addComment(Comment aComment)
  {
    boolean wasAdded = false;
    if (comments.contains(aComment)) { return false; }
    comments.add(aComment);
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeComment(Comment aComment)
  {
    boolean wasRemoved = false;
    if (comments.contains(aComment))
    {
      comments.remove(aComment);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addCommentAt(Comment aComment, int index)
  {  
    boolean wasAdded = false;
    if(addComment(aComment))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfComments()) { index = numberOfComments() - 1; }
      comments.remove(aComment);
      comments.add(index, aComment);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveCommentAt(Comment aComment, int index)
  {
    boolean wasAdded = false;
    if(comments.contains(aComment))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfComments()) { index = numberOfComments() - 1; }
      comments.remove(aComment);
      comments.add(index, aComment);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addCommentAt(aComment, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfGeneralTPApplieds()
  {
    return 0;
  }
  /* Code from template association_AddUnidirectionalMany */
  public boolean addGeneralTPApplied(GeneralTPApplied aGeneralTPApplied)
  {
    boolean wasAdded = false;
    if (generalTPApplieds.contains(aGeneralTPApplied)) { return false; }
    generalTPApplieds.add(aGeneralTPApplied);
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeGeneralTPApplied(GeneralTPApplied aGeneralTPApplied)
  {
    boolean wasRemoved = false;
    if (generalTPApplieds.contains(aGeneralTPApplied))
    {
      generalTPApplieds.remove(aGeneralTPApplied);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addGeneralTPAppliedAt(GeneralTPApplied aGeneralTPApplied, int index)
  {  
    boolean wasAdded = false;
    if(addGeneralTPApplied(aGeneralTPApplied))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfGeneralTPApplieds()) { index = numberOfGeneralTPApplieds() - 1; }
      generalTPApplieds.remove(aGeneralTPApplied);
      generalTPApplieds.add(index, aGeneralTPApplied);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveGeneralTPAppliedAt(GeneralTPApplied aGeneralTPApplied, int index)
  {
    boolean wasAdded = false;
    if(generalTPApplieds.contains(aGeneralTPApplied))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfGeneralTPApplieds()) { index = numberOfGeneralTPApplieds() - 1; }
      generalTPApplieds.remove(aGeneralTPApplied);
      generalTPApplieds.add(index, aGeneralTPApplied);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addGeneralTPAppliedAt(aGeneralTPApplied, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfTraceDirectives()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addTraceDirective(TraceDirective aTraceDirective)
  {
    boolean wasAdded = false;
    if (traceDirectives.contains(aTraceDirective)) { return false; }
    UmpleClass existingUmpleClass = aTraceDirective.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aTraceDirective.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeTraceDirective(aTraceDirective);
      addTraceDirective(aTraceDirective);
    }
    else
    {
      traceDirectives.add(aTraceDirective);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeTraceDirective(TraceDirective aTraceDirective)
  {
    boolean wasRemoved = false;
    if (traceDirectives.contains(aTraceDirective))
    {
      traceDirectives.remove(aTraceDirective);
      aTraceDirective.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addTraceDirectiveAt(TraceDirective aTraceDirective, int index)
  {  
    boolean wasAdded = false;
    if(addTraceDirective(aTraceDirective))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTraceDirectives()) { index = numberOfTraceDirectives() - 1; }
      traceDirectives.remove(aTraceDirective);
      traceDirectives.add(index, aTraceDirective);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveTraceDirectiveAt(TraceDirective aTraceDirective, int index)
  {
    boolean wasAdded = false;
    if(traceDirectives.contains(aTraceDirective))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTraceDirectives()) { index = numberOfTraceDirectives() - 1; }
      traceDirectives.remove(aTraceDirective);
      traceDirectives.add(index, aTraceDirective);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addTraceDirectiveAt(aTraceDirective, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfTraceCases()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addTraceCase(TraceCase aTraceCase)
  {
    boolean wasAdded = false;
    if (traceCases.contains(aTraceCase)) { return false; }
    UmpleClass existingUmpleClass = aTraceCase.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aTraceCase.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeTraceCase(aTraceCase);
      addTraceCase(aTraceCase);
    }
    else
    {
      traceCases.add(aTraceCase);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeTraceCase(TraceCase aTraceCase)
  {
    boolean wasRemoved = false;
    if (traceCases.contains(aTraceCase))
    {
      traceCases.remove(aTraceCase);
      aTraceCase.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addTraceCaseAt(TraceCase aTraceCase, int index)
  {  
    boolean wasAdded = false;
    if(addTraceCase(aTraceCase))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTraceCases()) { index = numberOfTraceCases() - 1; }
      traceCases.remove(aTraceCase);
      traceCases.add(index, aTraceCase);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveTraceCaseAt(TraceCase aTraceCase, int index)
  {
    boolean wasAdded = false;
    if(traceCases.contains(aTraceCase))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTraceCases()) { index = numberOfTraceCases() - 1; }
      traceCases.remove(aTraceCase);
      traceCases.add(index, aTraceCase);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addTraceCaseAt(aTraceCase, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfPorts()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addPort(Port aPort)
  {
    boolean wasAdded = false;
    if (ports.contains(aPort)) { return false; }
    UmpleClass existingUmpleClass = aPort.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aPort.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removePort(aPort);
      addPort(aPort);
    }
    else
    {
      ports.add(aPort);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removePort(Port aPort)
  {
    boolean wasRemoved = false;
    if (ports.contains(aPort))
    {
      ports.remove(aPort);
      aPort.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addPortAt(Port aPort, int index)
  {  
    boolean wasAdded = false;
    if(addPort(aPort))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPorts()) { index = numberOfPorts() - 1; }
      ports.remove(aPort);
      ports.add(index, aPort);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMovePortAt(Port aPort, int index)
  {
    boolean wasAdded = false;
    if(ports.contains(aPort))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPorts()) { index = numberOfPorts() - 1; }
      ports.remove(aPort);
      ports.add(index, aPort);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addPortAt(aPort, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfActiveMethods()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addActiveMethod(ActiveMethod aActiveMethod)
  {
    boolean wasAdded = false;
    if (activeMethods.contains(aActiveMethod)) { return false; }
    UmpleClass existingUmpleClass = aActiveMethod.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aActiveMethod.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeActiveMethod(aActiveMethod);
      addActiveMethod(aActiveMethod);
    }
    else
    {
      activeMethods.add(aActiveMethod);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeActiveMethod(ActiveMethod aActiveMethod)
  {
    boolean wasRemoved = false;
    if (activeMethods.contains(aActiveMethod))
    {
      activeMethods.remove(aActiveMethod);
      aActiveMethod.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addActiveMethodAt(ActiveMethod aActiveMethod, int index)
  {  
    boolean wasAdded = false;
    if(addActiveMethod(aActiveMethod))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfActiveMethods()) { index = numberOfActiveMethods() - 1; }
      activeMethods.remove(aActiveMethod);
      activeMethods.add(index, aActiveMethod);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveActiveMethodAt(ActiveMethod aActiveMethod, int index)
  {
    boolean wasAdded = false;
    if(activeMethods.contains(aActiveMethod))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfActiveMethods()) { index = numberOfActiveMethods() - 1; }
      activeMethods.remove(aActiveMethod);
      activeMethods.add(index, aActiveMethod);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addActiveMethodAt(aActiveMethod, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfPortBindings()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addPortBinding(PortBinding aPortBinding)
  {
    boolean wasAdded = false;
    if (portBindings.contains(aPortBinding)) { return false; }
    UmpleClass existingUmpleClass = aPortBinding.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aPortBinding.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removePortBinding(aPortBinding);
      addPortBinding(aPortBinding);
    }
    else
    {
      portBindings.add(aPortBinding);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removePortBinding(PortBinding aPortBinding)
  {
    boolean wasRemoved = false;
    if (portBindings.contains(aPortBinding))
    {
      portBindings.remove(aPortBinding);
      aPortBinding.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addPortBindingAt(PortBinding aPortBinding, int index)
  {  
    boolean wasAdded = false;
    if(addPortBinding(aPortBinding))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPortBindings()) { index = numberOfPortBindings() - 1; }
      portBindings.remove(aPortBinding);
      portBindings.add(index, aPortBinding);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMovePortBindingAt(PortBinding aPortBinding, int index)
  {
    boolean wasAdded = false;
    if(portBindings.contains(aPortBinding))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPortBindings()) { index = numberOfPortBindings() - 1; }
      portBindings.remove(aPortBinding);
      portBindings.add(index, aPortBinding);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addPortBindingAt(aPortBinding, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfTemplateFields()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addTemplateField(TemplateField aTemplateField)
  {
    boolean wasAdded = false;
    if (templateFields.contains(aTemplateField)) { return false; }
    UmpleClass existingUmpleClass = aTemplateField.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aTemplateField.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeTemplateField(aTemplateField);
      addTemplateField(aTemplateField);
    }
    else
    {
      templateFields.add(aTemplateField);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeTemplateField(TemplateField aTemplateField)
  {
    boolean wasRemoved = false;
    if (templateFields.contains(aTemplateField))
    {
      templateFields.remove(aTemplateField);
      aTemplateField.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addTemplateFieldAt(TemplateField aTemplateField, int index)
  {  
    boolean wasAdded = false;
    if(addTemplateField(aTemplateField))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTemplateFields()) { index = numberOfTemplateFields() - 1; }
      templateFields.remove(aTemplateField);
      templateFields.add(index, aTemplateField);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveTemplateFieldAt(TemplateField aTemplateField, int index)
  {
    boolean wasAdded = false;
    if(templateFields.contains(aTemplateField))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfTemplateFields()) { index = numberOfTemplateFields() - 1; }
      templateFields.remove(aTemplateField);
      templateFields.add(index, aTemplateField);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addTemplateFieldAt(aTemplateField, index);
    }
    return wasAdded;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfStateMachines()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addStateMachine(StateMachine aStateMachine)
  {
    boolean wasAdded = false;
    if (stateMachines.contains(aStateMachine)) { return false; }
    UmpleClass existingUmpleClass = aStateMachine.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aStateMachine.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeStateMachine(aStateMachine);
      addStateMachine(aStateMachine);
    }
    else
    {
      stateMachines.add(aStateMachine);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeStateMachine(StateMachine aStateMachine)
  {
    boolean wasRemoved = false;
    if (stateMachines.contains(aStateMachine))
    {
      stateMachines.remove(aStateMachine);
      aStateMachine.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addStateMachineAt(StateMachine aStateMachine, int index)
  {  
    boolean wasAdded = false;
    if(addStateMachine(aStateMachine))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfStateMachines()) { index = numberOfStateMachines() - 1; }
      stateMachines.remove(aStateMachine);
      stateMachines.add(index, aStateMachine);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveStateMachineAt(StateMachine aStateMachine, int index)
  {
    boolean wasAdded = false;
    if(stateMachines.contains(aStateMachine))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfStateMachines()) { index = numberOfStateMachines() - 1; }
      stateMachines.remove(aStateMachine);
      stateMachines.add(index, aStateMachine);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addStateMachineAt(aStateMachine, index);
    }
    return wasAdded;
  }
  /* Code from template association_SetOptionalOneToMany */
  public boolean setCompositeStructureTokenAnalyzer(CompositeStructureTokenAnalyzer aCompositeStructureTokenAnalyzer)
  {
    boolean wasSet = false;
    CompositeStructureTokenAnalyzer existingCompositeStructureTokenAnalyzer = compositeStructureTokenAnalyzer;
    compositeStructureTokenAnalyzer = aCompositeStructureTokenAnalyzer;
    if (existingCompositeStructureTokenAnalyzer != null && !existingCompositeStructureTokenAnalyzer.equals(aCompositeStructureTokenAnalyzer))
    {
      existingCompositeStructureTokenAnalyzer.removeComponent(this);
    }
    if (aCompositeStructureTokenAnalyzer != null)
    {
      aCompositeStructureTokenAnalyzer.addComponent(this);
    }
    wasSet = true;
    return wasSet;
  }
  /* Code from template association_SetOptionalOneToMany */
  public boolean setTemplateTokenAnalyzer(TemplateTokenAnalyzer aTemplateTokenAnalyzer)
  {
    boolean wasSet = false;
    TemplateTokenAnalyzer existingTemplateTokenAnalyzer = templateTokenAnalyzer;
    templateTokenAnalyzer = aTemplateTokenAnalyzer;
    if (existingTemplateTokenAnalyzer != null && !existingTemplateTokenAnalyzer.equals(aTemplateTokenAnalyzer))
    {
      existingTemplateTokenAnalyzer.removeTemplate(this);
    }
    if (aTemplateTokenAnalyzer != null)
    {
      aTemplateTokenAnalyzer.addTemplate(this);
    }
    wasSet = true;
    return wasSet;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfSubclasses()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addSubclass(UmpleClass aSubclass)
  {
    boolean wasAdded = false;
    if (subclasses.contains(aSubclass)) { return false; }
    UmpleClass existingExtendsClass = aSubclass.getExtendsClass();
    if (existingExtendsClass == null)
    {
      aSubclass.setExtendsClass(this);
    }
    else if (!this.equals(existingExtendsClass))
    {
      existingExtendsClass.removeSubclass(aSubclass);
      addSubclass(aSubclass);
    }
    else
    {
      subclasses.add(aSubclass);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeSubclass(UmpleClass aSubclass)
  {
    boolean wasRemoved = false;
    if (subclasses.contains(aSubclass))
    {
      subclasses.remove(aSubclass);
      aSubclass.setExtendsClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addSubclassAt(UmpleClass aSubclass, int index)
  {  
    boolean wasAdded = false;
    if(addSubclass(aSubclass))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfSubclasses()) { index = numberOfSubclasses() - 1; }
      subclasses.remove(aSubclass);
      subclasses.add(index, aSubclass);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveSubclassAt(UmpleClass aSubclass, int index)
  {
    boolean wasAdded = false;
    if(subclasses.contains(aSubclass))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfSubclasses()) { index = numberOfSubclasses() - 1; }
      subclasses.remove(aSubclass);
      subclasses.add(index, aSubclass);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addSubclassAt(aSubclass, index);
    }
    return wasAdded;
  }
  /* Code from template association_SetOptionalOneToMany */
  public boolean setOuterClass(UmpleClass aOuterClass)
  {
    boolean wasSet = false;
    UmpleClass existingOuterClass = outerClass;
    outerClass = aOuterClass;
    if (existingOuterClass != null && !existingOuterClass.equals(aOuterClass))
    {
      existingOuterClass.removeInnerClass(this);
    }
    if (aOuterClass != null)
    {
      aOuterClass.addInnerClass(this);
    }
    wasSet = true;
    return wasSet;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfClassDependencyNodes()
  {
    return 0;
  }
  /* Code from template association_AddManyToOptionalOne */
  public boolean addClassDependencyNode(ClassDependencyNode aClassDependencyNode)
  {
    boolean wasAdded = false;
    if (classDependencyNodes.contains(aClassDependencyNode)) { return false; }
    UmpleClass existingUmpleClass = aClassDependencyNode.getUmpleClass();
    if (existingUmpleClass == null)
    {
      aClassDependencyNode.setUmpleClass(this);
    }
    else if (!this.equals(existingUmpleClass))
    {
      existingUmpleClass.removeClassDependencyNode(aClassDependencyNode);
      addClassDependencyNode(aClassDependencyNode);
    }
    else
    {
      classDependencyNodes.add(aClassDependencyNode);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeClassDependencyNode(ClassDependencyNode aClassDependencyNode)
  {
    boolean wasRemoved = false;
    if (classDependencyNodes.contains(aClassDependencyNode))
    {
      classDependencyNodes.remove(aClassDependencyNode);
      aClassDependencyNode.setUmpleClass(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addClassDependencyNodeAt(ClassDependencyNode aClassDependencyNode, int index)
  {  
    boolean wasAdded = false;
    if(addClassDependencyNode(aClassDependencyNode))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfClassDependencyNodes()) { index = numberOfClassDependencyNodes() - 1; }
      classDependencyNodes.remove(aClassDependencyNode);
      classDependencyNodes.add(index, aClassDependencyNode);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveClassDependencyNodeAt(ClassDependencyNode aClassDependencyNode, int index)
  {
    boolean wasAdded = false;
    if(classDependencyNodes.contains(aClassDependencyNode))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfClassDependencyNodes()) { index = numberOfClassDependencyNodes() - 1; }
      classDependencyNodes.remove(aClassDependencyNode);
      classDependencyNodes.add(index, aClassDependencyNode);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addClassDependencyNodeAt(aClassDependencyNode, index);
    }
    return wasAdded;
  }

  public void delete()
  {
    while( !stateDependentMethods.isEmpty() )
    {
      stateDependentMethods.get(0).setUmpleClass(null);
    }
    codeInjections.clear();
    enums.clear();
    preConds.clear();
    postConds.clear();
    while( !umpleTestCases.isEmpty() )
    {
      umpleTestCases.get(0).setUmpleClass(null);
    }
    while( !testSequences.isEmpty() )
    {
      testSequences.get(0).setUmpleClass(null);
    }
    while( !testInits.isEmpty() )
    {
      testInits.get(0).setUmpleClass(null);
    }
    constraintTrees.clear();
    if (extendsClass != null)
    {
      UmpleClass placeholderExtendsClass = extendsClass;
      this.extendsClass = null;
      placeholderExtendsClass.removeSubclass(this);
    }
    while( !innerClasses.isEmpty() )
    {
      innerClasses.get(0).setOuterClass(null);
    }
    ArrayList<UmpleTrait> copyOfExtendsTraits = new ArrayList<UmpleTrait>(extendsTraits);
    extendsTraits.clear();
    for(UmpleTrait aExtendsTrait : copyOfExtendsTraits)
    {
      aExtendsTrait.removeSubClass(this);
    }
    ArrayList<UmpleTemplate> copyOfExtendsTemplates = new ArrayList<UmpleTemplate>(extendsTemplates);
    extendsTemplates.clear();
    for(UmpleTemplate aExtendsTemplate : copyOfExtendsTemplates)
    {
      aExtendsTemplate.removeSubClass(this);
    }
    parentInterface.clear();
    uniqueIdentifier = null;
    for(int i=attributes.size(); i > 0; i--)
    {
      Attribute aAttribute = attributes.get(i - 1);
      aAttribute.delete();
    }
    while( !associationVariables.isEmpty() )
    {
      associationVariables.get(0).setUmpleClass(null);
    }
    comments.clear();
    generalTPApplieds.clear();
    while( !traceDirectives.isEmpty() )
    {
      traceDirectives.get(0).setUmpleClass(null);
    }
    while( !traceCases.isEmpty() )
    {
      traceCases.get(0).setUmpleClass(null);
    }
    while( !ports.isEmpty() )
    {
      ports.get(0).setUmpleClass(null);
    }
    while( !activeMethods.isEmpty() )
    {
      activeMethods.get(0).setUmpleClass(null);
    }
    while( !portBindings.isEmpty() )
    {
      portBindings.get(0).setUmpleClass(null);
    }
    while( !templateFields.isEmpty() )
    {
      templateFields.get(0).setUmpleClass(null);
    }
    while( !stateMachines.isEmpty() )
    {
      stateMachines.get(0).setUmpleClass(null);
    }
    if (compositeStructureTokenAnalyzer != null)
    {
      CompositeStructureTokenAnalyzer placeholderCompositeStructureTokenAnalyzer = compositeStructureTokenAnalyzer;
      this.compositeStructureTokenAnalyzer = null;
      placeholderCompositeStructureTokenAnalyzer.removeComponent(this);
    }
    if (templateTokenAnalyzer != null)
    {
      TemplateTokenAnalyzer placeholderTemplateTokenAnalyzer = templateTokenAnalyzer;
      this.templateTokenAnalyzer = null;
      placeholderTemplateTokenAnalyzer.removeTemplate(this);
    }
    while( !subclasses.isEmpty() )
    {
      subclasses.get(0).setExtendsClass(null);
    }
    if (outerClass != null)
    {
      UmpleClass placeholderOuterClass = outerClass;
      this.outerClass = null;
      placeholderOuterClass.removeInnerClass(this);
    }
    while( !classDependencyNodes.isEmpty() )
    {
      classDependencyNodes.get(0).setUmpleClass(null);
    }
    super.delete();
  }

  // line 47 "../../../../src/Umple_Code_StateMachine.ump"
   public List<StateMachine> getAllStateMachines(){
    ArrayList<StateMachine> all = new ArrayList<StateMachine>();
      all.addAll(getStateMachines());
      for (StateMachine sm : getStateMachines())
      {
        all.addAll(sm.getNestedStateMachines());
      }
      return all;
  }

  // line 63 "../../../../src/Umple_Code_StateMachine.ump"
   public List<StateMachine> getStateMachines(Event e){
    List<StateMachine> allStateMachines = new ArrayList<StateMachine>();
      for (StateMachine sm : getAllStateMachines())
      {
        List<Event> allEvents = sm.getEvents();
        if (allEvents.contains(e))
        {
          allStateMachines.add(sm);
        }
      }
      return allStateMachines;
  }

  // line 76 "../../../../src/Umple_Code_StateMachine.ump"
   public List<Event> getEvents(){
    List<Event> allEvents = new ArrayList<Event>();
      for (StateMachine sm : getAllStateMachines())
      {
        allEvents.addAll(sm.getEvents());
      }

      List<Event> allUniqueEvents = new ArrayList<Event>();
      for (Event e : allEvents)
      {
        if (!allUniqueEvents.contains(e))
        {
          allUniqueEvents.add(e);
        }
      }
      return allUniqueEvents;
  }

  // line 95 "../../../../src/Umple_Code_StateMachine.ump"
   public Event findOrCreateEvent(String aName){
    if (aName == null)
      {
        return null;
      }

      for (StateMachine sm : getStateMachines())
      {
        for (Event aEvent : sm.getAllEvents())
        {
          if (aName.equals(aEvent.getName()))
          {
            return aEvent;
          }
        }
      }
      return new Event(aName);
  }

  // line 115 "../../../../src/Umple_Code_StateMachine.ump"
   public StateMachine getStateMachine(String name){
    for (StateMachine sm : stateMachines)
      {
        if (sm.getName().equals(name))
        {
          return sm;
        }
      }
      return null;
  }


  /**
   * See issue #1351. Adds a state-dependent method mapping for the current Umple class.
   */
  // line 366 "../../../../src/StateMachine.ump"
   public boolean addStateDependentMethod(Method method, State state){
    boolean wasAdded = false;
    if (!stateDependentMethods.contains(method))
    {
      stateDependentMethods.add(method);
    }
    Map<State, MethodBody> stateMap = stateDependentMethodBodyMap
                                     	.computeIfAbsent(method, k -> new HashMap<State, MethodBody>());
    stateMap.put(state, method.getMethodBody());
    return wasAdded;
  }

  // line 309 "../../../../src/Umple_Code_Trait.ump"
   public GeneralTPApplied getGeneralTPAppliedByName(String name){
    for (GeneralTPApplied gTPApplied : getGeneralTPApplieds()) {
			if (gTPApplied.getInheritanceName().equals(name)) {
				return gTPApplied;
			}
		}
		return null;
  }

  // line 60 "../../../../src/Umple_CodeClass.ump"
   public Method getAutoGeneratedConstructor(){
    for (Method aMethod : this.getMethods())
  	{
  		if (aMethod.getIsConstructor())
  		{
  			return aMethod;
  		}
  	}
  	return null;
  }

  // line 101 "../../../../src/Umple_CodeClass.ump"
   public  UmpleClass(String name){
    this(name, null);
  }

  // line 107 "../../../../src/Umple_CodeClass.ump"
   public ArrayList<String> getMethodNames(){
    ArrayList<String> methodNames = new ArrayList<String>();
    for(Attribute attr : this.getAttributes())
    {
      methodNames.addAll(attr.getMethodNames());
    }

    for(AssociationVariable av : this.getAssociationVariables())
    {
      methodNames.addAll(av.getMethodNames());
    }
    Label_StateMachine_19: ;

    for (Method m: this.getMethods()) {
      if (!isGetterSetter(m) && !m.isIsConstructor()) {
        methodNames.add(m.getName());
      }
    }

    methodNames.add("constructor");
    methodNames.add("delete");
    methodNames.add("toString");

    return methodNames;
  }


  /**
   * line 1869 "../../../../src/class/UmpleInternalParser_CodeClass.ump"
   */
  // line 134 "../../../../src/Umple_CodeClass.ump"
   private boolean isGetterSetter(Method method){
    if (method.getName().length() <= 2)
  		return false;
    String accessorName = method.getName().substring(0,3);
  	return ((accessorName.equals("get")) || (accessorName.equals("set"))) && method.getSource() == Method.Source.fAutoAPI && !method.getIsConstructor();
  }

  // line 141 "../../../../src/Umple_CodeClass.ump"
   public Boolean matchOperationMethod(String fullOperation, String method){
    String formattedMethod = method;
    TriState isMatch = new TriState(false);
    TriState isMatchOnExclude = new TriState(true);

    String[] allOperations = fullOperation.split(",");
    for (String operation : allOperations)
    {
      boolean isNot = false;
      if (operation.startsWith("!"))
      {
        isNot = true;
        operation = operation.substring(1);
      }

      String regexOperation = operation;
      regexOperation = regexOperation.replace("_*", "*");
      regexOperation = regexOperation.replace("*", ".*");
      boolean isCurrentMatch = formattedMethod.matches(regexOperation);

      if (isNot && isCurrentMatch)
      {
        isMatch.setStatus(false);
        isMatchOnExclude.setStatus(false);
      }
      else if (!isNot && isCurrentMatch)
      {
        isMatch.setStatus(true);
      }
    }

    return isMatchOnExclude.isTrue() || isMatch.isTrue();
  }


  /**
   * Gets applicable code injectiosn for generated methods
   */
  // line 177 "../../../../src/Umple_CodeClass.ump"
   public List<CodeInjection> getApplicableCodeInjections(String type, String method){
    ArrayList<CodeInjection> all = new ArrayList<CodeInjection>();
    if (type == null || method == null)
    {
      return all;
    }

    String formattedMethod = method;

    for (CodeInjection code : getCodeInjections())
    {
      if (code.getOperation() == null || !type.equals(code.getType()) || !("all".equals(code.getOperationSource()) || "generated".equals(code.getOperationSource())))
      {
        continue;
      }

      boolean isAllExcludes = true;
      TriState isMatch = new TriState(false);
      TriState isMatchOnExclude = new TriState(true);

      String[] allOperations = code.getOperation().split(",");
      for (String operation : allOperations)
      {

        boolean isNot = false;
        if (operation.startsWith("!"))
        {
          isNot = true;
          operation = operation.substring(1);
        }
        else
        {
          isAllExcludes = false;
        }
        isMatchOnExclude.setIsSet(true);

        String regexOperation = operation;
        regexOperation = regexOperation.replace("_*", "*");
        regexOperation = regexOperation.replace("*", ".*");
        boolean isCurrentMatch = formattedMethod.matches(regexOperation);

        if (isNot && isCurrentMatch)
        {
          isMatch.setStatus(false);
          isMatchOnExclude.setStatus(false);
        }
        else if (!isNot && isCurrentMatch)
        {
          isMatch.setStatus(true);
        }
      }

      if ((isAllExcludes && isMatchOnExclude.isTrue()) || isMatch.isTrue())
      {
        all.add(code);
      }
    }

    return all;
  }


  /**
   * Gets applicable code injectiosn for custom defined methods
   */
  // line 240 "../../../../src/Umple_CodeClass.ump"
   public List<CodeInjection> getApplicableCodeInjectionsCustomMethod(String type, String method, List<MethodParameter> parameters){
    ArrayList<CodeInjection> all = new ArrayList<CodeInjection>();
    if (type == null || method == null)
    {
      return all;
    }

    String formattedMethod = method;
    for (CodeInjection code : getCodeInjections())
    {
      if (code.getOperation() == null || !type.equals(code.getType()) || !("all".equals(code.getOperationSource()) || "custom".equals(code.getOperationSource())))
      {
        continue;
      }

      boolean isAllExcludes = true;
      TriState isMatch = new TriState(false);
      TriState isMatchOnExclude = new TriState(true);

      String[] allOperations = code.getOperation().split(",");
      for (int opInd = 0; opInd < allOperations.length; opInd++)
      {
        String operation = allOperations[opInd];

        boolean isNot = false;
        if (operation.startsWith("!"))
        {
          isNot = true;
          operation = operation.substring(1);
        }
        else
        {
          isAllExcludes = false;
        }
        isMatchOnExclude.setIsSet(true);

        String regexOperation = operation;
        regexOperation = regexOperation.replace("_*", "*");
        regexOperation = regexOperation.replace("*", ".*");
        regexOperation = regexOperation.replace("_~", "");
        boolean isCurrentMatch = formattedMethod.matches(regexOperation);

        boolean isParameterMatch = true;
        String currentParameters = code.getParameters()[opInd];

        if((parameters.size() == 0 && "".equals(currentParameters)) || "...".equals(currentParameters)) {
          isParameterMatch = true;
        }
        else if(parameters.size() != currentParameters.split(",").length)
        {
          isParameterMatch = false;
        } 
        else {
          int indx = 0;
          for(String parameterType : currentParameters.split(",")) {
            if(!parameterType.equals(parameters.get(indx).getType())) {
              isParameterMatch = false;
            }
            indx++;
          }
        } 

        isCurrentMatch &= isParameterMatch;

        if (isNot && isCurrentMatch)
        {
          isMatch.setStatus(false);
          isMatchOnExclude.setStatus(false);
        }
        else if (!isNot && isCurrentMatch)
        {
          isMatch.setStatus(true);
        }
      }

      if ((isAllExcludes && isMatchOnExclude.isTrue()) || isMatch.isTrue())
      {
        all.add(code);
      }
    }

    return all;
  }

  // line 325 "../../../../src/Umple_CodeClass.ump"
   public void addReferencedPackage(String aNamespace){
    if (indexOfNamespace(aNamespace) == -1 && !aNamespace.equals(getPackageName()))
    {
      addNamespace(aNamespace);
    }
  }


  /**
   * It can happen that one class has multiple association variables with the same name
   */
  // line 334 "../../../../src/Umple_CodeClass.ump"
   public AssociationVariable getAssociationVariable(String className, String roleName){
    for (AssociationVariable av : associationVariables)
    {
      if (av.getName().equals(roleName) && av.getType().equals(className))
      {
        return av;
      }
    }
    return null;
  }

  // line 346 "../../../../src/Umple_CodeClass.ump"
   public AssociationVariable getAssociationVariable(String name){
    for (AssociationVariable av : associationVariables)
    {
      if (av.getName().equals(name))
      {
        return av;
      }
    }
    return null;
  }

  // line 358 "../../../../src/Umple_CodeClass.ump"
   public AssociationVariable getAssociationVariableFor(UmpleClass uClass){
    for (AssociationVariable av : associationVariables)
    {
      if (av.getType().equals(uClass.getName()))
      {
        return av;
      }
    }
    return null;
  }

  // line 369 "../../../../src/Umple_CodeClass.ump"
   public boolean hasImplementedMethodIncludingWithinParentClasses(Method comparedMethod){
    Method aMethod = getMethod(comparedMethod);
    if(aMethod!=null&&!aMethod.isIsAbstract()){
      return true;
    }
    Label_StateMachine_20: ;

    if(getExtendsClass()!=null&&getExtendsClass().hasImplementedMethodIncludingWithinParentClasses(comparedMethod)){
      return true;
    }
    return false;
  }


  /**
   * Issue 771
   */
  // line 383 "../../../../src/Umple_CodeClass.ump"
   public boolean hasSameType(Method comparedMethod){
    String methodType = comparedMethod.getType();
    for (Method aMethod : this.getMethods()){
    	if(aMethod.getType().equals(methodType)){
    		return true;
    	}
    }
    return false;
  }

  // line 394 "../../../../src/Umple_CodeClass.ump"
   public Method getMethod(Method comparedMethod){
    String methodName = comparedMethod.getName();
    int numberOfParams = comparedMethod.getMethodParameters().size();
    for (Method aMethod : this.getMethods()){
      // Compare method names
      if (aMethod.getName().equals(methodName)){
        // Now compare parameters
        if (numberOfParams == aMethod.getMethodParameters().size())
        {
          boolean allSame = true;
          for (int i = 0; i < numberOfParams; i++)
          {
            if(!aMethod.getMethodParameter(i).getType().equals(comparedMethod.getMethodParameter(i).getType()))
            {
              allSame = false;
              break;
            }
          }
          if(allSame)
          {
            return aMethod;
          }
        }
      }
    }
    return null;
  }

  // line 423 "../../../../src/Umple_CodeClass.ump"
   public boolean hasAllAttributes(){
    return getAllAttributes().size() > 0;
  }

  // line 428 "../../../../src/Umple_CodeClass.ump"
   public List<Attribute> getAllAttributes(){
    List<Attribute> all = new ArrayList<Attribute>();

    // Get all it's inherited attributes
    if (this.hasExtendsClass()) {
      UmpleClass parent = this.getExtendsClass();
      List<Attribute> allParent = parent.getAllAttributes();
      all.addAll(allParent);
    }

    all.addAll(getAttributes());

    return all;
  }

  // line 444 "../../../../src/Umple_CodeClass.ump"
   public Attribute getAttribute(String name){
    for (Attribute av : getAllAttributes())
    {
      if (av.getName().equals(name))
      {
        return av;
      }
    }
    return null;
  }

  // line 456 "../../../../src/Umple_CodeClass.ump"
   public boolean isRoot(){
    return extendsClass == null;
  }

  // line 462 "../../../../src/Umple_CodeClass.ump"
   public GeneratedClass getGeneratedClass(){
    return gClass;
  }

  // line 467 "../../../../src/Umple_CodeClass.ump"
   public GeneratedClass createGeneratedClass(UmpleModel model){
    gClass = new GeneratedClass(model, this);
    if (getExtendsClass() != null)
    {
      gClass.setParentClass(getExtendsClass().getGeneratedClass());
    }
    return getGeneratedClass();
  }

  // line 477 "../../../../src/Umple_CodeClass.ump"
   public boolean isAttributeClass(){
    for (AssociationVariable association : getAssociationVariables())
    {
      if (association.getIsNavigable())
      {
        return false;
      }
    }
    return true;
  }


  /**
   * @return true if this class is immutable, either because it has the "immutable" modifier or
   * because an ancestor class is immutable; false if this class neither has the "immutable" modifier
   * nor an immutable ancestor.
   */
  // line 493 "../../../../src/Umple_CodeClass.ump"
   public boolean isImmutable(){
    return (iAmImmutable || ancestorIsImmutable);
  }

  // line 498 "../../../../src/Umple_CodeClass.ump"
   public boolean setImmutable(){
    boolean wasSet = false;
    if (extendsClass != null && !ancestorIsImmutable) { return wasSet; }

    if (propagateImmutabilityToAllRelationships(true))
    {
      iAmImmutable = true;
      wasSet = true;
    }
    return wasSet;
  }

  // line 514 "../../../../src/Umple_CodeClass.ump"
   private boolean propagateImmutabilityToAllRelationships(boolean isImmutable){
    setPropagateCounter(getPropagateCounter() - 1); //Reduce by 1 for each call
    
    if (isImmutable)
    {
      Label_StateMachine_21: ;
 

      for (AssociationVariable av : associationVariables)
      {
        if (!immutabilityAssociationRulesSatisfied(av, true)) { return false; }
      }
    }

    if( getPropagateCounter() == 0 ) {
        setPropagateCounter(CounterLimit);
        return true;
    }
    else{
      return notifySubclassesAncestorImmutable(isImmutable);
    }
  }

  // line 538 "../../../../src/Umple_CodeClass.ump"
   private boolean notifySubclassesAncestorImmutable(boolean isImmutable){
    boolean notified = true;
    List<UmpleClass> wereSet = new ArrayList<UmpleClass>();
    for (UmpleClass subclass : getSubclasses())
    {
      notified = subclass.setAncestorIsImmutable(isImmutable);
      if (!notified)
      {
        for (UmpleClass wasSet : wereSet)
        {
          wasSet.setAncestorIsImmutable(!isImmutable);
        }
        return notified;
      }
    }
    return notified;
  }

  // line 557 "../../../../src/Umple_CodeClass.ump"
   protected boolean setAncestorIsImmutable(boolean isImmutable){
    if (iAmImmutable)
    {
      ancestorIsImmutable = isImmutable;
      return true;
    }
    else
    {
      boolean success = propagateImmutabilityToAllRelationships(isImmutable);
      if (success) { ancestorIsImmutable = isImmutable; }
      return success;
    }
  }

  // line 572 "../../../../src/Umple_CodeClass.ump"
   private boolean enforceImmutabilityInheritanceRules(UmpleClass newSuperClass){
    // A subclass may not be immutable if the superclass is not immutable
    if (iAmImmutable && newSuperClass != null && !newSuperClass.isImmutable()) { return false; }
    boolean ancestorImmutable = (newSuperClass == null) ? false : newSuperClass.isImmutable();
    return setAncestorIsImmutable(ancestorImmutable);
  }

  // line 581 "../../../../src/Umple_CodeClass.ump"
   protected static  boolean immutabilityAssociationRulesSatisfied(AssociationVariable myAV, UmpleClass myClass, boolean myClassImmutable, AssociationVariable yourAV, UmpleClass yourClass, boolean yourClassImmutable){
    boolean satisfied = false;
    if (myAV == null || yourAV == null)
    {
      satisfied = true;
    }
    else if (!myClassImmutable && !yourClassImmutable && !"immutable".equals(myAV.getModifier()) && !"immutable".equals(yourAV.getModifier()))
    {
      satisfied = true;
    }
    else if (myAV.getIsNavigable() && yourAV.getIsNavigable())
    {
      //satisfied = false;
    }
    else if (myClass == null && yourClass == null)
    {
      satisfied = true;
    }
    else if (!yourAV.getIsNavigable() && (yourClass == null || yourClassImmutable))
    {
      if (yourClass != null && yourClass == myClass && myAV.isMandatory())
      {
        // reflexive associations may not be mandatory:
        //satisfied = false
      }
      else
      {
        satisfied = true;
      }
    }
    else if (!myAV.getIsNavigable() && (myClass == null || myClassImmutable))
    {
      if (myClass != null && yourClass == myClass && yourAV.isMandatory())
      {
        // reflexive associations may not be mandatory:
        //satisfied = false
      }
      else
      {
        satisfied = true;
      }
    }
    return satisfied;
  }

  // line 627 "../../../../src/Umple_CodeClass.ump"
   protected boolean immutabilityAssociationRulesSatisfied(AssociationVariable myAV, boolean myClassImmutable){
    AssociationVariable relatedAV = myAV.getRelatedAssociation();
    UmpleClass relatedClass = (relatedAV == null) ? null : relatedAV.getUmpleClass();
    boolean relatedClassImmutable = (relatedClass == null) ? false : ((relatedClass == this) ? myClassImmutable : relatedClass.isImmutable());

    return immutabilityAssociationRulesSatisfied(myAV, this, myClassImmutable, relatedAV, relatedClass, relatedClassImmutable);
  }

  // line 637 "../../../../src/Umple_CodeClass.ump"
   public boolean deleteAttribute(Attribute aAttribute){
    boolean wasRemoved = false;
    //Unable to remove aAttribute, as it must always have a umpleClass
    if (this.equals(aAttribute.getUmpleClass()))
    {
      attributes.remove(aAttribute);
      wasRemoved = true;
    }
    return wasRemoved;
  }

  // line 650 "../../../../src/Umple_CodeClass.ump"
   public void removeAllAutoGeneratedMethods(){
    List<Method> methodsCopy = new ArrayList<Method>(this.getMethods());
  	for (Method m: methodsCopy)
  	{
  		if (m.getSource() == Method.Source.fAutoAPI)
  			removeMethod(m);
  	}
  }

  // line 660 "../../../../src/Umple_CodeClass.ump"
   public void removeAutoGenerateMethodsForAttribute(Attribute attribute){
    String attributeName = attribute.getName();
  	String firstLetter = attributeName.substring(0,1).toUpperCase();
  	String rest = "";
  	if (attributeName.length() > 1)
  	{
  		rest = attributeName.substring(1);
  	}
  	String getName = "get" + firstLetter + rest;
  	String setName = "set" + firstLetter + rest;
  	
  	List<Method> methodsCopy = new ArrayList<Method>(this.getMethods());
    
    for (Method m : methodsCopy)
    {
    	if (m.getName().equals(getName) && m.getMethodParameters().size() == 0)
    		removeMethod(m);
    	else if (m.getName().equals(setName) && m.getMethodParameters().size() == 1
    			&& m.getMethodParameter(0).getType().equals(attribute.getType()))
    		removeMethod(m);
    }
  }

  // line 684 "../../../../src/Umple_CodeClass.ump"
   public void removeAttributeFromAutogeneratedConstructor(Attribute aAttribute){
    Method constructor = this.getAutoGeneratedConstructor();
  	if (constructor != null)
  	{
  		String attributeName = aAttribute.getName();
  		String parameterName = "a" + attributeName.substring(0,1).toUpperCase();
  		if (attributeName.length() > 1)
  		{
  			parameterName += attributeName.substring(1);
  		}
  	
  		MethodParameter toRemove = null;
  	
  		for (MethodParameter mp : constructor.getMethodParameters())
  		{
  			if (mp.getName().equals(parameterName) && mp.getFullType().equals(aAttribute.getType()))
  			{
  				toRemove = mp;
  				break;
  			}
  		}
  		
  		if (toRemove != null)
  		{
  			constructor.removeMethodParameter(toRemove);
  		}
  	}
  }


  /**
   * Issue 1008 - Helper function to determine if the Umple Class has a particular enumeration
   */
  // line 721 "../../../../src/Umple_CodeClass.ump"
   public boolean hasEnum(String enumName){
    for (UmpleEnumeration uEnum : getEnums()) {
      if (uEnum.getName().equals(enumName)) {
        return true;
      }
    }
    return false;
  }

  // line 220 "../../../../src/Trait_refactored.ump"
   public boolean hasMethodInTraits(Method aMethod){
    for (UmpleTrait uTrait : getExtendsTraits()) {
		  if (uTrait.hasCascadeMethod(aMethod,true) || uTrait.hasCascadeMethod(aMethod,false)) {
			  return true;
		  }
	}
	  return false;
  }

  // line 63 "../../../../src/Trace_refactored.ump"
   public List<TraceDirective> getAllTraceDirectives(){
    ArrayList<TraceDirective> all = new ArrayList<TraceDirective>();
    all.addAll(getTraceDirectives());

    for(TraceCase tc : getTraceCases())
      if( tc.getActivation() ==  true )
        for(TraceDirective td : tc.getTraceDirectives())
          all.add(td);

    return all;
  }

  // line 741 "../../../../src/Umple.ump"
  public boolean isUmpleClass(){
    return true;
  }


  /**
   * return TestCase using name
   */
  // line 24 "../../../../src/Test_Code.ump"
   public UmpleTestCase getUmpleTestCase(String name){
    for( UmpleTestCase tc : this.getUmpleTestCases())
	{
		if (tc.getName().equals(name))
		{
			return tc;
		}
	}
	
	return null;
  }

  // line 28 "../../../../src/Structure.ump"
   public Port getPort(String name){
    for (Port aPort : getPorts())
    	{
      		if (aPort.getName().equals(name))
      		{
        		return aPort;
      		}
    	}
    	return null;
  }


  public String toString()
  {
    return super.toString() + "["+
            "propagateCounter" + ":" + getPropagateCounter()+ "," +
            "filteredin" + ":" + getFilteredin()+ "," +
            "hasProxyPattern" + ":" + getHasProxyPattern()+ "," +
            "needsDefaultInterface" + ":" + getNeedsDefaultInterface()+ "," +
            "isDistributed" + ":" + getIsDistributed()+ "," +
            "isInternalSerializable" + ":" + getIsInternalSerializable()+ "," +
            "isDefaultInterfaceRemoteRMI" + ":" + getIsDefaultInterfaceRemoteRMI()+ "," +
            "level" + ":" + getLevel()+ "," +
            "isInitialized" + ":" + getIsInitialized()+ "," +
            "isAbstract" + ":" + getIsAbstract()+ "," +
            "isSingleton" + ":" + getIsSingleton()+ "," +
            "isStatic" + ":" + getIsStatic()+ "," +
            "portClass" + ":" + getPortClass()+ "]" + System.getProperties().getProperty("line.separator") +
            "  " + "key" + "=" + (getKey() != null ? !getKey().equals(this)  ? getKey().toString().replaceAll("  ","    ") : "this" : "null") + System.getProperties().getProperty("line.separator") +
            "  " + "templateEmitStringMap" + "=" + (getTemplateEmitStringMap() != null ? !getTemplateEmitStringMap().equals(this)  ? getTemplateEmitStringMap().toString().replaceAll("  ","    ") : "this" : "null") + System.getProperties().getProperty("line.separator") +
            "  " + "uniqueIdentifier = "+(getUniqueIdentifier()!=null?Integer.toHexString(System.identityHashCode(getUniqueIdentifier())):"null") + System.getProperties().getProperty("line.separator") +
            "  " + "compositeStructureTokenAnalyzer = "+(getCompositeStructureTokenAnalyzer()!=null?Integer.toHexString(System.identityHashCode(getCompositeStructureTokenAnalyzer())):"null") + System.getProperties().getProperty("line.separator") +
            "  " + "templateTokenAnalyzer = "+(getTemplateTokenAnalyzer()!=null?Integer.toHexString(System.identityHashCode(getTemplateTokenAnalyzer())):"null");
  }  
  //------------------------
  // DEVELOPER CODE - PROVIDED AS-IS
  //------------------------
  
  // line 361 "../../../../src/StateMachine.ump"
  private Map<Method, Map<State, MethodBody>> stateDependentMethodBodyMap = new HashMap<Method, Map<State, MethodBody>>() ;

// line 377 "../../../../src/StateMachine.ump"
  public Map<Method, Map<State, MethodBody>> getStateDependentMethodBodyMap () 
  {
    return stateDependentMethodBodyMap;
  }
// line 459 "../../../../src/Umple_CodeClass.ump"
  protected GeneratedClass gClass = null ;

  
}