/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package cruise.umple.compiler;
import java.io.*;
import java.util.*;
import cruise.umple.util.*;
import cruise.umple.compiler.exceptions.*;
import java.util.regex.Pattern;

// line 26 "../../../../src/Generator_CodeGvStateDiagram.ump"
// line 9 "../../../../src/stateMachineDiagramConfig.ump"
public class GvStateDiagramGenerator extends CodeGeneratorWithSubptions
{

  //------------------------
  // STATIC VARIABLES
  //------------------------

  public static final String NL = System.getProperty("line.separator");
  public static final String TEXT_0 = "// Code generated by Umple ";
  public static final String TEXT_1 = NL + NL + "digraph \"";
  public static final String TEXT_2 = "\" {" + NL + "  compound = true;" + NL + "  size=\"80,10\"" + NL;
  public static final String TEXT_3 = NL + "  // All transitions" + NL + "  ";
  public static final String TEXT_4 = NL + "}" + NL;
  public static final String TEXT_5 = "  node [shape=box, penwidth=0];" + NL + "  message [label =\"No state machine found in the input Umple file\"];" + NL;
  public static final String TEXT_6 = NL + "// Start states are shown as a black circle" + NL + "node [shape = point, fillcolor=\"black\", width=0.2 ];" + NL + "start_";
  public static final String TEXT_7 = " [ tooltip = \"";
  public static final String TEXT_8 = "\" ];" + NL + NL;
  public static final String TEXT_9 = NL + "// Format for normal states" + NL + "node [shape = rectangle, width=1,style=rounded];" + NL;
  public static final String TEXT_10 = NL + "// Format for normal states" + NL + "node [shape = circle, fixedsize = true, width=.3];" + NL;
  public static final String TEXT_11 = " ";
  public static final String TEXT_12 = " ";
  public static final String TEXT_13 = " [ ";
  public static final String TEXT_14 = " ] ;" + NL;
  public static final String TEXT_15 = " ";
  public static final String TEXT_16 = " ";
  public static final String TEXT_17 = " label = \"";
  public static final String TEXT_18 = "\",";
  public static final String TEXT_19 = " tooltip = \"";
  public static final String TEXT_20 = "\"";
  public static final String TEXT_21 = NL + " subgraph cluster";
  public static final String TEXT_22 = " {" + NL + "  label = \"sm ";
  public static final String TEXT_23 = " ";
  public static final String TEXT_24 = "\";" + NL + "  penwidth=0.5;" + NL;

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //GvStateDiagramGenerator Attributes
  private boolean hideActions;
  private boolean hideGuards;
  private boolean showTransitionLabels;
  private boolean showGuardLabels;
  private String display_language;
  private StateMachine root;
  private Map<Transition,String> internalBoundaryTrans;
  private int nodeNumber;
  private UmpleModel model;
  private String output;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public GvStateDiagramGenerator()
  {
    super();
    hideActions = false;
    hideGuards = false;
    showTransitionLabels = false;
    showGuardLabels = false;
    display_language = "";
    internalBoundaryTrans = new HashMap<Transition,String>();
    nodeNumber = 0;
    model = null;
    output = "";
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setHideActions(boolean aHideActions)
  {
    boolean wasSet = false;
    hideActions = aHideActions;
    wasSet = true;
    return wasSet;
  }

  public boolean setHideGuards(boolean aHideGuards)
  {
    boolean wasSet = false;
    hideGuards = aHideGuards;
    wasSet = true;
    return wasSet;
  }

  public boolean setShowTransitionLabels(boolean aShowTransitionLabels)
  {
    boolean wasSet = false;
    showTransitionLabels = aShowTransitionLabels;
    wasSet = true;
    return wasSet;
  }

  public boolean setShowGuardLabels(boolean aShowGuardLabels)
  {
    boolean wasSet = false;
    showGuardLabels = aShowGuardLabels;
    wasSet = true;
    return wasSet;
  }

  public boolean setRoot(StateMachine aRoot)
  {
    boolean wasSet = false;
    root = aRoot;
    wasSet = true;
    return wasSet;
  }

  public boolean setModel(UmpleModel aModel)
  {
    boolean wasSet = false;
    model = aModel;
    wasSet = true;
    return wasSet;
  }

  public boolean setOutput(String aOutput)
  {
    boolean wasSet = false;
    output = aOutput;
    wasSet = true;
    return wasSet;
  }

  public boolean getHideActions()
  {
    return hideActions;
  }

  public boolean getHideGuards()
  {
    return hideGuards;
  }

  public boolean getShowTransitionLabels()
  {
    return showTransitionLabels;
  }

  public boolean getShowGuardLabels()
  {
    return showGuardLabels;
  }

  public StateMachine getRoot()
  {
    return root;
  }

  /**
   * Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
   * off of what's contained in here.
   */
  public UmpleModel getModel()
  {
    return model;
  }

  public String getOutput()
  {
    return output;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isHideActions()
  {
    return hideActions;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isHideGuards()
  {
    return hideGuards;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isShowTransitionLabels()
  {
    return showTransitionLabels;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isShowGuardLabels()
  {
    return showGuardLabels;
  }

  public void delete()
  {
    super.delete();
  }


  /**
   * CENTRAL GENERATE METHOD
   */
  // line 69 "../../../../src/Generator_CodeGvStateDiagram.ump"
   public void generate(){
    StringBuilder code = new StringBuilder();
    StringBuilder transitions = new StringBuilder();
    String className;
    
    hideActions = hasSuboption("hideactions");
    hideGuards = hasSuboption("hideguards");
    showTransitionLabels = hasSuboption("showtransitionlabels");
    showGuardLabels = hasSuboption("showguardlabels");
    display_language = getDisplayLanguage();
    
    // Output basic gv file header
    _graphStart(0,code,model.getUmpleFile().getSimpleFileName());

    // Determine if there are multiple classes with state machines
    // or multiple state machines in any class
    // If so, we will need to put boxes around the state machines
    int smCount = 0;
    for (UmpleClass uClass : model.getUmpleClasses()) 
    {
      for (StateMachine sm : uClass.getStateMachines()) 
      {
        smCount++;
      }
    }
    if(smCount == 0) 
    {
      // Special case. No state machine.
      _nosm(0,code);
      terminateCode(code, transitions);
      return;
    }

    // We now know we have to output one or more state machines
    // Iterate through each class. 
    for (UmpleClass uClass : model.getUmpleClasses())
    {
      className = uClass.getName();
      code.append("\n  // Class: "+className+"\n");
      
      // Process the top level state machines in a class
      for (StateMachine sm : uClass.getStateMachines())
      {
      	root = sm;
        if(sm.getParentState() == null) 
        { // This check shouldn't be needed
          appendStateMachineRecursively(code, transitions, sm, uClass, className, true, smCount, 4);
        }
      } // End iteration through state machines of a class
    } // End iteration through classes
    terminateCode(code, transitions);
  }


  /**
   * @author: Vahdat
   * This function is used to detect the language used to display actions on the diagram.
   */
  // line 126 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private String getDisplayLanguage(){
    if (hasSuboption("Java")) return "Java";
    if (hasSuboption("Cpp")) return "Cpp";
    if (hasSuboption("Php")) return "Php";
    if (hasSuboption("RTCpp")) return "RTCpp";
    if (hasSuboption("SimpleCpp")) return "SimpleCpp";
    if (hasSuboption("Ruby")) return "Ruby";
    return "";
  }

  // line 136 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private void terminateCode(StringBuilder code, StringBuilder transitions){
    _graphEnd(0,code,transitions);

    model.setCode(code.toString());
    writeModel();
  }


  /**
   * Used to indent code
   */
  // line 168 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private void appendSpaces(StringBuilder code, int numSpaces){
    for(int i=0; i<numSpaces; i++) 
    {
      code.append(" ");
    }
  }


  /**
   * The state qualified name incorporates the classname, the state machine name
   * and the hierarchy of state names
   * This is used as the internal graphviz label, and is not displayed.
   */
  // line 179 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private String getStateQualifiedName(State s, UmpleClass c){
    StateMachine sm = s.getStateMachine();
    String prepend = s.hasNestedStateMachines() ? "cluster" : "";
    return prepend+c.getName()+"_"+sm.getFullName()+"_"+s.getName();
  }


  /**
   * Return the name for the state to be used in transitions
   */
  // line 187 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private String getTransitionNameForState(State s, UmpleClass c, boolean isOrigin){
    State firstNonSuperstate = getFirstNestedNonClusterState(s);
    return getStateQualifiedName(firstNonSuperstate, c);
  }


  /**
   * return self if it does not have nested state, otherwise the first
   * nested state that does not itself have a nested state
   */
  // line 195 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private State getFirstNestedNonClusterState(State s){
    if(!s.hasNestedStateMachines()) 
    {
      return s;
    }
    else 
    {
      return getFirstNestedNonClusterState(s.getNestedStateMachine(0).getState(0));
    }
  }

  // line 207 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private String getTransitionHeadOrTailForState(State s, UmpleClass c, boolean isOrigin){
    if(s.hasNestedStateMachines()) 
    {
      // Use lhead or ltail
      return (isOrigin? "ltail" : "lhead")+"="+getStateQualifiedName(s, c)+",";
    }
    else 
    {
      return "";
    }
  }


  /**
   * we introduce this method to generate a unique identity for a given transition using a universal set of transitions
   */
  // line 245 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private int getObjectIdentity(StateMachine sm, Object obj){
    int pos = 1;
		if( obj instanceof Transition ) {
			for(Transition trans : sm.getAllTransitions() ) {
				if(trans.equals( (Transition) obj) )
					return pos;
				pos++;
			}
		}
		if( obj instanceof Guard ) {
			pos = 1;
			for(Guard guard : sm.getAllGuards() ) {
				if(guard.equals(( Guard ) obj ))
					return pos;
				pos++;
			}
		}
  		return -1;
  }

  // line 269 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private void appendStateMachineRecursively(StringBuilder code, StringBuilder transitions, StateMachine sm, UmpleClass uClass, String className, boolean isTopLevel, int smCount, int indentLevel){
    String smName, clSmName, sLabel, sName, tooltip;
    boolean isPseudo = false;    
    Event event;
    Action action;
    String transitionLabel, guardString, actionCode, transitionAction, blah = "blah", guardLabel;
    Guard guard;
    List<StateMachine> allNestedStateMachines = sm.getImmediateNestedStateMachines();

    // We haven't processed any states yet in this statemachine
    Boolean isFirstState = true;

    // Determine whether bottom level
    Boolean isBottomLevel = allNestedStateMachines.isEmpty();
    String levelPhrase = "";
    if(isTopLevel) 
    {
      if(isBottomLevel) levelPhrase ="Top and Bottom Level ";
      else levelPhrase = "Top Level ";
    }
    else if(isBottomLevel) levelPhrase = "Bottom Level ";
      
    smName = sm.getName();
    clSmName = className+"_"+sm.getFullName();
    code.append("\n");
    appendSpaces(code,  indentLevel);
    code.append("// "+levelPhrase+"StateMachine: "+smName+"\n");        

    // If there are multiple state machines in the model
    // And this is a top level state machine
    // Then we need to put the state machine in a border
    if(smCount > 1 && isTopLevel) 
    {
      _topLevelBorder(indentLevel, code, clSmName, className, smName);
    }

    // Every state machine has a start state
    String [] stateInfo = getStatePath(sm, "start");
    tooltip = "Class "+className+", SM "+stateInfo[0]+", State "+stateInfo[1];
    _startState(indentLevel,code,clSmName, tooltip);
    _normalStateFormat(indentLevel, code);
 
    // Iterate through the states of this state machine
    for (State s : sm.getStates())
    {
      sLabel=s.getName();  // This is what is displayed
      if(sLabel.equals("HStar")) sLabel="\"H*\"";
      isPseudo = sLabel.equals("H") || sLabel.equals("\"H*\"");
      sName=getStateQualifiedName(s,uClass);  // Internal gv identifier
      
      code.append("\n");      
      appendSpaces(code,  indentLevel+2);
      code.append("// State: "+sLabel+"\n\n");   

      // WORKING ON
      // If state will have transitions that start from or end at boundary
      // and go or come from other states further inside
      // then we need to add a dummy connector state

      if(!isBottomLevel) 
      { // s is not bottom level
        Map<Transition,String> newInternalBoundaryTrans = new HashMap<Transition,String>();
      
        Set<Transition> allT = new HashSet<Transition>();
        allT.addAll(s.getTransitions());
        allT.addAll(s.getNextTransition());

        for (Transition t: allT) 
        {
          if(!internalBoundaryTrans.containsKey(t) && (
            (t.getFromState()==s && t.getNextState().isSubstateOf(s)) ||
            (t.getNextState()==s && t.getFromState().isSubstateOf(s)) ) ) 
          {

            nodeNumber++;
            String dummyName="dummyNode"+nodeNumber+"_"+
              t.getFromState().getName()+"_"+t.getNextState().getName();
            internalBoundaryTrans.put(t,dummyName);
            newInternalBoundaryTrans.put(t,dummyName);
          }
        }
        if(!newInternalBoundaryTrans.isEmpty()) 
        {
          appendSpaces(code, indentLevel+2);
          code.append("// Dummy notes for transitions to/from internals to boundary\n");
          appendSpaces(code, indentLevel+2);
          code.append("node [shape = point, width = 0.005];\n");

          for (String nodeName : newInternalBoundaryTrans.values()) 
          {
            appendSpaces(code, indentLevel+2);
            code.append(nodeName+" [label=\"\"];\n");
          }
          
          // Reinstate normal format
          _normalStateFormat(indentLevel+2, code);
        }
      }

      // Output the state (and possibly state machine) id
      if(!s.hasNestedStateMachines()) 
      {
        // Simple state node
        if(isPseudo) _pseudoStateFormat(indentLevel, code);
        appendSpaces(code,  indentLevel+2);
		
        tooltip = getStateTooltip(sm, s, className);
        code.append(sName+" [label = "+sLabel+", tooltip = \""+tooltip+"\"];\n");
        if(isPseudo) _normalStateFormat(indentLevel, code);        
      }
      else 
      {
        // Start of a subgraph
        appendSpaces(code,  indentLevel+1);
        code.append("subgraph "+sName+" {\n");
        appendSpaces(code,  indentLevel+2);
        code.append("label = \""+sLabel+"\";\n");
        appendSpaces(code,  indentLevel+2);
        code.append("style = rounded;\n");
      }

      if(isFirstState) 
      {
         // Output transition to first state
         isFirstState = false;
        String dest=getTransitionNameForState(s,uClass,false);
        String head=getTransitionHeadOrTailForState(s, uClass,false);
        stateInfo = getStatePath(sm, s.getName());
        tooltip = "start to "+stateInfo[1]; 
        
        _transition(2,transitions,"start_"+clSmName,"->", dest,
          transitionAttributes(head,"","start",s.getName(), tooltip)); 
      }
          
      // Output all the other transitions
      for (Transition t : s.getNextTransition()) 
      {
        event = t.getEvent();
        action = t.getAction();
        //showTransitionLabels = true;
        if ( !showTransitionLabels ) {
          transitionLabel = "";
        }
        else {
           transitionLabel = "   t"+getObjectIdentity( root, t )+": ";
        }       
        
        if(event.isAutoTransition()) 
        {
          transitionLabel += "";
        } 
        else {
          if (event.getIsTimer()) 
          {
            transitionLabel += "after("+event.getTimerInSeconds()+")";
          }
          else 
          {
            if(event.getArgs() == null || event.getArgs() == "") 
            {
              transitionLabel += event.getName();
            }
            else 
            {
              transitionLabel += event.getName()+"("+event.getArgs()+")";
            }
          }
        }
        
        if (action == null || getAvailableActionCode(action) == "" || hideActions) 
        {
          transitionAction = "";
        }
        else 
        {
          actionCode = getAvailableActionCode(action);
          if (actionCode.length() > 15) transitionAction = " / {...}";
          else transitionAction = " / "+actionCode.replaceAll("\"","&quot;");
        }
      
        guard = t.getGuard();
        if (guard == null || hideGuards) guardString = "";
        else 
        {
          //showGuardLabels = true;
          if ( !showGuardLabels ) {
          	guardLabel = "";
          }
          else {
            guardLabel = ":g"+getObjectIdentity( root, guard );
          }
          JavaGenerator gen = new JavaGenerator();
          gen.setModel(getModel());
          if(event.isAutoTransition()) guardString = "[";
          else guardString = " [";

          //guardString += guard.getCondition(gen).replaceAll("\"","&quot;") + "]";
	      guardString += guard.getExpression().replaceAll("\"","&quot;") + "]"+guardLabel;
        }
        
        String orig = getTransitionNameForState(t.getFromState(),uClass,true);
        String dest = getTransitionNameForState(t.getNextState(),uClass,false);
        String origlh = getTransitionHeadOrTailForState(t.getFromState(),uClass,true);
        String destlt = getTransitionHeadOrTailForState(t.getNextState(),uClass,false);
        tooltip = getTransitionTooltip(t, guardString); 

        // WORKING ON
        // If we have to go through a dummy external state
        // we have to add two transitions
        if(internalBoundaryTrans.containsKey(t)) 
        {
          _transition(2,transitions,orig,"->", internalBoundaryTrans.get(t)+":e",
            transitionAttributes("dir=none, "+origlh,
            transitionLabel + guardString + transitionAction,
            t.getFromState().getName(),t.getNextState().getName(), tooltip));        

          _transition(2,transitions,internalBoundaryTrans.get(t)+":w","->", dest,
            transitionAttributes(destlt,
            "",
            t.getFromState().getName(),t.getNextState().getName(), tooltip));        
        }
        else 
        {
          // Normal transition
          _transition(2,transitions,orig,"->", dest,
            transitionAttributes(origlh+destlt,
            transitionLabel + guardString + transitionAction,
            t.getFromState().getName(),t.getNextState().getName(), tooltip));
        }
        transitions.append("\n");
      }  // End iteration through the transitions

      // Process nested state machines of this state
      allNestedStateMachines = s.getNestedStateMachines();
      for(StateMachine nestedSm: allNestedStateMachines) 
      {
        appendStateMachineRecursively(code, transitions, nestedSm, uClass, className, false, smCount, indentLevel+2);
      } // End iteration through nested state machines

      // Mark end of subgraph
      if(s.hasNestedStateMachines()) 
      {
        appendSpaces(code,  indentLevel+1);
        code.append("}\n");
      }

      appendSpaces(code,  indentLevel+2);
      code.append("// End State: "+sLabel+"\n"); 
     
    } // End iteration through states of a state machine

    appendSpaces(code,  indentLevel);
    code.append("// End "+levelPhrase+"StateMachine: "+smName+"\n");  

    // If there are multiple state machines in the model
    // And this is the top level state machine
    // Then we need to end the cluster border started earlier
    if(smCount > 1 && isTopLevel) 
    {
      code.append("  }\n");
    }
  }


  /**
   * Get the path for nested states
   */
  // line 534 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private String[] getStatePath(StateMachine sm_in, String stateName){
    StateMachine sm = sm_in;
    State cur = sm.getParentState();
    String smName = sm.getName();
    String statePath = stateName;
	
    while (cur != null)
    {
      statePath = smName+"."+statePath;
      sm = cur.getStateMachine();
      cur = sm.getParentState();
      smName = sm.getName();
    }

    return new String[] {smName, statePath};
  }

  // line 553 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private String getTransitionTooltip(Transition t, String guardString){
    // Find the state machine path the transition is coming from
    String [] fromStateInfo = getStatePath(t.getFromState().getStateMachine(), t.getFromState().getName());
    String tooltipFromState = fromStateInfo[1];
	
    // Find the state machine path the transition is going to
    String [] toStateInfo = getStatePath(t.getNextState().getStateMachine(), t.getNextState().getName());
    String tooltipToState = toStateInfo[1];
	
    // Get the condition on which transitioning
    Event event = t.getEvent();
	
    // Set transition event information
    String tooltip = "From "+tooltipFromState+" to "+tooltipToState;
    if (!event.isAutoTransition()) 
    {
      if (event.getIsTimer()) // Timed transition
        tooltip = tooltip+" after("+event.getTimerInSeconds()+")";
      else if(event.getArgs() == null || event.getArgs() == "") 
        tooltip = tooltip+" on "+event.getName();
      else 
        tooltip = tooltip+" on "+event.getName()+"("+event.getArgs()+")";
    }
    else
    {
      tooltip = tooltip+" automatically";
	}
	
    // Get guard code for transition
    if (guardString != "" && !hideGuards)
    {
      tooltip = tooltip+"&#13;"+"Guard: "+guardString;
    }
	
    // Get action code for transition	
    Action action = t.getAction();
    String transitionAction = "";
    if (action != null)
    {
      transitionAction = getAvailableActionCode(action);
    }
    if (transitionAction != "" && !hideActions)
    {	
      transitionAction = transitionAction.replaceAll("\"","&quot;");
      tooltip = tooltip+"&#13;"+"Transition Action:\n"+retFiveLines(transitionAction);
    }
	
    return tooltip;
  }

  // line 604 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private String getStateTooltip(StateMachine sm, State st, String className){
    // Find the state machine path
    String [] stateInfo = getStatePath(sm, st.getName());
	
    String tooltip = "Class "+className+", SM "+stateInfo[0]+", State "+stateInfo[1];
		
    // Get the state actions
    if (!hideActions)
    {
      for (Action action : st.getActions())
      {
        String actionType = action.getActionType();
        String actionCode = retFiveLines(getAvailableActionCode(action).replaceAll("\"","&quot;"));
        if ("entry".equals(actionType))
        {
          tooltip = tooltip+"&#13;"+"Entry:\n"+actionCode;
        }
        else if ("exit".equals(actionType))
        {
          tooltip = tooltip+"&#13;"+"Exit:\n"+actionCode;
        }
        else
        {
          tooltip = tooltip+"&#13;"+"Action:\n"+actionCode;
        }
      }
    }
	
    // Get the activities
    for (Activity activity : st.getActivities())
    {
      String activityCode = activity.getCodeblock().toString().replaceAll("\"","&quot;");
      tooltip = tooltip+"&#13;"+"Activity:\n"+retFiveLines(activityCode);
    }
	
    return tooltip;
  }


  /**
   * Get the smallest space indent in the code
   */
  // line 644 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private int getMinSpace(String [] parts){
    int lines = parts.length < 5 ? parts.length : 5;
    int minSpaceCount = 1000;
    
    // The first part doesn't have whitespace in front of it
    for (int i = 1; i < lines; i++)
    {
      String part = parts[i];
      int j = 0, spaceCount = 0;
  	  
      while(j < part.length()){
        if(Character.isWhitespace(part.charAt(j))) { spaceCount++; }
        else { break; } // only want to count leading spaces
        j++;
      }
      
      if (spaceCount < minSpaceCount)
        minSpaceCount = spaceCount;
    }
  	
    return minSpaceCount;
  }


  /**
   * Return only the first 5 lines of code
   * Used for displaying code in the tooltip as to not overwhelm the tooltip
   */
  // line 670 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private String retFiveLines(String code){
    String trimmedCode = "";
  	
    // Check if the code has multiple lines
    // TODO: Get this working with Unix AND Windows line endings
    if (code.contains(System.getProperty("line.separator")) || code.contains("\n"))
    {
      String[] parts = code.split("\\r?\\n");
  	  
      int minSpace = getMinSpace(parts);
      int substringIdx = minSpace; 
      int lines = parts.length < 5 ? parts.length : 5;
 	    
      // Only go through the first 5 lines
      for (int i = 0; i < lines; i++)
      {
        String part = "   "+parts[i]; // Always have at least an indent of 3
  		  
        // Get rid of excess indentation or add indentation for first line
        part = (i > 0) ? part.substring(substringIdx) : part;
  		
        trimmedCode = trimmedCode+part;
        if (i < lines-1)
          trimmedCode += "\n";
      }
  	    
      if (parts.length > 5)
        trimmedCode = trimmedCode+"\n   ...";
  	  
      return trimmedCode;
    }
  	
    return "   "+code;
  }


  /**
   * Output the graphviz file to a file with the .gv suffix
   */
  // line 707 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private void writeModel(){
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName() + ".gv";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating GraphViz State Machine code." + e, e);
    }
  }


  /**
   * @author : Vahdat
   * This method tries to go through all action languages and get the action code for the first language.
   * This is needed because sometimes we want to generate two languages, but in the diagram we should show just one language which in this case is just the first valid language.
   * 
   */
  // line 731 "../../../../src/Generator_CodeGvStateDiagram.ump"
   private String getAvailableActionCode(Action action){
    String actionCode = "";
    if (display_language!=""){
      actionCode = action.getCodeblock().getCode(display_language);
      if (actionCode=="" && display_language=="Java"){
        actionCode = action.getActionCode();
      }
    } else {
      actionCode =action.getActionCode();
    }
    if (actionCode.equals("null")) actionCode = "";
    return actionCode;
  }

  private String _createSpacesString(int numSpaces){
    
  StringBuilder spaces =  new StringBuilder();
      for(int i=0; i <numSpaces; i++) {
          spaces.append(" ");
      }
      return spaces.toString();
  }

  public StringBuilder _graphStart(Integer numSpaces, StringBuilder sb, String filename){
    String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
    realSb.append(TEXT_0);
    realSb.append(UmpleModel.VERSION_NUMBER);
    realSb.append(TEXT_1);
    realSb.append(filename);
    realSb.append(TEXT_2);

    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; 
  }

  public String graphStart(String filename){
        StringBuilder sb = new StringBuilder();
    return this._graphStart(0,sb,filename).toString(); 
  }

  public StringBuilder _graphEnd(Integer numSpaces, StringBuilder sb, StringBuilder transitions){
    String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
    realSb.append(TEXT_3);
    realSb.append(transitions);
    realSb.append(TEXT_4);

    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; 
  }

  public String graphEnd(StringBuilder transitions){
        StringBuilder sb = new StringBuilder();
    return this._graphEnd(0,sb,transitions).toString(); 
  }

  public StringBuilder _nosm(Integer numSpaces, StringBuilder sb){
    String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
    realSb.append(TEXT_5);

    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; 
  }

  public String nosm(){
        StringBuilder sb = new StringBuilder();
    return this._nosm(0,sb).toString(); 
  }

  public StringBuilder _startState(Integer numSpaces, StringBuilder sb, String clSmName, String tooltip){
    String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
    realSb.append(TEXT_6);
    realSb.append(clSmName);
    realSb.append(TEXT_7);
    realSb.append(tooltip);
    realSb.append(TEXT_8);

    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; 
  }

  public String startState(String clSmName, String tooltip){
        StringBuilder sb = new StringBuilder();
    return this._startState(0,sb,clSmName,tooltip).toString(); 
  }

  public StringBuilder _normalStateFormat(Integer numSpaces, StringBuilder sb){
    String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
    realSb.append(TEXT_9);

    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; 
  }

  public String normalStateFormat(){
        StringBuilder sb = new StringBuilder();
    return this._normalStateFormat(0,sb).toString(); 
  }

  public StringBuilder _pseudoStateFormat(Integer numSpaces, StringBuilder sb){
    String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
    realSb.append(TEXT_10);

    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; 
  }

  public String pseudoStateFormat(){
        StringBuilder sb = new StringBuilder();
    return this._pseudoStateFormat(0,sb).toString(); 
  }

  public StringBuilder _transition(Integer numSpaces, StringBuilder sb, String start, String arrow, String dest, String attributes){
    String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
    realSb.append(start);
    realSb.append(TEXT_11);
    realSb.append(arrow);
    realSb.append(TEXT_12);
    realSb.append(dest);
    realSb.append(TEXT_13);
    realSb.append(attributes);
    realSb.append(TEXT_14);

    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; 
  }

  public String transition(String start, String arrow, String dest, String attributes){
        StringBuilder sb = new StringBuilder();
    return this._transition(0,sb,start,arrow,dest,attributes).toString(); 
  }

  public StringBuilder _transitionAttributes(Integer numSpaces, StringBuilder sb, String lheadtail, String label, String readableStart, String readableEnd, String tooltip){
    String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
    if(lheadtail.length()>0) {
    realSb.append(TEXT_15);
    realSb.append(lheadtail);
    realSb.append(TEXT_16);
    
  }
  if(label.length()>0) {
    realSb.append(TEXT_17);
    realSb.append(label);
    realSb.append(TEXT_18);
    
  }
  
    realSb.append(TEXT_19);
    realSb.append(tooltip);
    realSb.append(TEXT_20);

    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; 
  }

  public String transitionAttributes(String lheadtail, String label, String readableStart, String readableEnd, String tooltip){
        StringBuilder sb = new StringBuilder();
    return this._transitionAttributes(0,sb,lheadtail,label,readableStart,readableEnd,tooltip).toString(); 
  }

  public StringBuilder _topLevelBorder(Integer numSpaces, StringBuilder sb, String clSmName, String className, String smName){
    String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
    realSb.append(TEXT_21);
    realSb.append(clSmName);
    realSb.append(TEXT_22);
    realSb.append(className);
    realSb.append(TEXT_23);
    realSb.append(smName);
    realSb.append(TEXT_24);

    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; 
  }

  public String topLevelBorder(String clSmName, String className, String smName){
        StringBuilder sb = new StringBuilder();
    return this._topLevelBorder(0,sb,clSmName,className,smName).toString(); 
  }


  public String toString()
  {
    return super.toString() + "["+
            "hideActions" + ":" + getHideActions()+ "," +
            "hideGuards" + ":" + getHideGuards()+ "," +
            "showTransitionLabels" + ":" + getShowTransitionLabels()+ "," +
            "showGuardLabels" + ":" + getShowGuardLabels()+ "," +
            "output" + ":" + getOutput()+ "]" + System.getProperties().getProperty("line.separator") +
            "  " + "root" + "=" + (getRoot() != null ? !getRoot().equals(this)  ? getRoot().toString().replaceAll("  ","    ") : "this" : "null") + System.getProperties().getProperty("line.separator") +
            "  " + "model" + "=" + (getModel() != null ? !getModel().equals(this)  ? getModel().toString().replaceAll("  ","    ") : "this" : "null");
  }
}