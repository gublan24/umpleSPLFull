//moved from file 'Master_readyComposition.ump' but not inserted in their target features

mixset StateMachine { 
  class GeneratorHelper { 
    before Lable_StateMachine_1:postpare(UmpleModel)
  {
      postpareStateMachine(model);
    }  } 
} 

mixset Trace { 
  class GeneratorHelper { 
    before Lable_Trace_2:postpare(UmpleModel)
  {
      postpareTrace(model);
    }  } 
} 


mixset StateMachine { 
  class GeneratorHelper { 
    before Lable_StateMachine_3:postpare(UmpleClass)
  {
      postpareStateMachine(aClass);
    }  } 
} 



mixset Trace { 
  class GeneratorHelper { 
    before Lable_Trace_4:postpare(UmpleClass)
  {
      postpareTrace(aClass);
    }  } 
} 


mixset Mixset { 
  class GeneratorHelper { 
    before Lable_Mixset_5:toCode(List<CodeInjection>)
  {
	      if(inject.hasCodeLabel())
          continue;// handle the case when labels are used. // Do nothing  
        }  } 
} 


mixset RubyGeneratorIntMixset { 
  class GeneratorHelper { 
    before Lable_RubyGeneratorIntMixset_6:toCode(List<CodeInjection>)
  {
          comment = RubyGenerator.class.isInstance(generator)?"#":"//";
        }  } 
} 


mixset Class { 
  class UmpleGenerator { 
    before Lable_Class_7:initializeParser
  {
      parser.addGrammarFile("/class/umple_classes.grammar");
    }  } 
} 


mixset Trait { 
  class UmpleGenerator { 
    before Lable_Trait_8:initializeParser
  {
      parser.addGrammarFile("/trait/umple_traits.grammar");
    }  } 
} 


mixset FIXML { 
  class UmpleGenerator { 
    before Lable_FIXML_9:initializeParser
  {
      parser.addGrammarFile("/fixml/umple_fixml.grammar");
    }  } 
} 


mixset StateMachine { 
  class UmpleGenerator { 
    before Lable_StateMachine_10:initializeParser
  {
      parser.addGrammarFile("/stateMachine/umple_state_machines.grammar");
    }  } 
} 


mixset Trace { 
  class UmpleGenerator { 
    before Lable_Trace_11:initializeParser
  {
      parser.addGrammarFile("/trace/umple_traces.grammar");
    }  } 
} 


mixset Template { 
  class UmpleGenerator { 
    before Lable_Template_12:initializeParser
  {
      parser.addGrammarFile("/template/umple_template.grammar");
    }  } 
} 


mixset Structure { 
  class UmpleGenerator { 
    before Lable_Structure_13:initializeParser
  {
      parser.addGrammarFile("/strcture/umple_structure.grammar");
    }  } 
} 


mixset Layout { 
  class UmpleGenerator { 
    before Lable_Layout_14:initializeParser
  {
       parser.addGrammarFile("/layout/umple_layout.grammar");
    }  } 
} 


mixset Filter { 
  class UmpleGenerator { 
    before Lable_Filter_15:initializeParser
  {
      parser.addGrammarFile("/filter/umple_filter.grammar"); // TODO Under development
    }  } 
} 


mixset Mixset { 
  class UmpleGenerator { 
    before Lable_Mixset_16:initializeParser
  {
      parser.addGrammarFile("/mixset/umple_mixsets.grammar");
    }  } 
} 

mixset StateMachine { 
  class SuperCodeGenerator { 
    before Lable_StateMachine_17:testForPrimitiveInConstraint(ConstraintVariable)
  {
      if(variable instanceof ConstraintStateMachine)
      {
        return false;
      }
    }  } 
} 

mixset StateMachine { 
  class SuperCodeGenerator { 
    before Lable_StateMachine_18:translate(String,ConstraintVariable,boolean)
  {
      else if("state".equals(id))
      {
        return translate("stateOne", ((ConstraintState)cv).getState());
      }
      else if("statemachine".equals(id))
      {
        return translate("getFullMethod",((ConstraintStateMachine)cv).getStateMachine())+"()";
      }
    }  } 
} 


mixset StateMachine { 
  class UmpleClass { 
    before Lable_StateMachine_19:getMethodNames
  {
      for(StateMachine sm : this.getStateMachines())
      {
        String stateMachineName = sm.getName().substring(0, 1).toUpperCase() + sm.getName().substring(1);
        methodNames.add("set" + stateMachineName);
        methodNames.add("get" + stateMachineName);

        for(Event ev : sm.getEvents())
        {
          methodNames.add(ev.getName());
        }
      }
    }  } 
} 


mixset StateMachine { 
  class UmpleClass { 
    before Lable_StateMachine_20:hasImplementedMethodIncludingWithinParentClasses(Method)
  {
    if (numberOfStateMachines()>0){
    	for(StateMachine sm : getStateMachines()){
    		if (sm.getEventByMethod(comparedMethod)!=null){
    			return true;
    		}
    	}
    }
    }  } 
} 

mixset StateMachine { 
  class UmpleClass { 
    before Lable_StateMachine_21:propagateImmutabilityToAllRelationships(boolean)
  {
      if (this.hasStateMachines()) { return false; }
      }  } 
} 



mixset Filter { 
  class UmpleModel { 
    before Lable_Filter_22:generate
  {
      applyFilter(null);
    }  } 
} 

mixset Trait { 
  class UmpleModel { 
    before Lable_Trait_23:getDefaultAssociationPosition(Association)
  {
        if(getUmpleTraitTypeParameter(classOne) || getUmpleTrait(classOne)!=null) return null;
        if(getUmpleTraitTypeParameter(classTwo) || getUmpleTrait(classTwo)!=null) return null;
      }  } 
} 

mixset Association { 
  class UmpleModel { 
    before Lable_Association_24:markIncludedClasses(Filter)
  {
          if(f.hasAssociation())
          {
            markRelatedClass(f.getAssociationCount());
          }
        }  } 
} 

mixset Association { 
  class UmpleModel { 
    before Lable_Association_25:filterOutClasses
  {
            // Chop out it and its associations
            for(Association a : clazz.getAssociations())
            {      
            clazz.removeAssociation(a); // Remove from this end
            
            // Find the other end(s) and remove references too
            for (AssociationEnd ae : a.getEnds())
            {
                String endClassName = ae.getClassName();
                if(!endClassName.equals(clazz.getName()))
                {
                UmpleClass otherClass = getUmpleClass(endClassName);
                if(otherClass != null) {
                    otherClass.removeAssociation(a);
                }
                }
            }
            
            removeAssociation(a); // from model
            a.delete();
            }
            Object[] avs = clazz.getAssociationVariables().toArray();
            for(Object avo:  avs)
            {
            AssociationVariable av = (AssociationVariable)avo;
            AssociationVariable otherAv = av.getRelatedAssociation();
            if(otherAv != null) {
                otherAv.delete();
            }
            av.delete();
            }
            removeUmpleClass(clazz);
            clazz.delete();

          }  } 
}  


mixset Association { 
  class ConstraintOperator { 
    before Lable_Association_26:correctForCardinality(ConstraintVariable)
  {
      else if((variable instanceof ConstraintAssociation)&&value.contains("cardinality"))
      {
        ((ConstraintAssociation)variable).setNumberOf(true);
      }
    }  } 
} 

mixset StateMachine { 
  class UmpleTrait { 
    before Lable_StateMachine_27:propagateImmutabilityToAllRelationships(boolean)
  {
	      if (this.hasStateMachines()) { return false; } 
        }  } 
} 


mixset Association { 
  class UmpleTrait { 
    before Lable_Association_28:propagateImmutabilityToAllRelationships(boolean)
  {
          for (AssociationVariable av : associationVariables)
          {
            if (!immutabilityAssociationRulesSatisfied(av, true)) { return false; }
          }
        }  } 
} 


mixset StateMachine { 
  class GeneralTPApplied { 
    before Lable_StateMachine_29:GeneralTPApplied(GeneralTPApplied)
  {
      stateMachineModifiers = new ArrayList<>(another.getStateMachineModifiers());
    }  } 
} 


mixset StateMachine { 
  class GeneralTPApplied { 
    before Lable_StateMachine_30:GeneralTPApplied(GeneralTPApplied)
  {
      stateMachineTemplateSignatures = new ArrayList<>(another.getStateMachineTemplateSignatures());
    }  } 
}


mixset Association { 
  class AssociationVariable { 
    before Lable_Association_31:getTraced(String,UmpleClass)
  {
				for(AssociationTraceItem ast: td.getAssociationTraceItems())
				{
					if(( (method.equals("associationAdd")||method.equals("associationRemove")) && ast.getTraceCardinality()))
					{
						for(AssociationVariable variable: ast.getAssociationVariables())
						{
							if(variable.getName().equals(this.getName()))
								traceItems.add(ast);
						}

					}
					if((method.equals("associationAdd") && ast.getTraceAdd()))
					{
						for(AssociationVariable variable: ast.getAssociationVariables())
						{
							if(variable.getName().equals(this.getName()))
								traceItems.add(ast);
						}
					}
					if((method.equals("associationRemove") && ast.getTraceRemove()))
					{
						for(AssociationVariable variable: ast.getAssociationVariables())
						{
							if(variable.getName().equals(this.getName()))
								traceItems.add(ast);
						}
					}
				}
			}  } 
} 


mixset Association { 
  class ModelConstraintAssociation { 
    before Lable_Association_32:evaluate(UmpleClassifier)
  {
        for(Association association:uClass.getAssociations())
        {
          AssociationEnd theirs = null;
          AssociationEnd mine = null;
          if(association.getEnd(0).getClassName().equals(uClass.getName()))
          {
            theirs = association.getEnd(1);
            mine = association.getEnd(0);
          }
          else if(association.getEnd(1).getClassName().equals(uClass.getName()))
          {
            theirs = association.getEnd(0);
            mine = association.getEnd(1);
          }

          if(!theirs.getClassName().equals(getTarget()))
          {
            boolean isNotMyConcern = true;
            UmpleClass child = ((UmpleClass)uClassifier).getSourceModel().getUmpleClass(theirs.getClassName());

            if(child!=null)
            {
              UmpleClass parent = child.getExtendsClass();
              while(child!=null)
              {
                if(child.getName().equals(getTarget()))
                {
                  isNotMyConcern = false;
                }
                UmpleClass temp = parent;
                parent = child.getExtendsClass();
                child = temp;
              }
            }
            if(isNotMyConcern)
            {
              continue;
            }
          }

          String tBound = theirs.getMultiplicity().getBound();

          Integer rMax = 0;
          Integer rMin = 0;

          if(rightHandMultiplicity.getBound()!=null)
          {
            rMax = Integer.parseInt(rightHandMultiplicity.getBound().replace("*",""+Integer.MAX_VALUE));
            rMin = Integer.parseInt(rightHandMultiplicity.getBound().replace("*","0"));
          }
          else
          {
            rMax = Integer.parseInt(rightHandMultiplicity.getMaximum().replace("*",""+Integer.MAX_VALUE));
            rMin = Integer.parseInt(rightHandMultiplicity.getMinimum().replace("*","0"));
          }

          if("*".equals(rightHandMultiplicity.getBound()))
          {
          }
          else if(tBound==null)
          {
            Integer tMin = Integer.parseInt(theirs.getMultiplicity().getMinimum().replace("*","0"));
            Integer tMax = Integer.parseInt(theirs.getMultiplicity().getMaximum().replace("*",""+Integer.MAX_VALUE));

            if(tMax>rMax||tMin<rMin)
            {
              continue;
            }
          }
          else
          {
            Integer itBound = Integer.parseInt(tBound.replace("*","0"));
            if(itBound>rMax||itBound<rMin)
            {
              continue;
            }
          }

          tBound = mine.getMultiplicity().getBound();

          Integer lMax = 0;
          Integer lMin = 0;

          if(leftHandMultiplicity.getBound()!=null)
          {
            lMax = Integer.parseInt(leftHandMultiplicity.getBound().replace("*",""+Integer.MAX_VALUE));
            lMin = Integer.parseInt(leftHandMultiplicity.getBound().replace("*","0"));
          }
          else
          {
            lMax = Integer.parseInt(leftHandMultiplicity.getMaximum().replace("*",""+Integer.MAX_VALUE));
            lMin = Integer.parseInt(leftHandMultiplicity.getMinimum().replace("*","0"));
          }

          if("*".equals(leftHandMultiplicity.getBound()))
          {
          }
          else if(tBound==null)
          {
            Integer tMin = Integer.parseInt(mine.getMultiplicity().getMinimum().replace("*","0"));
            Integer tMax = Integer.parseInt(mine.getMultiplicity().getMaximum().replace("*",""+Integer.MAX_VALUE));

            if(tMax>lMax||tMin<lMin)
            {
              continue;
            }
          }
          else
          {
            Integer itBound = Integer.parseInt(tBound.replace("*","0"));
            if(itBound>lMax||itBound<lMin)
            {
              continue;
            }
          }
          return ModelConstraint.SUCCESS;
        }
        }  } 
} 


mixset Association { 
  class AttributeTraceItem { 
    before Lable_Association_33:trace(CodeTranslator,Object,String,UmpleClass,String...)
  {
				  else if(o instanceof AssociationVariable)
				  {
					name = gen.translate("associationMany",(AssociationVariable)o);
				  }
				}  } 
} 


mixset StateMachine { 
  class StateMachineTraceItem { 
    before Lable_StateMachine_34:trace(CodeTranslator,Object,String,UmpleClass,String...)
  {
				else if(o instanceof State)
				{
					State state = (State)o;
					name = getStateMachine().getName()+"\"";
					obj = state.getName();
					for( Action a : ((State) o).getActions() )
					{
						if( this.getEntry() && a.getActionType().equals("entry") )
							obj += ",actionUmpleLine=" + a.getPosition().getLineNumber();
						if( this.getExit() && a.getActionType().equals("exit") )
							obj += ",actionUmpleLine=" + a.getPosition().getLineNumber();
					}
					}
				else if(o instanceof Activity)
				{
					Activity act = (Activity)o;
					State state = act.getState();
					name = getStateMachine().getName()+"\"";
					obj = state.getName();
					if( methodname.equals("sm_da"))
						obj += ",doActivitedStarted";
					else if(methodname.equals("sm_di"))
						obj += ",doActivitedInterrupted";
				}
			}  } 
} 


mixset Association { 
  class AssociationTraceItem { 
    before Lable_Association_35:trace(CodeTranslator,Object,String,UmpleClass,String...)
  {
		for(AssociationVariable ass: uClass.getAssociationVariables())
		{
			if(ass.equals(o))
			{
				String type = ((AssociationVariable)o).getType();
				String name = "";
				String extra = "";
				String obj = "";
				String accessor = gen.translate("traceAccessor",this);
				String concatinator = gen.translate("traceConcatinator",this);
				String comma = concatinator+"\",\""+concatinator;
				String tracerName = Character.toUpperCase(getTracerType().charAt(0)) + getTracerType().substring(1);
				String messageLayout = "{0}"+comma+"{1}"+concatinator+"\",{2},{3},{4},\""+concatinator+"{5}"+concatinator+"\",{6},{7},\"";
				mixset Association {
				  if(o instanceof AssociationVariable)
				  {
					name = gen.translate("associationMany",(AssociationVariable)o);
			  	  }
				}

				//         if(type==null||"".equals(type)||"Boolean".equals(type)||"boolean".equals(type)||"String".equals(type)||"int".equals(type)||"Integer".equals(type)||"float".equals(type)||"Float".equals(type)||"double".equals(type)||"Double".equals(type)||"Time".equals(type)||"Date".equals(type))
				//         {
				//           obj = name;
				//         }
				//         else
				//         {
				//           obj = name+"(\"+"+StringFormatter.format(gen.translate("traceIdentifier",this),name)+"+\")";
				//           name += gen.translate("traceFormatNonPrimitive",this);
				//         }

				for(String str: args){
					extra+=concatinator+str;
				}
				if(getTraceDirective().getTraceRecord()!=null)
				{
					for(Attribute record:getTraceDirective().getTraceRecord().getAttributes())
					{
						extra+=comma+gen.translate("attribute"+(record.getIsList()?"Many":"One"),record);
					}
					if(getTraceDirective().getTraceRecord().numberOfRecord()>0)
					{
						extra+= concatinator+"\"";
						for(String record:getTraceDirective().getTraceRecord().getRecord())
						{
							extra+=","+record.replace("\"","");
						}
						extra+= "\"";
					}
				}
				String message = messageLayout+extra;
				message = StringFormatter.format(
						message,gen.translate("traceTimestamp",this),
						gen.translate("traceThread",this),
						getPosition().getFilename().replace("\\","\\\\"),
						getPosition().getLineNumber(),
						uClass.getName()+"+"+type,
						StringFormatter.format(gen.translate("traceIdentifier",this),gen.translate("traceSelf",this)),
						methodname,
						name        
						);

				message = TraceItemUtil.prepareTraceMessage(getTraceDirective(),gen,this,message);

				message = StringFormatter.format(getExtremities(gen, name),message);
				message = GeneratorHelper.doIndent(message,gen.translate("traceIndent",this));
				if(getTraceDirective().getPostfix().getExecuteClause()!=null)
				{
					String execute = getTraceDirective().getPostfix().getExecuteClause();
					execute = GeneratorHelper.doIndent(execute,gen.translate("traceIndent",this));
					message += "\n" + execute;
				}
				return message;
			}
		}
		}  } 
}

mixset Trait { 
  class PreconditionAnalyzer { 
    before Lable_Trait_36:analyze(Token)
  {
    else if (uClassifier instanceof UmpleTrait)
    {
      ((UmpleTrait)(uClassifier)).addPreCond((Precondition)rawLine);  
    }  
    }  } 
} 


mixset Trait { 
  class PostconditionAnalyzer { 
    before Lable_Trait_37:analyze(Token)
  {
      else if (uClassifier instanceof UmpleTrait)
      {
        ((UmpleTrait)(uClassifier)).addPostCond((Postcondition)rawLine);  
      }
    }  } 
} 



mixset Trait { 
  class InvariantAnalyzer { 
    before Lable_Trait_38:analyze(Token)
  {
      else if (uClassifier instanceof UmpleTrait)
      {
        ((UmpleTrait)uClassifier).addConstraintTree(rawLine);  
      }
    }  } 
} 


mixset Trait { 
  class ConstraintNameNameAnalyzer { 
    before Lable_Trait_39:retrieveClass(ConstraintTree,UmpleClassifier)
  {
              uClass = previouslyFoundAttribute.getAttribute().getUmpleTrait();
              UmpleModel model = ((UmpleTrait)uClass).getSourceModel();
              uClass = model.getUmpleClass(previouslyFoundAttribute.getAttribute().getType());
              }  } 
} 


mixset Trait { 
  class ConstraintNameNameAnalyzer { 
    before Lable_Trait_40:retrieveClass(ConstraintTree,UmpleClassifier)
  {
              uClass = previouslyFoundAssociation.getAssociation().getUmpleTrait();
              UmpleModel model = ((UmpleTrait)uClass).getSourceModel();
              uClass = model.getUmpleClass(previouslyFoundAssociation.getAssociation().getType());
              }  } 
}


mixset Trait { 
  class ConstraintNameNameAnalyzer { 
    before Lable_Trait_41:generateConstraintName(UmpleClassifier,String,Boolean)
  {
        attribute = ((UmpleTrait)(uClassifier)).getAttribute(value);
      }  } 
} 

mixset Trait { 
  class ConstraintNameNameAnalyzer { 
    before Lable_Trait_42:generateConstraintName(UmpleClassifier,String,Boolean)
  {
          association = ((UmpleTrait)(uClassifier)).getAssociationVariable(value);
        }  } 
} 


mixset StateMachine { 
  class ConstraintNameNameAnalyzer { 
    before Lable_StateMachine_43:generateConstraintName(UmpleClassifier,String,Boolean)
  {
        StateMachine stateMachine = null;
        if(uClassifier instanceof UmpleClass)
        {
          stateMachine = ((UmpleClass)uClassifier).getStateMachine(value);
        }
        }  } 
} 

mixset Trait { 
  class ConstraintNameNameAnalyzer { 
    before Lable_Trait_44:generateConstraintName(UmpleClassifier,String,Boolean)
  {
          mixset StateMachine {
            else if(uClassifier instanceof UmpleTrait)
            {
              stateMachine = ((UmpleTrait)uClassifier).getStateMachine(value);
            }
          }
        }  } 
} 

mixset StateMachine { 
  class ConstraintNameNameAnalyzer { 
    before Lable_StateMachine_45:generateConstraintName(UmpleClassifier,String,Boolean)
  {
        if(stateMachine!=null)
        {
          ConstraintStateMachine name = new ConstraintStateMachine(stateMachine);
          return name;
        }
        }  } 
} 

mixset Structure { 
  class ConstraintNameNameAnalyzer { 
    before Lable_Structure_46:generateConstraintName(UmpleClassifier,String,Boolean)
  {
            Port port = null;
            if (uClassifier instanceof UmpleClass)
            {
              port = ((UmpleClass)(uClassifier)).getPort(value);
            }
            if(port!=null)
            {
              ConstraintPort name = new ConstraintPort(port);
              return name;
            }
        }  } 
} 


mixset Trait { 
  class ConstraintNameNameAnalyzer { 
    before Lable_Trait_47:generateConstraintName(UmpleClassifier,String,Boolean)
  {
    else if(uClassifier instanceof UmpleTrait)
    {
      for(UmpleTrait uTrait:((UmpleTrait)uClassifier).getExtendsTraits())
      {
        ConstraintVariable var = generateConstraintName(uTrait,value,hasParameter);
        if(!(var instanceof ConstraintUnassignedName))
        {
          return var;
        }
      }
    }      
    }  } 
}

mixset Constraint { 
  class UmpleInternalParser { 
    before Lable_Constraint_48:init
  {
      parser.addGrammarFile("/constraint/umple_constraints.grammar");  // TODO Under development
    }  } 
} 

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_49:analyze(boolean)
  {
        secondPostTokenAnalysis();
      }  } 
} 

mixset Attribute { 
  class UmpleInternalParser { 
    before Lable_Attribute_50:analyze(boolean)
  {
        mixset Method {
          checkDefaultedNameConflict();
        }
      }  } 
} 


mixset FeatureModel { 
  class UmpleInternalParser { 
    before Lable_FeatureModel_51:analyze(boolean)
  {
        analyzeFeatureModel(); // lastly to analyze the feature model after all mixsets are added to umple model. 
      }  } 
} 

mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_52:analyzeToken(Token,int)
  {
      analyzeMixsetUseStatement(t, analysisStep);
    }  } 
} 


mixset Class { 
  class UmpleInternalParser { 
    before Lable_Class_53:analyzeToken(Token,int)
  {
      analyzeClassToken(t,analysisStep);
    }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_54:analyzeToken(Token,int)
  {
      analyzeTraitToken(t,analysisStep);
    }  } 
} 


mixset Template { 
  class UmpleInternalParser { 
    before Lable_Template_55:analyzeToken(Token,int)
  {
      analyzeTemplateToken(t,analysisStep);
    }  } 
} 


mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_56:analyzeToken(Token,int)
  {
      analyzeStateMachineToken(t,analysisStep);
    }  } 
} 


mixset Structure { 
  class UmpleInternalParser { 
    before Lable_Structure_57:analyzeToken(Token,int)
  {
      analyzeComponentToken(t,analysisStep);
    }  } 
} 


mixset Trace { 
  class UmpleInternalParser { 
    before Lable_Trace_58:analyzeToken(Token,int)
  {
      analyzeTraceToken(t,analysisStep);
    }  } 
} 


mixset Filter { 
  class UmpleInternalParser { 
    before Lable_Filter_59:analyzeToken(Token,int)
  {
      analyzeFilterToken(t,analysisStep);
    }  } 
} 


mixset Layout { 
  class UmpleInternalParser { 
    before Lable_Layout_60:analyzeToken(Token,int)
  {
      analyzeLayoutToken(t,analysisStep);
    }  } 
} 


mixset FIXML { 
  class UmpleInternalParser { 
    before Lable_FIXML_61:analyzeToken(Token,int)
  {
      analyzeFIXML(t, analysisStep);
    }  } 
} 


mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_62:analyzeToken(Token,int)
  {
      analyzeMixsetToken(t, analysisStep);
    }  } 
} 


mixset FeatureModel { 
  class UmpleInternalParser { 
    before Lable_FeatureModel_63:analyzeToken(Token,int)
  {
      analyzeRequireStatement(t, analysisStep);
    }  } 
} 

mixset AspectInjection { 
  class UmpleInternalParser { 
    before Lable_AspectInjection_64:analyzeToken(Token,int)
  {
      analyzeInjectionToken(t, analysisStep);
    }  } 
} 


mixset Class { 
  class UmpleInternalParser { 
    before Lable_Class_65:analyzeToken(Token,UmpleClass,int)
  {
      analyzeClassToken(t,aClass,analysisStep);
    }  } 
} 



mixset Constraint { 
  class UmpleInternalParser { 
    before Lable_Constraint_67:analyzeDependentTokens(Token,UmpleClass,int)
  {
      if (t.is("modelConstraintBody"))
      {
        analyzeModelConstraint(t,aClass);
      }
    }  } 
} 


mixset AspectInjection { 
  class UmpleInternalParser { 
    before Lable_AspectInjection_68:analyzeDependentTokens(Token,UmpleClass,int)
  {
      else if (t.is("beforeCode") || t.is("afterCode"))
      {
        analyzeInjectionCode(t,aClass);
      }
    }  } 
} 


mixset Trace { 
  class UmpleInternalParser { 
    before Lable_Trace_69:analyzeDependentTokens(Token,UmpleClass,int)
  {
      analyzeTraceToken(t,aClass);
    }  } 
} 


mixset Layout { 
  class UmpleInternalParser { 
    before Lable_Layout_70:analyzeDependentTokens(Token,UmpleClass,int)
  {
      analyzeLayoutToken(t,aClass,analysisStep);
    }  } 
} 


mixset Class { 
  class UmpleInternalParser { 
    before Lable_Class_71:postTokenAnalysis
  {
      if (getParseResult().getWasSuccess())
      {
        postTokenClassAnalysis();
      }
    }  } 
} 


mixset Trace { 
  class UmpleInternalParser { 
    before Lable_Trace_72:postTokenAnalysis
  { 
      if (getParseResult().getWasSuccess())
      {
        postTokenTraceAnalysis();
      }
    }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_73:postTokenAnalysis
  {
      if (getParseResult().getWasSuccess())
      {
        postTokenTraitAnalysis();
      }  
      if (getParseResult().getWasSuccess())
      {
        applyTraits();
        //Issue 686
        checkCodeInjections();
      } 
     }  } 
} 


mixset Layout { 
  class UmpleInternalParser { 
    before Lable_Layout_74:postTokenAnalysis
  {
      if (getParseResult().getWasSuccess())
      {
        postTokenLayoutAnalysis();
      }
    }  } 
} 


mixset Template { 
  class UmpleInternalParser { 
    before Lable_Template_75:postTokenAnalysis
  {
      if (getParseResult().getWasSuccess()) {
        postTokenTemplateAnalysis();
      }
    }  } 
} 


mixset Structure { 
  class UmpleInternalParser { 
    before Lable_Structure_76:postTokenAnalysis
  {
      if (getParseResult().getWasSuccess()) {
        postTokenComponentAnalysis();
      }
    }  } 
} 


mixset Constraint { 
  class UmpleInternalParser { 
    before Lable_Constraint_77:postTokenAnalysis
  {
      if (getParseResult().getWasSuccess())
      {
        postTokenModelConstraintAnalysis();
      }
    }  } 
} 


mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_78:analyzeClassToken(Token,int)
  {
      // add parsed files to parsedUmpfiles hashMap.
      String umpFileName = t.getSubToken("use").getValue();
      if(! parsedUmpfiles.keySet().contains(umpFileName))
      parsedUmpfiles.put(umpFileName, true);
      }  } 
} 


mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_79:analyzeClassToken(Token,UmpleClass,int)
  {
      else if (token.getValue("mixsetDefinition") != null)  {
        analyzeMixsetBodyToken(token);
      }
    }  } 
} 


mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_80:postTokenClassAnalysis
  {
      addAutogeneratedMethodsForStateMachines();
      }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_81:checkAssociationsForDistributed
  { 
         if (associationIsBetweenClassAndTrait(association)){continue;} 
       }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_82:checkAssociationsForDistributed
  {
      if(getModel().getUmpleTraitTypeParameter(myEnd.getClassName()) || getModel().getUmpleTrait(myEnd.getClassName())!=null) return ;
      if(getModel().getUmpleTraitTypeParameter(yourEnd.getClassName()) || getModel().getUmpleTrait(yourEnd.getClassName())!=null) return ;
      }  } 
} 


mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_83:analyzeAllAssociations(Token)
  {
        if (token.is("mixsetDefinition"))
        {
          analyzeMixsetBodyToken(token);
        } 
      }  } 
} 


mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_84:analyzeClass(Token)
  {
    //Reset number of activeObjects with each class definition
    this.numberOfActiveObjects = 1;
    }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_85:addExtendsTo(Token,UmpleClassifier,Map<UmpleClassifier,List<String>>,Map<UmpleClassifier,List<Token>>)
  {
          processGTemplateParameterAssignment(extendsToken, aClassifier, extendName);
        }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_86:verifyClassesInUse
  {
        boolean isTraitTypeParameter = model.getUmpleTraitTypeParameter(e.getValue());
        boolean isATrait = model.getUmpleTrait(e.getValue()) != null;
        condToCheck = condToCheck && !isATrait && !isTraitTypeParameter;
      }  } 
} 

mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_87:addUnlinkedExtends
  {
          isTraitCheck = isUmpleTrait(extendName);
        }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_88:addUnlinkedExtends
  {
              UmpleTrait parent = model.getUmpleTrait(extendName);     
              boolean wasSet = child.addExtendsTrait(parent);
              if (!wasSet)
              {
                Position pos;
                try
                {
                  pos = extendsToken.get(i).getPosition();
                }
                catch(Exception e)
                {
                  pos = new Position("",0,0,0);
                }
                // TODO 1: the error code should be chnaged.            
                setFailedPosition(pos, 16, child.getName(), parent.getName());
                return;
              }
            }  } 
} 

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_89:addUnlinkedKeys
  {          
            if(c.hasStateMachines())  
            {
                for(StateMachine aStateMachine : c.getStateMachines())
                {
                    if(aStateMachine.getName().equals(tokenVal))
                    {
                        tokenMatch = true;
                        break;
                    }
                }
            }
            }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_90:addImplementedMethodsFromInterface(List<UmpleInterface>,UmpleClass)
  {
            hasMethodTraitsCheck = !(uClass.hasMethodInTraits(aMethod));
          }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_91:createSpecializedLinks
  {
        if (model.getUmpleTrait(aLeftEnd.getClassName()) != null || model.getUmpleTrait(aRightEnd.getClassName()) != null)
        {
          continue;
        }
      }  } 
} 



mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_92:createSpecializedLinks
  {
          if (model.getUmpleTrait(bLeftEnd.getClassName()) != null || model.getUmpleTrait(bRightEnd.getClassName()) != null)
          {
            continue;
          }
       }  } 
} 



mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_93:checkSingletonAssociations
  { 
        if (associationIsBetweenClassAndTrait(association)){continue;} 
      }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_94:checkSingletonAssociations
  {
        if(getModel().getUmpleTraitTypeParameter(myEnd.getClassName()) || getModel().getUmpleTrait(myEnd.getClassName())!=null) return ;
        if(getModel().getUmpleTraitTypeParameter(yourEnd.getClassName()) || getModel().getUmpleTrait(yourEnd.getClassName())!=null) return ;
      }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_95:addUnlinkedAssociations
  { 
         if (associationIsBetweenClassAndTrait(association)){continue;}
       }  } 
} 


mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_96:analyzeMethod(Token,UmpleElement,boolean)
  {
              methodCode = processInlineMixset(token.getValue(), meth);
            }  } 
} 


mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_97:analyzeMethod(Token,UmpleElement,boolean)
  {
        if (uClass.getStateDependentMethods().contains(aMethod) && !aMethod.isIsAbstract()) {
          uClass.addStateDependentMethod(aMethod, null);
        }
        else
        }  } 
} 


mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_98:analyzeMethod(Token,UmpleElement,boolean)
  {
        stateDependentMethodsflag = !uClass.getStateDependentMethods().contains(aMethod);
        }  } 
} 



mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_99:analyzeMethod(Token,UmpleElement,boolean)
  {
    else if (uElement instanceof UmpleTrait)
    {
        UmpleTrait uTrait = (UmpleTrait) uElement;
        if (method.is("abstractMethodDeclaration")) aMethod.setIsAbstract(true);
        
        // Add Getter/Setter/Constructor to Class
     //   boolean shouldAddMethod = isConstructorOrGetSet(uClass, aMethod);
        if (!uTrait.hasMethod(aMethod)) // && shouldAddMethod)
        {
          String msg = "Please do not modify the following method.";
      aMethod.addCommentAt(new Comment(msg),0);
          msg = "The following method comes from trait "+uTrait.getName()+".";
      aMethod.addCommentAt(new Comment(msg),1);
      msg = "Trait "+uTrait.getName()+" has been used in classes: ";
      aMethod.addCommentAt(new Comment(msg),2);
          uTrait.addMethod(aMethod); 
        } 

        // Make class abstract if an abstract method was added
        if(uTrait.hasMethod(aMethod) && aMethod.getIsAbstract()) 
        {
          uTrait.setIsAbstract(true);
          uTrait.addUnimplementedMethod(aMethod);
        }

        // If method not added to class, add it to list of
        // unimplemented methods
        if(!uTrait.hasMethod(aMethod)) 
        {
          uTrait.addUnimplementedMethod(aMethod);
        }     
    }
    }  } 
} 


mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_100:checkCodeInjectionValidity(Token,UmpleClass,String)
  {
          stateDependentMethodsFlag = uClass.getStateDependentMethods().stream().anyMatch(m -> m.getName().equals(operationFinal));
        }  } 
} 

mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_101:makeCodeInject(Token,CodeInjection,CodeBlock,UmpleClassifier)
  {
        aspectCode = processInlineMixset(sub.getValue(), null);
        }  } 
} 


mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_102:analyzeExtraCode(Token,UmpleClass)
  {

    //This is a catch all and will be used less often as the grammar gets updated.
    if(extraCodeIsMalformedStateMachine(token)) setFailedPosition(token.getPosition(), 1006, "");
    }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_103:fixImportFromDefaultPackage
  { 
             if (associationIsBetweenClassAndTrait(association)){continue;} 
           }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_104:fixImportFromDefaultPackage
  {
            if(getModel().getUmpleTraitTypeParameter(myEnd.getClassName()) || getModel().getUmpleTrait(myEnd.getClassName())!=null) return ;
            if(getModel().getUmpleTraitTypeParameter(yourEnd.getClassName()) || getModel().getUmpleTrait(yourEnd.getClassName())!=null) return ;
          }  } 
} 
//


mixset Mixset { 
  class TemplateDefinitionWalker { 
    before Lable_Mixset_157:analyzeToken(Token,TemplateTokenAnalyzer,int)
  {
          processInlineMixset(aToken);
        }  } 
} 

mixset StateMachine { 
  class CompositeStructureTokenAnalyzer { 
    before Lable_StateMachine_156:analyzeInvariantConstraint(Token)
  {
			     else if (invariantToken.is("statemachineExpr"))
			     {
				   rawLine.addElementAll(analyzeStateMachineConstraintExpression(invariantToken,null));
			     }
			   }  } 
} 

mixset Association { 
  class CompositeStructureTokenAnalyzer { 
    before Lable_Association_155:analyzeInvariantConstraint(Token)
  {
			     else if (invariantToken.is("associationExpr"))
			     {
				   rawLine.addElementAll(analyzeAssociationConstraintExpression(invariantToken,null));
			     }
			   }  } 
} 


mixset Association { 
  class CompositeStructureTokenAnalyzer { 
    before Lable_Association_154:analyzeAssociationConstraintExpression(Token,UmpleClassifier)
  {
			  else if(sub.is("associationLit"))
			  {
				rawLine.addElementAll(analyzeAssociationLiteralConstraintExpression(sub,uClassifier,card,all,true,subject,operator));
			  }
			}  } 
} 


mixset StateMachine { 
  class CompositeStructureTokenAnalyzer { 
    before Lable_StateMachine_153:analyzeConstraint(Token,UmpleClassifier)
  {
	     else if (invariantToken.is("statemachineExpr"))
	     {
		   rawLine.addElementAll(analyzeStateMachineConstraintExpression(invariantToken,uClassifier));
	     }
	   }  } 
} 


mixset Association { 
  class CompositeStructureTokenAnalyzer { 
    before Lable_Association_152:analyzeConstraint(Token,UmpleClassifier)
  {
		else if (invariantToken.is("associationExpr"))
		{
			rawLine.addElementAll(analyzeAssociationConstraintExpression(invariantToken,uClassifier));
		}
	   }  } 
} 


mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_151:analyzeInjectionCode(Token,UmpleClassifier)
  {
      // check if the aspect needs to be injected before/after a label.
      if(codeLabelToken != null)
      injection.setInjectionlabel(codeLabelToken.getValue());
    }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_150:analyzeToplevelInjectionCode(Token,int,String)
  {
          for (String umpleTraitName:traitNames)
          {
            for (Method m : model.getUmpleTrait(umpleTraitName).getMethods())
            {
              methodNames.add(m.getName());
            }
          }
        }  } 
}


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_149:analyzeToplevelInjectionCode(Token,int,String)
  {
              traitNames = (ArrayList<String>) mapElement.getValue();
              ArrayList<String> newTraitNames = (ArrayList<String>) traitNames.clone();
              for (String traitName : traitNames)
              {
                if (model.getUmpleTrait(traitName) == null)
                {
                  newTraitNames.remove(traitName);
                }
              } 
              traitNames = newTraitNames;
            }  } 
}


mixset FeatureModel { 
  class UmpleInternalParser { 
    before Lable_FeatureModel_148:parseMixsetNotUsedToken(Token)
  {
      //parse require statments. 
      analyzeRequireStatement(token, 2);
    }  } 
} 


mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_147:getMixsetFragmentWithEnclosingElement(Token,String)
  {
      else if (token.is("associationDefinition"))
      {
        tokenKey = "name"; 
        prefix ="association";
      }
    }  } 
} 

mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_146:getMixsetFragmentWithEnclosingElement(Token,String)
  {
      else if (token.is("traitDefinition"))
      {
        tokenKey = "name"; 
        prefix ="trait";
        returnMixsetBody= true;
      }
    }  } 
} 


mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_145:getMixsetFragmentWithEnclosingElement(Token,String)
  {
      else if (token.is("state"))
      {
        tokenKey = "stateName";
      }
      else if (token.is("inlineStateMachine"))
      {
        tokenKey =  "name";
      }
    }  } 
} 


mixset Class { 
  class UmpleInternalParser { 
    before Lable_Class_144:getMixsetFragmentWithEnclosingElement(Token,String)
  {
      if (token.is("classDefinition"))
      {
        tokenKey = "name"; 
        prefix ="class";
        returnMixsetBody= true;
      }
    }  } 
} 

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_143:analyzeModelEnumInClass(UmpleClass,UmpleEnumeration)
  {   
     // Check if the class's state machines conflict with the enumeration, and if any of its state 
     // machine's events use the enumeration in their parameters
     for (StateMachine sm : uClass.getStateMachines()) {
       if (classUsesEnum) {
         if (uEnum.hasSameName(sm.getName())) {
           // Enumeration Conflicts with State Machine Error
           getParseResult().addErrorMessage(new ErrorMessage(97, 
                                                             uEnum.getPosition(), 
                                                             uEnum.getName(), 
                                                             "" + uEnum.getPosition().getLineNumber(),
                                                             sm.getName(),
                                                             uClass.getName()));
           return;
         }
       }
       for (Event e : sm.getAllEvents()) {
         for (MethodParameter p : e.getParams()) {
           if (uEnum.hasSameName(p.getType())) {
             if (!classUsesEnum && uEnum.hasSameName(sm.getName())) {
               // Enumeration Conflicts with State Machine Error
               getParseResult().addErrorMessage(new ErrorMessage(97, 
                                                                uEnum.getPosition(), 
                                                                uEnum.getName(), 
                                                                "" + uEnum.getPosition().getLineNumber(),
                                                                sm.getName(),
                                                                uClass.getName()));
               return;
             } else {
               classUsesEnum = true;
           }
         }
       }
      }
     }
    }  } 
} 

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_142:postTokenClassEnumerationAnalysis(UmpleClass)
  {
      // Check if the enumeration conflicts with any state machines, and if the enumeration is used as
      // event parameters
      for (StateMachine sm : uClass.getStateMachines()) {
        if (uEnum.hasSameName(sm.getName())) {
          // Enumeration Conflicts with State Machine Error
          getParseResult().addErrorMessage(new ErrorMessage(97, 
                                                            uEnum.getPosition(), 
                                                            uEnum.getName(), 
                                                            "" + uEnum.getPosition().getLineNumber(),
                                                            sm.getName(),
                                                            uClass.getName()));
          return;
        }
        for (Event e : sm.getAllEvents()) {
          for (MethodParameter p : e.getParams()) {
            if (uEnum.hasSameName(p.getType()) && otherClass != null) {
              // Event Parameter Ambiguity Warning
              getParseResult().addErrorMessage(new ErrorMessage(103, 
                                                                uEnum.getPosition(), 
                                                                uEnum.getName(), 
                                                                "" + uEnum.getPosition().getLineNumber(),
                                                                p.getName(),
                                                                e.getName(),
                                                                sm.getName(),
                                                                otherClass.getName()));
            }
          }
        }
      }
      }  } 
}


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_141:postTokenModelEnumerationAnalysis
  {      
      // Check that the enumeration doesn't conflict with any traits
      for (UmpleTrait uT : model.getUmpleTraits()) {
        if (uEnum.hasSameName(uT.getName())) {
          // Enumeration Naming Conflict
          getParseResult().addErrorMessage(new ErrorMessage(96,
                                                            uEnum.getPosition(), 
                                                            uEnum.getName(), 
                                                            "" + uEnum.getPosition().getLineNumber(),
                                                            "" + uT.getPosition(0).getLineNumber()));
          return;
        }
      }
      }  } 
} 

mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_140:analyzeFilterToken(Token,int)
  {
            if(t.is("association"))
	        {
	          addAssociationValue(f,t);
          	}
          }  } 
} 


mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_139:layoutNewElements
  {
      // Layout associations
      for (int i=0; i<model.numberOfAssociations(); i++)
      {
        Association a = model.getAssociation(i);
        
        if (associationIsBetweenClassAndInterface (a)){continue;}
        if (associationIsBetweenClassAndTrait (a)){continue;}
        
        int numberOfPositions = a.numberOfPositions();

        if (numberOfPositions < 2)
        {
          Coordinate[] defaults = model.getDefaultAssociationPosition(a);
      if (defaults==null) continue;
          a.addPosition(defaults[0]);
          a.addPosition(defaults[1]);
          a.getPosition(0).setStatus(Coordinate.Status.Defaulted);
          a.getPosition(1).setStatus(Coordinate.Status.Defaulted);
        }
      }
    }  } 
} 

mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_138:analyzeLayoutToken(Token,UmpleClassifier,int)
  {
      else if (token.is("associationPosition"))
      {
        String name = token.getValue("name");
        Association assoc = model.getAssociation(name);

        if (assoc != null)
        {
          assoc.setName(name);
          for(Token position : token.getSubTokens())
          {
            if (position.is("coordinate"))
            {
              assoc.addPosition(new Coordinate(position.getIntValue("x"),position.getIntValue("y"),0,0));
            }
          }
        }
      }
    }  } 
} 


mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_137:traceItemType(Token)
  {
    // --- check if association
    for( AssociationVariable aVar : aClass.getAssociationVariables() )
    {
      if( traceToken.getValue("traceEntity").equals(aVar.getName()))
      {
        traceItemType = 3;
      }
    }

    for( Association a : aClass.getAssociations() )
    {
      if( a.getName().contains(traceToken.getValue("traceEntity") ))
      {
        traceItemType = 3;
      }
    }
    }  } 
} 



mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_136:traceItemType(Token)
  {
      // --- check if state machine
      for( StateMachine sVar : aClass.getStateMachines() )
      {
        if( traceToken.getValue("traceEntity").equals(sVar.getName()))
        {
          traceItemType = 2;
        }
        for( State s : sVar.getStates() )
        {
          if( traceToken.getValue("traceEntity").equals(s.getName()) || traceToken.getValue("traceEntity").equals(sVar.getName()+"."+s.getName()) )
          {
            traceItemType = 2;
          }
          for( Transition t : s.getTransitions() )
            if( traceToken.getValue("traceEntity").equals(t.getEvent().getName()))
            {
              traceItemType = 2;
            }
          // check if traced state is already found
          // no need to check nested states
          if( traceItemType == 2 ) return traceItemType;
          if(s.hasNestedStateMachines())
          {
            traceItemType = checkNestedStateMachine(traceToken.getValue("traceEntity"),s);	
          }
        }
      }
    }  } 
} 


mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_135:traceItemType(Token)
  {  
    attr = attr==null?aClass.getAssociationVariable(traceToken.getValue("traceEntity")):attr;
    }  } 
} 


mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_134:anaylzeTraceWildCard(Token)
  {
    //------------- trace all associations [wildcard]
    if( traceToken.getValue("traceEntity").toLowerCase().equals("allassociations") )
    {
      for( AssociationVariable assoc : uClass.getAssociationVariables() )
      {
      	tracedAssoc.setPosition(traceToken.getPosition());
      	tracedAssoc.addAssociationVariable(assoc);
      	tracedAssoc.setTraceAdd(true);
      	tracedAssoc.setTraceRemove(true);
      }
    }
    }  } 
} 

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_133:analyzeTraceItem(Token)
  {
      if( traceItemType == 2 )
      {
        analyzeStateMachineTraceItem(traceToken);
      }
    }  } 
}

mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_132:analyzeTraceStatement(UmpleClass,Token)
  {
          attr = traceDirective.getUmpleClass().getAssociationVariable(token.getValue("LHS"));
          }  } 
} 

mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_131:analyzeTraceStatement(UmpleClass,Token)
  {
          tracedAssoc.setConstraint(constraint);
          }  } 
} 

mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_130:analyzeTraceStatement(UmpleClass,Token)
  {
    tracedAssoc = new AssociationTraceItem(traceDirective);
    }  } 
} 

mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_129:analyzeTransition(boolean,Token,State,String)
  {
        if (fromState.getStateMachine().getRootStateMachine().getUmpleClass()==null){
    		uClassifier = fromState.getStateMachine().getRootStateMachine().getUmpleTrait();
    	  }
      }  } 
} 


mixset Trace { 
  class UmpleInternalParser { 
    before Lable_Trace_128:populateStateMachine(Token,StateMachine,UmpleClassifier)
  {
        if(stateToken.is("trace"))
        {
          if (uClassifier instanceof UmpleClass) {
          analyzeTraceStatement((UmpleClass)uClassifier,stateToken); 
        } else {
          //TODO--- trait's functionality for trace;
        }
        }
      }  } 
}
mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_127:analyzeStateMachine(Token,UmpleClassifier)
  {
      analyzeMixsetDefinition(innerMixsetTokens, sm);
    }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_126:analyzeStateMachine(Token,UmpleClassifier)
  {
          if (uClassifier instanceof UmpleTrait) {
          //TODO --Trait's code
          setFailedPosition(stateMachineToken.getPosition(), 15, uClassifier.getName());
        }
      }  } 
} 

mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_125:analyzeStateMachine(Token,UmpleClassifier)
  {
       if (uClassifier instanceof UmpleTrait) {
    	wasSet = sm.setUmpleTrait((UmpleTrait)uClassifier);
     }
    }  } 
} 
 
 mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_124:analyzeStateMachine(Token,UmpleClassifier)
  {
            if (uClassifier instanceof UmpleTrait){
            sm.setUmpleTrait((UmpleTrait)uClassifier);
          } 
        }  } 
} 



mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_123:analyzedReferencedStateMachine(Token,UmpleClassifier)
  {
        else if (uClassifier instanceof UmpleTrait) {
          //TODO --Trait's code
          setFailedPosition(stateMachineToken.getPosition(), 15, uClassifier.getName());
        }
      }  } 
} 
mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_122:analyzedReferencedStateMachine(Token,UmpleClassifier)
  {
        else if (uClassifier instanceof UmpleTrait) {
        wasSet = sm.setUmpleTrait((UmpleTrait)uClassifier);
      }
    }  } 
} 


mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_121:analyzedReferencedStateMachine(Token,UmpleClassifier)
  {
      if (uClassifier instanceof UmpleTrait){
        sm.setUmpleTrait((UmpleTrait)uClassifier);
      }
    }  } 
} 

mixset Trait { 
  class UmpleInternalParser { 
    before Lable_Trait_120:analyzeStateMachineToken(Token,UmpleClassifier,int)
  {
      else if (uClassifier instanceof UmpleTrait) {
        if (((UmpleTrait)uClassifier).isImmutable())
        {
          //TODO--- trait's code	
            setFailedPosition(token.getPosition(), 15, uClassifier.getName());
            return;
        }	
	    }
    }  } 
}

mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_119:analyzeFIXMLextendedContentContetnt(Token)
  {
				  addAssociation(uClass, rUClass,subToken); // based-on-single-associations
				}  } 
} 
mixset Association { 
  class UmpleInternalParser { 
    before Lable_addAssociation_118:analyzeFIXMLextendedContentContetnt(Token)
  {
				  addAssociation(uClass, rUClass,subToken); // based-on-single-associations
				}  } 
} 
mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_117:analyzeFIXMLDefinition(Token)
  {
				  assignAssociationInitialValues(); // based-on-single-associations
				}  } 
} 

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_116:processGTemplateParameterAssignment(Token,UmpleClassifier,String)
  {
          else if (subToken.is("StateMachineAliasName")){ 
              StateMachineTemplateSignature stTSignature = obtainStateMachineTemplateSignature(subToken);
              if (! aGeneralTPApplied.hasStateMachineTemplateSignature(stTSignature)){  
                aGeneralTPApplied.addStateMachineTemplateSignature(stTSignature);
              } else {
                getParseResult().addErrorMessage(new ErrorMessage(229,subToken.getPosition(),aGeneralTPApplied.getInheritanceName(),stTSignature.getSrcStateMachine()));
                return;
              } 
          } else if (subToken.is("iEStateMachine")){ 
              StateMachineModifier stTSignature = obtainStateMachineModifier(subToken);
              if (! aGeneralTPApplied.hasStateMachineModifier(stTSignature)){  
                aGeneralTPApplied.addStateMachineModifier(stTSignature);
              } else {
                getParseResult().addErrorMessage(new ErrorMessage(229,subToken.getPosition(),aGeneralTPApplied.getInheritanceName(),stTSignature.getSrcStateMachine()));
                return;
              } 
          } 
        }  } 
}

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_115:processGTemplateParameterAssignment(Token,UmpleClassifier,String)
  {
                StateMachineTemplateSignature stTSignature = obtainStateMachineTemplateSignatureForTransitions(subToken);
                if (! aGeneralTPApplied.hasStateMachineTemplateSignature(stTSignature)){  
                  aGeneralTPApplied.addStateMachineTemplateSignature(stTSignature);
                } else {
                  getParseResult().addErrorMessage(new ErrorMessage(229,subToken.getPosition(),aGeneralTPApplied.getInheritanceName(),stTSignature.getSrcStateMachine()));
                  return;
                }
            }  } 
}

mixset AspectInjection { 
  class UmpleInternalParser { 
    before Lable_AspectInjection_114:applyTraitProperties(UmpleClass,UmpleTrait)
  {
       // copy injection codes
       for (CodeInjection cj : inTrait.getCodeInjections()) {
               cj.setUmpleClassifier(inClass);
               inClass.addCodeInjection(cj);
       }
    }  } 
}

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_113:applyTraits
  {
          if (getParseResult().getWasSuccess()) copyStateMachinesFromTraiToClass(uClass);
          }  } 
}

mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_112:applyTraits
  {
            if (getParseResult().getWasSuccess()) copyAssociationsFromTraitToClass(uClass);
          }  } 
}

mixset Layout { 
  class UmpleInternalParser { 
    before Lable_Layout_111:analyzeDependentTokens(Token,UmpleTrait,int)
  {
      analyzeLayoutToken(t,inTrait,analysisStep);
    }  } 
}

mixset AspectInjection { 
  class UmpleInternalParser { 
    before Lable_AspectInjection_110:analyzeDependentTokens(Token,UmpleTrait,int)
  {
      else if (t.is("beforeCode") || t.is("afterCode"))
      {
      //TODO should applied for traits
        analyzeInjectionCode(t,inTrait);
      }
    }  } 
} 

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_108:analyzeExtraCode(Token,UmpleTrait)
  {
      if(extraCodeIsMalformedStateMachine(token)) setFailedPosition(token.getPosition(), 1006, "");
    }  } 
} 



mixset Association { 
  class UmpleInternalParser { 
    before Lable_Association_107:analyzeTraitToken(Token,UmpleTrait,int)
  {
      else if (token.is("inlineAssociation"))
      {
        analyzeinlineAssociation(token,aTrait);
      }
      else if (token.is("symmetricReflexiveAssociation"))
      {
        analyzeSymmetricReflexiveAssociation(token,aTrait);
      }
    }  } 
} 



mixset Mixset { 
  class UmpleInternalParser { 
    before Lable_Mixset_106:analyzeTraitToken(Token,UmpleTrait,int)
  {
      else if (token.is("mixsetDefinition"))
      {
        analyzeMixsetBodyToken(token);
    
      }
    }  } 
} 

mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_66:analyzeToken(Token,UmpleClass,int)
  {
      analyzeStateMachineToken(t,aClass,analysisStep);
    }  } 
} 

/*
//the below is similar to Lable_StateMachine_66. Check
mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_105:analyzeToken(Token,UmpleTrait,int)
  {
      analyzeStateMachineToken(t,aTrait,analysisStep);
    }  } 
} 
*/






mixset StateMachine { 
  class UmpleInternalParser { 
    before Lable_StateMachine_109:analyzeException(Token,UmpleTrait)
  {
    else if(sub.is("malformedStatemachine1")||sub.is("malformedStatemachine2"))
    {
      String extraCode = "";
      for(Token token:sub.getSubTokens())
      {
        if(token.is("stuff"))
        {
          if(!"".equals(token.getValue())&&!token.getValue().contains(" ")&&!Token.isValidIdentifier(token.getValue()))
          {
            setFailedPosition(token.getPosition(), 150, token.getValue("name"));
          }
          extraCode += token.getValue()+ " ";
        }
      }
      extraCode += "\n  {\n    "+sub.getValue("innerstuff")+"\n  }";
      aTrait.appendExtraCode("// line " + exception.getPosition().getLineNumber() + " " + aTrait.getRelativePath(exception.getPosition().getFilename(),"Java"));
      aTrait.appendExtraCode("  "+extraCode+"\n");
      setFailedPosition(sub.getPosition(), 1006, sub.getValue("name"));
    }

    }  
    
    } 
} 





 