<?xml version="1.0" encoding="UTF-8" ?>
<testsuite errors="0" failures="0" hostname="Abdulazizs-MacBook-Pro.local" name="cruise.umple.statemachine.implementation.StateMachineTest" skipped="0" tests="134" time="1.688" timestamp="2021-10-26T14:28:16">
  <properties>
    <property name="ant.library.dir" value="/usr/local/Cellar/ant/1.10.9/libexec/lib" />
    <property name="env.TERM" value="xterm-256color" />
    <property name="java.specification.version" value="15" />
    <property name="ant.project.name" value="UmpleCore" />
    <property name="ant.file.type.UmpleCore" value="file" />
    <property name="sun.jnu.encoding" value="UTF-8" />
    <property name="ant.file.type.LocalBuildProperties" value="file" />
    <property name="env.SDKMAN_CANDIDATES_API" value="https://api.sdkman.io/2" />
    <property name="sun.arch.data.model" value="64" />
    <property name="dist.umple.docs.jar.prev" value="umpledocs-1.31.1.5860.78bb27cc6.jar" />
    <property name="rake_cmd" value="rake" />
    <property name="showJunitOutput" value="false" />
    <property name="umple.deps.dir" value="/Users/abdulaziz/tmp/umple/dist/libs" />
    <property name="java.vendor.url" value="https://openjdk.java.net/" />
    <property name="dist.libs.dir" value="/Users/abdulaziz/tmp/umple/dist/libs" />
    <property name="sun.boot.library.path" value="/usr/local/Cellar/openjdk/15.0.1/libexec/openjdk.jdk/Contents/Home/lib" />
    <property name="sun.java.command" value="org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner testsfile=/Users/abdulaziz/tmp/umple/junittestcases9945622084601822128.properties skipNonTests=false filtertrace=true haltOnError=false haltOnFailure=false showoutput=false outputtoformatters=true logfailedtests=true threadid=0 logtestlistenerevents=false formatter=org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter,/Users/abdulaziz/tmp/umple/dist/qa/cruise.umple/IGNORETHIS.xml crashfile=/Users/abdulaziz/tmp/umple/junitvmwatcher11280979461299836288.properties propsfile=/Users/abdulaziz/tmp/umple/junit10838995335343066243.properties" />
    <property name="jdk.debug" value="release" />
    <property name="java.specification.vendor" value="Oracle Corporation" />
    <property name="test.output.path" value="/Users/abdulaziz/tmp/umple/dist/qa/cruise.umple" />
    <property name="env.JAVA_HOME" value="/usr/local/opt/openjdk" />
    <property name="java.version.date" value="2020-10-20" />
    <property name="java.home" value="/usr/local/Cellar/openjdk/15.0.1/libexec/openjdk.jdk/Contents/Home" />
    <property name="basedir" value="/Users/abdulaziz/tmp/umple" />
    <property name="file.separator" value="/" />
    <property name="java.vm.compressedOopsMode" value="Zero based" />
    <property name="line.separator" value="&#xa;" />
    <property name="ivy.jar.file" value="/Users/abdulaziz/.ant/lib/ivy-2.4.0.jar" />
    <property name="java.specification.name" value="Java Platform API Specification" />
    <property name="java.vm.specification.vendor" value="Oracle Corporation" />
    <property name="ant.file.Template" value="/Users/abdulaziz/tmp/umple/build/_template.xml" />
    <property name="dist.umple.stats.jar" value="umplestats-1.31.1.5860.78bb27cc6.jar" />
    <property name="ivyRetrieveLogLevel" value="quiet" />
    <property name="sun.management.compiler" value="HotSpot 64-Bit Tiered Compilers" />
    <property name="java.runtime.version" value="15.0.1+9" />
    <property name="env.TERM_PROGRAM_VERSION" value="440" />
    <property name="user.name" value="abdulaziz" />
    <property name="env.PATH" value="/Users/abdulaziz/.sdkman/candidates/gradle/current/bin:/Library/Frameworks/Python.framework/Versions/3.9/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/Apple/usr/bin:/Library/Frameworks/Mono.framework/Versions/Current/Commands" />
    <property name="env.LOGNAME" value="abdulaziz" />
    <property name="env.XPC_FLAGS" value="0x0" />
    <property name="env.__CF_USER_TEXT_ENCODING" value="0x1F5:0x0:0x0" />
    <property name="file.encoding" value="UTF-8" />
    <property name="env.__CFBundleIdentifier" value="com.apple.Terminal" />
    <property name="env.TERM_SESSION_ID" value="20D2790F-0FEC-4CCB-A10B-030C8F4ED298" />
    <property name="umple.stable.jar" value="/Users/abdulaziz/tmp/umple/dist/libs/umple-1.31.1.5860.78bb27cc6.jar" />
    <property name="haltonfailure" value="false" />
    <property name="connectionTimeout" value="30" />
    <property name="env.SHLVL" value="1" />
    <property name="dist.dir" value="/Users/abdulaziz/tmp/umple/dist" />
    <property name="dist.path" value="/Users/abdulaziz/tmp/umple/dist/cruise.umple" />
    <property name="java.io.tmpdir" value="/var/folders/fm/7tjk7l8154x840c6vvrs49p40000gn/T/" />
    <property name="umple.ivy.dep.file" value="/Users/abdulaziz/tmp/umple/build/ivy.xml" />
    <property name="dist.umple.run.jar.prev" value="umplerun-1.31.1.5860.78bb27cc6.jar" />
    <property name="dist.umple.jar" value="umple-1.31.1.5860.78bb27cc6.jar" />
    <property name="java.version" value="15.0.1" />
    <property name="env.SSH_AUTH_SOCK" value="/private/tmp/com.apple.launchd.qK4l0KXsgu/Listeners" />
    <property name="java.vm.specification.name" value="Java Virtual Machine Specification" />
    <property name="ant.home" value="/usr/local/Cellar/ant/1.10.9/libexec" />
    <property name="ant.file.type.UmpleDeps" value="file" />
    <property name="env.SDKMAN_DIR" value="/Users/abdulaziz/.sdkman" />
    <property name="ant.version" value="Apache Ant(TM) version 1.10.9 compiled on September 27 2020" />
    <property name="env.TMPDIR" value="/var/folders/fm/7tjk7l8154x840c6vvrs49p40000gn/T/" />
    <property name="env.SDKMAN_PLATFORM" value="darwinx64" />
    <property name="java.library.path" value="/Users/abdulaziz/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:." />
    <property name="java.vendor" value="N/A" />
    <property name="shouldPackageUmpleOnline" value="false" />
    <property name="dist.umple.validator.jar" value="umplevalidator-1.31.1.5860.78bb27cc6.jar" />
    <property name="sun.io.unicode.encoding" value="UnicodeBig" />
    <property name="jopt-simple.install.version" value="4.4" />
    <property name="socksNonProxyHosts" value="local|*.local|169.254/16|*.169.254/16" />
    <property name="env.SDKMAN_CANDIDATES_DIR" value="/Users/abdulaziz/.sdkman/candidates" />
    <property name="env.TERM_PROGRAM" value="Apple_Terminal" />
    <property name="vendors.path" value="/Users/abdulaziz/tmp/umple/dist/libs/vendors" />
    <property name="env.PWD" value="/Users/abdulaziz/tmp/umple/build" />
    <property name="ant.file.type" value="file" />
    <property name="last.version" value="1.31.1.5860.78bb27cc6" />
    <property name="env.LANG" value="en_CA.UTF-8" />
    <property name="ant.file.type.VersionLast" value="file" />
    <property name="java.class.path" value="/Users/abdulaziz/tmp/umple/cruise.umple/bin:/Users/abdulaziz/tmp/umple/dist/libs/core/ant-launcher.jar:/Users/abdulaziz/tmp/umple/dist/libs/core/ant.jar:/Users/abdulaziz/tmp/umple/dist/libs/core/jopt-simple.jar:/Users/abdulaziz/tmp/umple/dist/libs/test/hamcrest-core.jar:/Users/abdulaziz/tmp/umple/dist/libs/test/junit.jar:/Users/abdulaziz/.ant/lib/junit.jar:/usr/local/Cellar/ant/1.10.9/libexec/lib/ant-launcher.jar:/usr/local/Cellar/ant/1.10.9/libexec/lib/ant.jar:/usr/local/Cellar/ant/1.10.9/libexec/lib/ant-junit.jar:/usr/local/Cellar/ant/1.10.9/libexec/lib/ant-junit4.jar" />
    <property name="env.HOME" value="/Users/abdulaziz" />
    <property name="java.vm.vendor" value="Oracle Corporation" />
    <property name="env.GRADLE_HOME" value="/Users/abdulaziz/.sdkman/candidates/gradle/current" />
    <property name="xtext.project.path" value="cruise.umple.xtext" />
    <property name="ant.file.type.Template" value="file" />
    <property name="user.timezone" value="America/Toronto" />
    <property name="project.path" value="cruise.umple" />
    <property name="ant.file.UmpleDeps" value="/Users/abdulaziz/tmp/umple/build/build.deps.xml" />
    <property name="java.vm.specification.version" value="15" />
    <property name="os.name" value="Mac OS X" />
    <property name="env.DISPLAY" value="/private/tmp/com.apple.launchd.8VZUm1G4zQ/org.xquartz:0" />
    <property name="dist.umple.sync.jar" value="umplesync-1.31.1.5860.78bb27cc6.jar" />
    <property name="sun.java.launcher" value="SUN_STANDARD" />
    <property name="user.country" value="CA" />
    <property name="dist.umple.run.jar" value="umplerun-1.31.1.5860.78bb27cc6.jar" />
    <property name="http.nonProxyHosts" value="local|*.local|169.254/16|*.169.254/16" />
    <property name="sun.cpu.endian" value="little" />
    <property name="user.home" value="/Users/abdulaziz" />
    <property name="user.language" value="en" />
    <property name="ivy.install.version" value="2.4.0" />
    <property name="ant.java.version" value="15" />
    <property name="ant.file.type.Umple" value="file" />
    <property name="showJunitSummary" value="false" />
    <property name="bin.path" value="cruise.umple/bin" />
    <property name="umple.version" value="1.31.1.5860.78bb27cc6" />
    <property name="dist.umple.sync.jar.prev" value="umplesync-1.31.1.5860.78bb27cc6.jar" />
    <property name="ivyResolveLogLevel" value="download-only" />
    <property name="env.XPC_SERVICE_NAME" value="0" />
    <property name="user.home.ant" value="/Users/abdulaziz/.ant/lib" />
    <property name="ftp.nonProxyHosts" value="local|*.local|169.254/16|*.169.254/16" />
    <property name="is.osx" value="true" />
    <property name="dist.umple.stats.jar.prev" value="umplestats-1.31.1.5860.78bb27cc6.jar" />
    <property name="ant.file" value="/Users/abdulaziz/tmp/umple/build/build.umple.xml" />
    <property name="path.separator" value=":" />
    <property name="dist.umple.umplificator.jar.prev" value="umpleumplificator-1.31.1.5860.78bb27cc6.jar" />
    <property name="os.version" value="11.6" />
    <property name="ant.file.VersionLast" value="/Users/abdulaziz/tmp/umple/build/_versionLast.xml" />
    <property name="ant.file.Umple" value="/Users/abdulaziz/tmp/umple/build/build.xml" />
    <property name="java.runtime.name" value="OpenJDK Runtime Environment" />
    <property name="dist.umple.docs.jar" value="umpledocs-1.31.1.5860.78bb27cc6.jar" />
    <property name="ant.project.invoked-targets" value="template.test" />
    <property name="dist.umple.umplificator.jar" value="umpleumplificator-1.31.1.5860.78bb27cc6.jar" />
    <property name="java.vm.name" value="OpenJDK 64-Bit Server VM" />
    <property name="ant.file.LocalBuildProperties" value="/Users/abdulaziz/tmp/umple/build/_local.xml" />
    <property name="env.SHELL" value="/bin/zsh" />
    <property name="ant.core.lib" value="/usr/local/Cellar/ant/1.10.9/libexec/lib/ant.jar" />
    <property name="java.vendor.url.bug" value="https://bugreport.java.com/bugreport/" />
    <property name="junit" value="*Test" />
    <property name="user.dir" value="/Users/abdulaziz/tmp/umple/build" />
    <property name="os.arch" value="x86_64" />
    <property name="env.SDKMAN_VERSION" value="5.11.5+713" />
    <property name="shouldDeploy" value="false" />
    <property name="dist.umple.validator.jar.prev" value="umplevalidator-1.31.1.5860.78bb27cc6.jar" />
    <property name="java.vm.info" value="mixed mode, sharing" />
    <property name="java.vm.version" value="15.0.1+9" />
    <property name="ant.file.UmpleCore" value="/Users/abdulaziz/tmp/umple/build/build.umple.xml" />
    <property name="online" value="true" />
    <property name="myenv" value="local" />
    <property name="umple.deps.manual.dir" value="/Users/abdulaziz/tmp/umple/dist/libs/manual" />
    <property name="env.USER" value="abdulaziz" />
    <property name="java.class.version" value="59.0" />
    <property name="first.build" value="false" />
    <property name="dist.umple.jar.prev" value="umple-1.31.1.5860.78bb27cc6.jar" />
    <property name="env.JAVA_MAIN_CLASS_3280" value="org.apache.tools.ant.launch.Launcher" />
    <property name="ant.project.default-target" value="build" />
  </properties>
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine_withParameters_1" time="0.095" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="refactorFinalState_hasAllInvalidElements" time="0.017" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testRegionFinalStates_1" time="0.027" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testRegionFinalStates_2" time="0.011" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testRegionFinalStates_3" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testRegionFinalStates_4" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testRegionFinalStates_5" time="0.014" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testRegionFinalStates_6" time="0.017" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="checkExternalTransitions_noNestedStateMachines" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="pooledStateMachine_timedEvents" time="0.033" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateMachineWithNegativeNumberGuard2" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="parallelSm_diffNamesDiffStates_2" time="0.068" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testFinalKeyword" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="transitionAction" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedWithConcurrensStatesCourseAttempt" time="0.017" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testFinalKeyword_2" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="finalState" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateNameSpacingForEventTransitionNewState" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateMachine_UnspecifiedReception" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="entryExitActionDuplicates" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testTwoParameterGuard_1" time="0.02" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedWithNestingStatesATM" time="0.021" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="eventWithArguments" time="0.011" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="entryAction" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="refactorFinalState_invalidElementsInNestedFinalState" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="nestedStateMachineExtendedByClass" time="0.04" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multiplePooledStateMachine_EventlessStateMachine" time="0.055" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedSMwithConcurrentStatesTest" time="0.024" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="refactorFinalState_onlyEntryAction" time="0.031" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="parallelSm_diffNamesDiffStatesEntryExitActions" time="0.021" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="duplicateTimeoutVariableAndMethod" time="0.012" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multipleGuardsSameEventWithDefaultNoGuard" time="0.014" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="refactorFinalState_empty" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multipleQSM_EventlessStateMachine" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateNameSpacingForTwoStates" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedWithConcurrentStateMachines" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testPooledwithNestedStates" time="0.014" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multiplePooledStateMachines_sameEvents" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="concurrentStates" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="EmptyAndNonEmptyStates" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="pooledStateMachine_timedEvents_and_autoTansitions" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedSM_UnspecifiedReception" time="0.013" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="doActivityNestedStateMachine" time="0.016" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateMachine_unSpecifiedReception_QSM" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="CapitalStateMachineAttribute" time="0.003" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateMachineWithStringComparisonGuard" time="0.009" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="doActivity_Multiple" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine_implements" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multiplePooledStateMachine_nestedStates" time="0.009" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedWithNestingStateMachines" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="checkExternalTransitions_withExitActions_1" time="0.011" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="checkExternalTransitions_withExitActions_2" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="guardNegSymbolSpacing" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="parallelSm_sameNameDiffStates_2" time="0.012" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateNameSpacingForEventTransitionSameState" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="checkExternalTransitions_concurrentStateMachines_2" time="0.012" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="entryExitActionNoTransitions" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="exitAction" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="noDefaultEntryMethodGenerated" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="nestedStateMachineExtendedByMultipleClasses" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="eventWithArguments_1" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="eventWithArguments_2" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateNameSpacingForNoStates" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine_2" time="0.011" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="nestedStates_Two_TimedTransition" time="0.013" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine_timedTransition_1" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine_timedTransition_2" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="exitActionSelfTransition" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="guardNameBothAttributeAndMethod2" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="guardNameBothAttributeAndMethod3" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="doActivityMultipleInSameState" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="pooledStateMachine_UnspecifiedReception" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="parallelSm_sameNameDiffStates" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="EventTransitionNewState" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateMachineWithNegativeNumberGuard" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="noDefaultEntryMethodGenerated_2" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="doActivityNoTransitions" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine_withParameters" time="0.009" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multipleQSMe_nestedStates" time="0.009" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine_timedEvents_and_autoTansitions" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="pooledStateMachine_timedTransition_1" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="pooledStateMachine_timedTransition_2" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="doActivitiesWithAutoTransition" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine_timedEvents" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="twoEventsWithArguments" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multipleQSM" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="pooledStateMachine_withParameters" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="nestedStates_exitInnerBeforeOutter" time="0.019" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="NoStates" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="eventlessStateMachine_before_PooledStateMachine" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="nestedStates_timedTransition" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="eventlessStateMachine_before_QueuedStateMachine" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="sameEvent_twoStates_differentStatemachines" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="nestedStates_UnspecifiedReception" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="nestedStates" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="nestedState_StateMachine_timedEvents" time="0.013" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="before_after_setMethod" time="0.013" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multipleGuardsSameEvent" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="externalStateMachine" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="guardSpacing" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="pooledStateMachine" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="parallelSm_sameNameDiffStatesEntryExitActions" time="0.013" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateNameSpacingForOneState" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="stateMachineSpacing" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="pooledStateMachineWithConcurrentStates_autoTransition" time="0.013" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="parallelSm_diffNamesDiffStates" time="0.029" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="entryExitTransitionAction" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="timedEvent" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testMultipleQSMs" time="0.011" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="activeObject" time="0.009" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="guardsOnEntryAndExit" time="0.007" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="equivalentGuards" time="0.169" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="doActivity" time="0.012" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multipleQSM_sameEvents" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="multiplePooledStateMachine" time="0.014" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="guardNameBothAttributeAndMethod" time="0.009" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="checkExternalTransitions_concurrentStateMachines" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedStateMachine_autoTransition" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="doActivityMultiMixin" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="entryExitTransitionActionWithGuard" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testPooledwithNestedStates_2" time="0.028" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testPooledwithNestedStates_3" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="testPooledwithNestedStates_4" time="0.011" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="autoEventTransition" time="0.004" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="nestedStatesOfQSMwithSameEventNames" time="0.008" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="checkExternalTransitions_noExitActions_1" time="0.011" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="TwoState" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="oneGuard" time="0.006" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="queuedSMwithConcurrentStatesTest_2" time="0.01" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="OneState" time="0.005" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="pooledStateMachine_autoTransition" time="0.009" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="EventTransitionSameState" time="0.012" />
  <testcase classname="cruise.umple.statemachine.implementation.StateMachineTest" name="avoidJunitError" time="0.002" />
  <system-out><![CDATA[/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedStateMachine_withParameters_1.ump"
public class LightFixture implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture Attributes
  private int brightness;

  //LightFixture State Machines
  public enum Bulb { Off, Dimmed, On }
  private Bulb bulb;
  
  //enumeration type of messages accepted by LightFixture
  protected enum MessageType { turnDimmer_M, flipSwitch_M, entry_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    brightness = 0;
    setBulb(Bulb.Off);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of LightFixture
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setBrightness(int aBrightness)
  {
    boolean wasSet = false;
    brightness = aBrightness;
    wasSet = true;
    return wasSet;
  }

  public int getBrightness()
  {
    return brightness;
  }

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean _turnDimmer(Integer lightval,Double grade)
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        // line 8 "../queuedStateMachine_withParameters_1.ump"
        setBrightness(lightval)
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case Dimmed:
        // line 14 "../queuedStateMachine_withParameters_1.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case On:
        // line 18 "../queuedStateMachine_withParameters_1.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _flipSwitch()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case Dimmed:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case On:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _entry()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Dimmed:
        if (dimmer>99)
        {
          setBulb(Bulb.On);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void turnDimmer (Integer lightval,Double grade)
  {
    Vector<Object> v = new Vector<Object>(2);
    v.add(0, lightval);
    v.add(1, grade);
    queue.put(new Message(MessageType.turnDimmer_M, v));
  }

  public void flipSwitch ()
  {
    queue.put(new Message(MessageType.flipSwitch_M, null));
  }

  public void entry ()
  {
    queue.put(new Message(MessageType.entry_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case turnDimmer_M:
          status = _turnDimmer((Integer) m.param.elementAt(0), (Double) m.param.elementAt(1));
          break;
        case flipSwitch_M:
          status = _flipSwitch();
          break;
        case entry_M:
          status = _entry();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }

  public String toString()
  {
    return super.toString() + "["+
            "brightness" + ":" + getBrightness()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../refactorFinalState_hasAllInvalidElements.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Status { on, off, FINAL }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setStatus(Status.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean turnoff()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        setStatus(Status.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean powerOff()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        setStatus(Status.FINAL);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean turnOn()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case off:
        setStatus(Status.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case FINAL:
        // line 13 "../refactorFinalState_hasAllInvalidElements.ump"
        entry();
        delete();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "testRegionFinalStates_1.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s4 }
  public enum SmS1 { Null, s2, s3 }
  public enum SmS4 { Null, s5 }
  private Sm sm;
  private SmS1 smS1;
  private SmS4 smS4;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSmS4(SmS4.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    if (smS4 != SmS4.Null) { answer += "." + smS4.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public SmS4 getSmS4()
  {
    return smS4;
  }

  public boolean goToS5()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s4:
        exitSmS4();
        setSmS4(SmS4.s5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToS3()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s2:
        exitSmS1();
        setSmS1(SmS1.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToS4()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s2:
        exitSm();
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
      case s4:
        exitSmS4();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s2); }
        break;
      case s4:
        if (smS4 == SmS4.Null) { setSmS4(SmS4.s5); }
        break;
    }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s2:
        setSmS1(SmS1.Null);
        break;
      case s3:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1)
    {
      case s3:
        delete();
        break;
    }
  }

  private void exitSmS4()
  {
    switch(smS4)
    {
      case s5:
        setSmS4(SmS4.Null);
        break;
    }
  }

  private void setSmS4(SmS4 aSmS4)
  {
    smS4 = aSmS4;
    if (sm != Sm.s4 && aSmS4 != SmS4.Null) { setSm(Sm.s4); }

    // entry actions and do activities
    switch(smS4)
    {
      case s5:
        delete();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "testRegionFinalStates_2.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1 }
  public enum SmS1S2 { Null, s2 }
  public enum SmS1S3 { Null, s3 }
  public enum SmS1S3S3 { Null, s4, s5 }
  private Sm sm;
  private SmS1S2 smS1S2;
  private SmS1S3 smS1S3;
  private SmS1S3S3 smS1S3S3;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1S2(SmS1S2.Null);
    setSmS1S3(SmS1S3.Null);
    setSmS1S3S3(SmS1S3S3.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1S2 != SmS1S2.Null) { answer += "." + smS1S2.toString(); }
    if (smS1S3 != SmS1S3.Null) { answer += "." + smS1S3.toString(); }
    if (smS1S3S3 != SmS1S3S3.Null) { answer += "." + smS1S3S3.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1S2 getSmS1S2()
  {
    return smS1S2;
  }

  public SmS1S3 getSmS1S3()
  {
    return smS1S3;
  }

  public SmS1S3S3 getSmS1S3S3()
  {
    return smS1S3S3;
  }

  public boolean goToS3()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2 aSmS1S2 = smS1S2;
    switch (aSmS1S2)
    {
      case s2:
        exitSmS1S2();
        setSmS1S3(SmS1S3.s3);
        setSmS1S2(SmS1S2.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToS5()
  {
    boolean wasEventProcessed = false;
    
    SmS1S3S3 aSmS1S3S3 = smS1S3S3;
    switch (aSmS1S3S3)
    {
      case s4:
        exitSmS1S3S3();
        setSmS1S3S3(SmS1S3S3.s5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1S2();
        exitSmS1S3();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1S2 == SmS1S2.Null) { setSmS1S2(SmS1S2.s2); }
        if (smS1S3 == SmS1S3.Null) { setSmS1S3(SmS1S3.s3); }
        break;
    }
  }

  private void exitSmS1S2()
  {
    switch(smS1S2)
    {
      case s2:
        setSmS1S2(SmS1S2.Null);
        break;
    }
  }

  private void setSmS1S2(SmS1S2 aSmS1S2)
  {
    smS1S2 = aSmS1S2;
    if (sm != Sm.s1 && aSmS1S2 != SmS1S2.Null) { setSm(Sm.s1); }
  }

  private void exitSmS1S3()
  {
    switch(smS1S3)
    {
      case s3:
        exitSmS1S3S3();
        setSmS1S3(SmS1S3.Null);
        break;
    }
  }

  private void setSmS1S3(SmS1S3 aSmS1S3)
  {
    smS1S3 = aSmS1S3;
    if (sm != Sm.s1 && aSmS1S3 != SmS1S3.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1S3)
    {
      case s3:
        if (smS1S3S3 == SmS1S3S3.Null) { setSmS1S3S3(SmS1S3S3.s4); }
        break;
    }
  }

  private void exitSmS1S3S3()
  {
    switch(smS1S3S3)
    {
      case s4:
        setSmS1S3S3(SmS1S3S3.Null);
        break;
      case s5:
        setSmS1S3S3(SmS1S3S3.Null);
        break;
    }
  }

  private void setSmS1S3S3(SmS1S3S3 aSmS1S3S3)
  {
    smS1S3S3 = aSmS1S3S3;
    if (smS1S3 != SmS1S3.s3 && aSmS1S3S3 != SmS1S3S3.Null) { setSmS1S3(SmS1S3.s3); }

    // entry actions and do activities
    switch(smS1S3S3)
    {
      case s5:
        delete();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "testRegionFinalStates_3.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1 }
  public enum SmS1S2 { Null, s2 }
  public enum SmS1S2S2 { Null, s3, s4 }
  public enum SmS1S5 { Null, s5 }
  public enum SmS1S5S5 { Null, s6, s7 }
  public enum SmS1S8 { Null, s8 }
  public enum SmS1S8S8 { Null, s9, s10 }
  private Sm sm;
  private SmS1S2 smS1S2;
  private SmS1S2S2 smS1S2S2;
  private SmS1S5 smS1S5;
  private SmS1S5S5 smS1S5S5;
  private SmS1S8 smS1S8;
  private SmS1S8S8 smS1S8S8;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1S2(SmS1S2.Null);
    setSmS1S2S2(SmS1S2S2.Null);
    setSmS1S5(SmS1S5.Null);
    setSmS1S5S5(SmS1S5S5.Null);
    setSmS1S8(SmS1S8.Null);
    setSmS1S8S8(SmS1S8S8.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1S2 != SmS1S2.Null) { answer += "." + smS1S2.toString(); }
    if (smS1S2S2 != SmS1S2S2.Null) { answer += "." + smS1S2S2.toString(); }
    if (smS1S5 != SmS1S5.Null) { answer += "." + smS1S5.toString(); }
    if (smS1S5S5 != SmS1S5S5.Null) { answer += "." + smS1S5S5.toString(); }
    if (smS1S8 != SmS1S8.Null) { answer += "." + smS1S8.toString(); }
    if (smS1S8S8 != SmS1S8S8.Null) { answer += "." + smS1S8S8.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1S2 getSmS1S2()
  {
    return smS1S2;
  }

  public SmS1S2S2 getSmS1S2S2()
  {
    return smS1S2S2;
  }

  public SmS1S5 getSmS1S5()
  {
    return smS1S5;
  }

  public SmS1S5S5 getSmS1S5S5()
  {
    return smS1S5S5;
  }

  public SmS1S8 getSmS1S8()
  {
    return smS1S8;
  }

  public SmS1S8S8 getSmS1S8S8()
  {
    return smS1S8S8;
  }

  public boolean goToS4()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2S2 aSmS1S2S2 = smS1S2S2;
    switch (aSmS1S2S2)
    {
      case s3:
        exitSmS1S2S2();
        setSmS1S2S2(SmS1S2S2.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToS7()
  {
    boolean wasEventProcessed = false;
    
    SmS1S5S5 aSmS1S5S5 = smS1S5S5;
    switch (aSmS1S5S5)
    {
      case s6:
        exitSmS1S5S5();
        setSmS1S5S5(SmS1S5S5.s7);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToS10()
  {
    boolean wasEventProcessed = false;
    
    SmS1S8S8 aSmS1S8S8 = smS1S8S8;
    switch (aSmS1S8S8)
    {
      case s9:
        exitSmS1S8S8();
        setSmS1S8S8(SmS1S8S8.s10);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1S2();
        exitSmS1S5();
        exitSmS1S8();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1S2 == SmS1S2.Null) { setSmS1S2(SmS1S2.s2); }
        if (smS1S5 == SmS1S5.Null) { setSmS1S5(SmS1S5.s5); }
        if (smS1S8 == SmS1S8.Null) { setSmS1S8(SmS1S8.s8); }
        break;
    }
  }

  private void exitSmS1S2()
  {
    switch(smS1S2)
    {
      case s2:
        exitSmS1S2S2();
        setSmS1S2(SmS1S2.Null);
        break;
    }
  }

  private void setSmS1S2(SmS1S2 aSmS1S2)
  {
    smS1S2 = aSmS1S2;
    if (sm != Sm.s1 && aSmS1S2 != SmS1S2.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1S2)
    {
      case s2:
        if (smS1S2S2 == SmS1S2S2.Null) { setSmS1S2S2(SmS1S2S2.s3); }
        break;
    }
  }

  private void exitSmS1S2S2()
  {
    switch(smS1S2S2)
    {
      case s3:
        setSmS1S2S2(SmS1S2S2.Null);
        break;
      case s4:
        setSmS1S2S2(SmS1S2S2.Null);
        break;
    }
  }

  private void setSmS1S2S2(SmS1S2S2 aSmS1S2S2)
  {
    smS1S2S2 = aSmS1S2S2;
    if (smS1S2 != SmS1S2.s2 && aSmS1S2S2 != SmS1S2S2.Null) { setSmS1S2(SmS1S2.s2); }

    // entry actions and do activities
    switch(smS1S2S2)
    {
      case s4:
        if (smS1S5S5 == SmS1S5S5.s7 && smS1S8S8 == SmS1S8S8.s10) { delete(); }
        break;
    }
  }

  private void exitSmS1S5()
  {
    switch(smS1S5)
    {
      case s5:
        exitSmS1S5S5();
        setSmS1S5(SmS1S5.Null);
        break;
    }
  }

  private void setSmS1S5(SmS1S5 aSmS1S5)
  {
    smS1S5 = aSmS1S5;
    if (sm != Sm.s1 && aSmS1S5 != SmS1S5.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1S5)
    {
      case s5:
        if (smS1S5S5 == SmS1S5S5.Null) { setSmS1S5S5(SmS1S5S5.s6); }
        break;
    }
  }

  private void exitSmS1S5S5()
  {
    switch(smS1S5S5)
    {
      case s6:
        setSmS1S5S5(SmS1S5S5.Null);
        break;
      case s7:
        setSmS1S5S5(SmS1S5S5.Null);
        break;
    }
  }

  private void setSmS1S5S5(SmS1S5S5 aSmS1S5S5)
  {
    smS1S5S5 = aSmS1S5S5;
    if (smS1S5 != SmS1S5.s5 && aSmS1S5S5 != SmS1S5S5.Null) { setSmS1S5(SmS1S5.s5); }

    // entry actions and do activities
    switch(smS1S5S5)
    {
      case s7:
        if (smS1S2S2 == SmS1S2S2.s4 && smS1S8S8 == SmS1S8S8.s10) { delete(); }
        break;
    }
  }

  private void exitSmS1S8()
  {
    switch(smS1S8)
    {
      case s8:
        exitSmS1S8S8();
        setSmS1S8(SmS1S8.Null);
        break;
    }
  }

  private void setSmS1S8(SmS1S8 aSmS1S8)
  {
    smS1S8 = aSmS1S8;
    if (sm != Sm.s1 && aSmS1S8 != SmS1S8.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1S8)
    {
      case s8:
        if (smS1S8S8 == SmS1S8S8.Null) { setSmS1S8S8(SmS1S8S8.s9); }
        break;
    }
  }

  private void exitSmS1S8S8()
  {
    switch(smS1S8S8)
    {
      case s9:
        setSmS1S8S8(SmS1S8S8.Null);
        break;
      case s10:
        setSmS1S8S8(SmS1S8S8.Null);
        break;
    }
  }

  private void setSmS1S8S8(SmS1S8S8 aSmS1S8S8)
  {
    smS1S8S8 = aSmS1S8S8;
    if (smS1S8 != SmS1S8.s8 && aSmS1S8S8 != SmS1S8S8.Null) { setSmS1S8(SmS1S8.s8); }

    // entry actions and do activities
    switch(smS1S8S8)
    {
      case s10:
        if (smS1S2S2 == SmS1S2S2.s4 && smS1S5S5 == SmS1S5S5.s7) { delete(); }
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "testRegionFinalStates_4.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, Final, s2 }
  public enum SmS1O1 { Null, o1 }
  public enum SmS1O1O1 { Null, o1Start, o1Final }
  public enum SmS1O2 { Null, o2 }
  public enum SmS1O2O2 { Null, o2Start, o2Final }
  public enum SmS2 { Null, s2Start, s2Final }
  private Sm sm;
  private SmS1O1 smS1O1;
  private SmS1O1O1 smS1O1O1;
  private SmS1O2 smS1O2;
  private SmS1O2O2 smS1O2O2;
  private SmS2 smS2;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1O1(SmS1O1.Null);
    setSmS1O1O1(SmS1O1O1.Null);
    setSmS1O2(SmS1O2.Null);
    setSmS1O2O2(SmS1O2O2.Null);
    setSmS2(SmS2.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1O1 != SmS1O1.Null) { answer += "." + smS1O1.toString(); }
    if (smS1O1O1 != SmS1O1O1.Null) { answer += "." + smS1O1O1.toString(); }
    if (smS1O2 != SmS1O2.Null) { answer += "." + smS1O2.toString(); }
    if (smS1O2O2 != SmS1O2O2.Null) { answer += "." + smS1O2O2.toString(); }
    if (smS2 != SmS2.Null) { answer += "." + smS2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1O1 getSmS1O1()
  {
    return smS1O1;
  }

  public SmS1O1O1 getSmS1O1O1()
  {
    return smS1O1O1;
  }

  public SmS1O2 getSmS1O2()
  {
    return smS1O2;
  }

  public SmS1O2O2 getSmS1O2O2()
  {
    return smS1O2O2;
  }

  public SmS2 getSmS2()
  {
    return smS2;
  }

  public boolean goToS2()
  {
    boolean wasEventProcessed = false;
    
    SmS1O1 aSmS1O1 = smS1O1;
    switch (aSmS1O1)
    {
      case o1:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goBigFinal()
  {
    boolean wasEventProcessed = false;
    
    SmS1O1O1 aSmS1O1O1 = smS1O1O1;
    switch (aSmS1O1O1)
    {
      case o1Start:
        exitSm();
        setSm(Sm.Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean completeO1()
  {
    boolean wasEventProcessed = false;
    
    SmS1O1O1 aSmS1O1O1 = smS1O1O1;
    switch (aSmS1O1O1)
    {
      case o1Start:
        exitSmS1O1O1();
        setSmS1O1O1(SmS1O1O1.o1Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean completeO2()
  {
    boolean wasEventProcessed = false;
    
    SmS1O2O2 aSmS1O2O2 = smS1O2O2;
    switch (aSmS1O2O2)
    {
      case o2Start:
        exitSmS1O2O2();
        setSmS1O2O2(SmS1O2O2.o2Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean completeS2()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2Start:
        exitSmS2();
        setSmS2(SmS2.s2Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1O1();
        exitSmS1O2();
        break;
      case s2:
        exitSmS2();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1O1 == SmS1O1.Null) { setSmS1O1(SmS1O1.o1); }
        if (smS1O2 == SmS1O2.Null) { setSmS1O2(SmS1O2.o2); }
        break;
      case Final:
        delete();
        break;
      case s2:
        if (smS2 == SmS2.Null) { setSmS2(SmS2.s2Start); }
        break;
    }
  }

  private void exitSmS1O1()
  {
    switch(smS1O1)
    {
      case o1:
        exitSmS1O1O1();
        setSmS1O1(SmS1O1.Null);
        break;
    }
  }

  private void setSmS1O1(SmS1O1 aSmS1O1)
  {
    smS1O1 = aSmS1O1;
    if (sm != Sm.s1 && aSmS1O1 != SmS1O1.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1O1)
    {
      case o1:
        if (smS1O1O1 == SmS1O1O1.Null) { setSmS1O1O1(SmS1O1O1.o1Start); }
        break;
    }
  }

  private void exitSmS1O1O1()
  {
    switch(smS1O1O1)
    {
      case o1Start:
        setSmS1O1O1(SmS1O1O1.Null);
        break;
      case o1Final:
        setSmS1O1O1(SmS1O1O1.Null);
        break;
    }
  }

  private void setSmS1O1O1(SmS1O1O1 aSmS1O1O1)
  {
    smS1O1O1 = aSmS1O1O1;
    if (smS1O1 != SmS1O1.o1 && aSmS1O1O1 != SmS1O1O1.Null) { setSmS1O1(SmS1O1.o1); }

    // entry actions and do activities
    switch(smS1O1O1)
    {
      case o1Final:
        if (smS1O2O2 == SmS1O2O2.o2Final) { delete(); }
        break;
    }
  }

  private void exitSmS1O2()
  {
    switch(smS1O2)
    {
      case o2:
        exitSmS1O2O2();
        setSmS1O2(SmS1O2.Null);
        break;
    }
  }

  private void setSmS1O2(SmS1O2 aSmS1O2)
  {
    smS1O2 = aSmS1O2;
    if (sm != Sm.s1 && aSmS1O2 != SmS1O2.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1O2)
    {
      case o2:
        if (smS1O2O2 == SmS1O2O2.Null) { setSmS1O2O2(SmS1O2O2.o2Start); }
        break;
    }
  }

  private void exitSmS1O2O2()
  {
    switch(smS1O2O2)
    {
      case o2Start:
        setSmS1O2O2(SmS1O2O2.Null);
        break;
      case o2Final:
        setSmS1O2O2(SmS1O2O2.Null);
        break;
    }
  }

  private void setSmS1O2O2(SmS1O2O2 aSmS1O2O2)
  {
    smS1O2O2 = aSmS1O2O2;
    if (smS1O2 != SmS1O2.o2 && aSmS1O2O2 != SmS1O2O2.Null) { setSmS1O2(SmS1O2.o2); }

    // entry actions and do activities
    switch(smS1O2O2)
    {
      case o2Final:
        if (smS1O1O1 == SmS1O1O1.o1Final) { delete(); }
        break;
    }
  }

  private void exitSmS2()
  {
    switch(smS2)
    {
      case s2Start:
        setSmS2(SmS2.Null);
        break;
      case s2Final:
        setSmS2(SmS2.Null);
        break;
    }
  }

  private void setSmS2(SmS2 aSmS2)
  {
    smS2 = aSmS2;
    if (sm != Sm.s2 && aSmS2 != SmS2.Null) { setSm(Sm.s2); }

    // entry actions and do activities
    switch(smS2)
    {
      case s2Final:
        delete();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "testRegionFinalStates_5.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { o1 }
  public enum SmO1S1 { Null, s1 }
  public enum SmO1S1S2 { Null, s2 }
  public enum SmO1S1S2S2 { Null, s3, s4 }
  public enum SmO1S1S5 { Null, s5 }
  public enum SmO1S1S5S5 { Null, s6 }
  public enum SmO1S7 { Null, s7 }
  public enum SmO1S7S7 { Null, s8, s9 }
  private Sm sm;
  private SmO1S1 smO1S1;
  private SmO1S1S2 smO1S1S2;
  private SmO1S1S2S2 smO1S1S2S2;
  private SmO1S1S5 smO1S1S5;
  private SmO1S1S5S5 smO1S1S5S5;
  private SmO1S7 smO1S7;
  private SmO1S7S7 smO1S7S7;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmO1S1(SmO1S1.Null);
    setSmO1S1S2(SmO1S1S2.Null);
    setSmO1S1S2S2(SmO1S1S2S2.Null);
    setSmO1S1S5(SmO1S1S5.Null);
    setSmO1S1S5S5(SmO1S1S5S5.Null);
    setSmO1S7(SmO1S7.Null);
    setSmO1S7S7(SmO1S7S7.Null);
    setSm(Sm.o1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smO1S1 != SmO1S1.Null) { answer += "." + smO1S1.toString(); }
    if (smO1S1S2 != SmO1S1S2.Null) { answer += "." + smO1S1S2.toString(); }
    if (smO1S1S2S2 != SmO1S1S2S2.Null) { answer += "." + smO1S1S2S2.toString(); }
    if (smO1S1S5 != SmO1S1S5.Null) { answer += "." + smO1S1S5.toString(); }
    if (smO1S1S5S5 != SmO1S1S5S5.Null) { answer += "." + smO1S1S5S5.toString(); }
    if (smO1S7 != SmO1S7.Null) { answer += "." + smO1S7.toString(); }
    if (smO1S7S7 != SmO1S7S7.Null) { answer += "." + smO1S7S7.toString(); }
    if (smO1S1S2S2 != SmO1S1S2S2.Null) { answer += "." + smO1S1S2S2.toString(); }
    if (smO1S1S5S5 != SmO1S1S5S5.Null) { answer += "." + smO1S1S5S5.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmO1S1 getSmO1S1()
  {
    return smO1S1;
  }

  public SmO1S1S2 getSmO1S1S2()
  {
    return smO1S1S2;
  }

  public SmO1S1S2S2 getSmO1S1S2S2()
  {
    return smO1S1S2S2;
  }

  public SmO1S1S5 getSmO1S1S5()
  {
    return smO1S1S5;
  }

  public SmO1S1S5S5 getSmO1S1S5S5()
  {
    return smO1S1S5S5;
  }

  public SmO1S7 getSmO1S7()
  {
    return smO1S7;
  }

  public SmO1S7S7 getSmO1S7S7()
  {
    return smO1S7S7;
  }

  public boolean goToS4Final()
  {
    boolean wasEventProcessed = false;
    
    SmO1S1S2S2 aSmO1S1S2S2 = smO1S1S2S2;
    switch (aSmO1S1S2S2)
    {
      case s3:
        exitSmO1S1S2S2();
        setSmO1S1S2S2(SmO1S1S2S2.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToS9Final()
  {
    boolean wasEventProcessed = false;
    
    SmO1S7S7 aSmO1S7S7 = smO1S7S7;
    switch (aSmO1S7S7)
    {
      case s8:
        exitSmO1S7S7();
        setSmO1S7S7(SmO1S7S7.s9);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case o1:
        exitSmO1S1();
        exitSmO1S7();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case o1:
        if (smO1S1 == SmO1S1.Null) { setSmO1S1(SmO1S1.s1); }
        if (smO1S7 == SmO1S7.Null) { setSmO1S7(SmO1S7.s7); }
        break;
    }
  }

  private void exitSmO1S1()
  {
    switch(smO1S1)
    {
      case s1:
        exitSmO1S1S2();
        exitSmO1S1S5();
        setSmO1S1(SmO1S1.Null);
        break;
    }
  }

  private void setSmO1S1(SmO1S1 aSmO1S1)
  {
    smO1S1 = aSmO1S1;
    if (sm != Sm.o1 && aSmO1S1 != SmO1S1.Null) { setSm(Sm.o1); }

    // entry actions and do activities
    switch(smO1S1)
    {
      case s1:
        if (smO1S1S2 == SmO1S1S2.Null) { setSmO1S1S2(SmO1S1S2.s2); }
        if (smO1S1S5 == SmO1S1S5.Null) { setSmO1S1S5(SmO1S1S5.s5); }
        break;
    }
  }

  private void exitSmO1S1S2()
  {
    switch(smO1S1S2)
    {
      case s2:
        exitSmO1S1S2S2();
        setSmO1S1S2(SmO1S1S2.Null);
        break;
    }
  }

  private void setSmO1S1S2(SmO1S1S2 aSmO1S1S2)
  {
    smO1S1S2 = aSmO1S1S2;
    if (smO1S1 != SmO1S1.s1 && aSmO1S1S2 != SmO1S1S2.Null) { setSmO1S1(SmO1S1.s1); }

    // entry actions and do activities
    switch(smO1S1S2)
    {
      case s2:
        if (smO1S1S2S2 == SmO1S1S2S2.Null) { setSmO1S1S2S2(SmO1S1S2S2.s3); }
        break;
    }
  }

  private void exitSmO1S1S2S2()
  {
    switch(smO1S1S2S2)
    {
      case s3:
        setSmO1S1S2S2(SmO1S1S2S2.Null);
        break;
      case s4:
        setSmO1S1S2S2(SmO1S1S2S2.Null);
        break;
    }
  }

  private void setSmO1S1S2S2(SmO1S1S2S2 aSmO1S1S2S2)
  {
    smO1S1S2S2 = aSmO1S1S2S2;
    if (smO1S1S2 != SmO1S1S2.s2 && aSmO1S1S2S2 != SmO1S1S2S2.Null) { setSmO1S1S2(SmO1S1S2.s2); }

    // entry actions and do activities
    switch(smO1S1S2S2)
    {
      case s4:
        if (smO1S1S5S5 == SmO1S1S5S5.s6 && smO1S7S7 == SmO1S7S7.s9) { delete(); }
        break;
    }
  }

  private void exitSmO1S1S5()
  {
    switch(smO1S1S5)
    {
      case s5:
        exitSmO1S1S5S5();
        setSmO1S1S5(SmO1S1S5.Null);
        break;
    }
  }

  private void setSmO1S1S5(SmO1S1S5 aSmO1S1S5)
  {
    smO1S1S5 = aSmO1S1S5;
    if (smO1S1 != SmO1S1.s1 && aSmO1S1S5 != SmO1S1S5.Null) { setSmO1S1(SmO1S1.s1); }

    // entry actions and do activities
    switch(smO1S1S5)
    {
      case s5:
        if (smO1S1S5S5 == SmO1S1S5S5.Null) { setSmO1S1S5S5(SmO1S1S5S5.s6); }
        break;
    }
  }

  private void exitSmO1S1S5S5()
  {
    switch(smO1S1S5S5)
    {
      case s6:
        setSmO1S1S5S5(SmO1S1S5S5.Null);
        break;
    }
  }

  private void setSmO1S1S5S5(SmO1S1S5S5 aSmO1S1S5S5)
  {
    smO1S1S5S5 = aSmO1S1S5S5;
    if (smO1S1S5 != SmO1S1S5.s5 && aSmO1S1S5S5 != SmO1S1S5S5.Null) { setSmO1S1S5(SmO1S1S5.s5); }

    // entry actions and do activities
    switch(smO1S1S5S5)
    {
      case s6:
        if (smO1S1S2S2 == SmO1S1S2S2.s4 && smO1S7S7 == SmO1S7S7.s9) { delete(); }
        break;
    }
  }

  private void exitSmO1S7()
  {
    switch(smO1S7)
    {
      case s7:
        exitSmO1S7S7();
        setSmO1S7(SmO1S7.Null);
        break;
    }
  }

  private void setSmO1S7(SmO1S7 aSmO1S7)
  {
    smO1S7 = aSmO1S7;
    if (sm != Sm.o1 && aSmO1S7 != SmO1S7.Null) { setSm(Sm.o1); }

    // entry actions and do activities
    switch(smO1S7)
    {
      case s7:
        if (smO1S7S7 == SmO1S7S7.Null) { setSmO1S7S7(SmO1S7S7.s8); }
        break;
    }
  }

  private void exitSmO1S7S7()
  {
    switch(smO1S7S7)
    {
      case s8:
        setSmO1S7S7(SmO1S7S7.Null);
        break;
      case s9:
        setSmO1S7S7(SmO1S7S7.Null);
        break;
    }
  }

  private void setSmO1S7S7(SmO1S7S7 aSmO1S7S7)
  {
    smO1S7S7 = aSmO1S7S7;
    if (smO1S7 != SmO1S7.s7 && aSmO1S7S7 != SmO1S7S7.Null) { setSmO1S7(SmO1S7.s7); }

    // entry actions and do activities
    switch(smO1S7S7)
    {
      case s9:
        if (smO1S1S2S2 == SmO1S1S2S2.s4 && smO1S1S5S5 == SmO1S1S5S5.s6) { delete(); }
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "testRegionFinalStates_6.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Status { s1, Final, s2, s3 }
  public enum StatusS1S11 { Null, s11, fState1 }
  public enum StatusS1S11S11 { Null, s111 }
  public enum StatusS1S11S11S111 { Null, s111 }
  public enum StatusS1S12 { Null, s12 }
  public enum StatusS1S12S12 { Null, s122, fState2 }
  private Status status;
  private StatusS1S11 statusS1S11;
  private StatusS1S11S11 statusS1S11S11;
  private StatusS1S11S11S111 statusS1S11S11S111;
  private StatusS1S12 statusS1S12;
  private StatusS1S12S12 statusS1S12S12;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setStatusS1S11(StatusS1S11.Null);
    setStatusS1S11S11(StatusS1S11S11.Null);
    setStatusS1S11S11S111(StatusS1S11S11S111.Null);
    setStatusS1S12(StatusS1S12.Null);
    setStatusS1S12S12(StatusS1S12S12.Null);
    setStatus(Status.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    if (statusS1S11 != StatusS1S11.Null) { answer += "." + statusS1S11.toString(); }
    if (statusS1S11S11 != StatusS1S11S11.Null) { answer += "." + statusS1S11S11.toString(); }
    if (statusS1S11S11S111 != StatusS1S11S11S111.Null) { answer += "." + statusS1S11S11S111.toString(); }
    if (statusS1S12 != StatusS1S12.Null) { answer += "." + statusS1S12.toString(); }
    if (statusS1S12S12 != StatusS1S12S12.Null) { answer += "." + statusS1S12S12.toString(); }
    if (statusS1S11S11S111 != StatusS1S11S11S111.Null) { answer += "." + statusS1S11S11S111.toString(); }
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public StatusS1S11 getStatusS1S11()
  {
    return statusS1S11;
  }

  public StatusS1S11S11 getStatusS1S11S11()
  {
    return statusS1S11S11;
  }

  public StatusS1S11S11S111 getStatusS1S11S11S111()
  {
    return statusS1S11S11S111;
  }

  public StatusS1S12 getStatusS1S12()
  {
    return statusS1S12;
  }

  public StatusS1S12S12 getStatusS1S12S12()
  {
    return statusS1S12S12;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case s1:
        exitStatus();
        setStatus(Status.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e4()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case s2:
        setStatus(Status.Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e3()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case s2:
        setStatus(Status.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e()
  {
    boolean wasEventProcessed = false;
    
    StatusS1S11S11S111 aStatusS1S11S11S111 = statusS1S11S11S111;
    switch (aStatusS1S11S11S111)
    {
      case s111:
        exitStatus();
        setStatus(Status.Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean d1()
  {
    boolean wasEventProcessed = false;
    
    StatusS1S11S11S111 aStatusS1S11S11S111 = statusS1S11S11S111;
    switch (aStatusS1S11S11S111)
    {
      case s111:
        exitStatusS1S11();
        setStatusS1S11(StatusS1S11.fState1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean d2()
  {
    boolean wasEventProcessed = false;
    
    StatusS1S12S12 aStatusS1S12S12 = statusS1S12S12;
    switch (aStatusS1S12S12)
    {
      case s122:
        exitStatusS1S12S12();
        setStatusS1S12S12(StatusS1S12S12.fState2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitStatus()
  {
    switch(status)
    {
      case s1:
        exitStatusS1S11();
        exitStatusS1S12();
        // line 4 "testRegionFinalStates_6.ump"
        System.out.println("t4");
        break;
    }
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case s1:
        if (statusS1S11 == StatusS1S11.Null) { setStatusS1S11(StatusS1S11.s11); }
        if (statusS1S12 == StatusS1S12.Null) { setStatusS1S12(StatusS1S12.s12); }
        break;
      case Final:
        delete();
        break;
      case s3:
        delete();
        break;
    }
  }

  private void exitStatusS1S11()
  {
    switch(statusS1S11)
    {
      case s11:
        exitStatusS1S11S11();
        // line 7 "testRegionFinalStates_6.ump"
        System.out.println("t3");
        setStatusS1S11(StatusS1S11.Null);
        break;
      case fState1:
        setStatusS1S11(StatusS1S11.Null);
        break;
    }
  }

  private void setStatusS1S11(StatusS1S11 aStatusS1S11)
  {
    statusS1S11 = aStatusS1S11;
    if (status != Status.s1 && aStatusS1S11 != StatusS1S11.Null) { setStatus(Status.s1); }

    // entry actions and do activities
    switch(statusS1S11)
    {
      case s11:
        if (statusS1S11S11 == StatusS1S11S11.Null) { setStatusS1S11S11(StatusS1S11S11.s111); }
        break;
      case fState1:
        if (statusS1S12S12 == StatusS1S12S12.fState2) { delete(); }
        break;
    }
  }

  private void exitStatusS1S11S11()
  {
    switch(statusS1S11S11)
    {
      case s111:
        exitStatusS1S11S11S111();
        // line 9 "testRegionFinalStates_6.ump"
        System.out.println("t2");
        setStatusS1S11S11(StatusS1S11S11.Null);
        break;
    }
  }

  private void setStatusS1S11S11(StatusS1S11S11 aStatusS1S11S11)
  {
    statusS1S11S11 = aStatusS1S11S11;
    if (statusS1S11 != StatusS1S11.s11 && aStatusS1S11S11 != StatusS1S11S11.Null) { setStatusS1S11(StatusS1S11.s11); }

    // entry actions and do activities
    switch(statusS1S11S11)
    {
      case s111:
        if (statusS1S11S11S111 == StatusS1S11S11S111.Null) { setStatusS1S11S11S111(StatusS1S11S11S111.s111); }
        break;
    }
  }

  private void exitStatusS1S11S11S111()
  {
    switch(statusS1S11S11S111)
    {
      case s111:
        // line 11 "testRegionFinalStates_6.ump"
        System.out.println("t1");
        setStatusS1S11S11S111(StatusS1S11S11S111.Null);
        break;
    }
  }

  private void setStatusS1S11S11S111(StatusS1S11S11S111 aStatusS1S11S11S111)
  {
    statusS1S11S11S111 = aStatusS1S11S11S111;
    if (statusS1S11S11 != StatusS1S11S11.s111 && aStatusS1S11S11S111 != StatusS1S11S11S111.Null) { setStatusS1S11S11(StatusS1S11S11.s111); }
  }

  private void exitStatusS1S12()
  {
    switch(statusS1S12)
    {
      case s12:
        exitStatusS1S12S12();
        setStatusS1S12(StatusS1S12.Null);
        break;
    }
  }

  private void setStatusS1S12(StatusS1S12 aStatusS1S12)
  {
    statusS1S12 = aStatusS1S12;
    if (status != Status.s1 && aStatusS1S12 != StatusS1S12.Null) { setStatus(Status.s1); }

    // entry actions and do activities
    switch(statusS1S12)
    {
      case s12:
        if (statusS1S12S12 == StatusS1S12S12.Null) { setStatusS1S12S12(StatusS1S12S12.s122); }
        break;
    }
  }

  private void exitStatusS1S12S12()
  {
    switch(statusS1S12S12)
    {
      case s122:
        setStatusS1S12S12(StatusS1S12S12.Null);
        break;
      case fState2:
        setStatusS1S12S12(StatusS1S12S12.Null);
        break;
    }
  }

  private void setStatusS1S12S12(StatusS1S12S12 aStatusS1S12S12)
  {
    statusS1S12S12 = aStatusS1S12S12;
    if (statusS1S12 != StatusS1S12.s12 && aStatusS1S12S12 != StatusS1S12S12.Null) { setStatusS1S12(StatusS1S12.s12); }

    // entry actions and do activities
    switch(statusS1S12S12)
    {
      case fState2:
        if (statusS1S11 == StatusS1S11.fState1) { delete(); }
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "checkExternalTransitions_noNestedStateMachines.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2, s3 }
  private Sm sm;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean goToS2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToS3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../pooledStateMachine_timedEvents.ump"
public class Mentor implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Mentor Attributes
  private int howLongUntilOk;

  //Mentor State Machines
  public enum Status { Ok, NotOk }
  private Status status;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by Mentor
  protected enum MessageType { timeoutOkToNotOk_M, timeoutNotOkToOk_M }

  // Map for a Mentor pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Status.Ok,new HashSet<MessageType>(Arrays.asList(MessageType.timeoutOkToNotOk_M)));
    stateMessageMap.put(Status.NotOk,new HashSet<MessageType>(Arrays.asList(MessageType.timeoutNotOkToOk_M)));
  }

  //Helper Variables
  private TimedEventHandler timeoutOkToNotOkHandler;
  private TimedEventHandler timeoutNotOkToOkHandler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Mentor()
  {
    howLongUntilOk = 3;
    setStatus(Status.Ok);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of Mentor
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setHowLongUntilOk(int aHowLongUntilOk)
  {
    boolean wasSet = false;
    howLongUntilOk = aHowLongUntilOk;
    wasSet = true;
    return wasSet;
  }

  public int getHowLongUntilOk()
  {
    return howLongUntilOk;
  }

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean _timeoutOkToNotOk()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Ok:
        exitStatus();
        setStatus(Status.NotOk);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _timeoutNotOkToOk()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case NotOk:
        exitStatus();
        setStatus(Status.Ok);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitStatus()
  {
    switch(status)
    {
      case Ok:
        stopTimeoutOkToNotOkHandler();
        break;
      case NotOk:
        stopTimeoutNotOkToOkHandler();
        break;
    }
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case Ok:
        startTimeoutOkToNotOkHandler();
        break;
      case NotOk:
        startTimeoutNotOkToOkHandler();
        break;
    }
  }

  private void startTimeoutOkToNotOkHandler()
  {
    timeoutOkToNotOkHandler = new TimedEventHandler(this,"timeoutOkToNotOk",4);
  }

  private void stopTimeoutOkToNotOkHandler()
  {
    timeoutOkToNotOkHandler.stop();
  }

  private void startTimeoutNotOkToOkHandler()
  {
    timeoutNotOkToOkHandler = new TimedEventHandler(this,"timeoutNotOkToOk",howLongUntilOk);
  }

  private void stopTimeoutNotOkToOkHandler()
  {
    timeoutNotOkToOkHandler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private Mentor controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(Mentor aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeoutOkToNotOk".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeoutOkToNotOk();
        if (shouldRestart)
        {
          controller.startTimeoutOkToNotOkHandler();
        }
        return;
      }
      if ("timeoutNotOkToOk".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeoutNotOkToOk();
        if (shouldRestart)
        {
          controller.startTimeoutNotOkToOkHandler();
        }
        return;
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getStatus()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public boolean timeoutOkToNotOk ()
  {
    boolean wasAdded = false;
    pool.put(new Message(MessageType.timeoutOkToNotOk_M, null));
    wasAdded = true;
    return wasAdded;
  }

  public boolean timeoutNotOkToOk ()
  {
    boolean wasAdded = false;
    pool.put(new Message(MessageType.timeoutNotOkToOk_M, null));
    wasAdded = true;
    return wasAdded;
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case timeoutOkToNotOk_M:
          status = _timeoutOkToNotOk();
          break;
        case timeoutNotOkToOk_M:
          status = _timeoutNotOkToOk();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }

  public String toString()
  {
    return super.toString() + "["+
            "howLongUntilOk" + ":" + getHowLongUntilOk()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "stateMachineWithNegativeNumberGuard2.ump"
public class stateMachineWithNegativeNumberGuard2
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //stateMachineWithNegativeNumberGuard2 State Machines
  public enum Status { on, off }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public stateMachineWithNegativeNumberGuard2()
  {
    setStatus(Status.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean turnOff(Integer pn)
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        if (pn<-1)
        {
          setStatus(Status.off);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean turnOn()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case off:
        setStatus(Status.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "parallelSm_diffNamesDiffStates_2.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1 }
  public enum SmS0T1 { Null, t1 }
  public enum SmS0T2 { Null, t2, t3 }
  public enum SmS1 { Null, s2 }
  public enum SmS1S2T4 { Null, t4, t5 }
  public enum SmS1S2T6 { Null, t6, t7 }
  private Sm sm;
  private SmS0T1 smS0T1;
  private SmS0T2 smS0T2;
  private SmS1 smS1;
  private SmS1S2T4 smS1S2T4;
  private SmS1S2T6 smS1S2T6;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS0T1(SmS0T1.Null);
    setSmS0T2(SmS0T2.Null);
    setSmS1(SmS1.Null);
    setSmS1S2T4(SmS1S2T4.Null);
    setSmS1S2T6(SmS1S2T6.Null);
    setSm(Sm.s0);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS0T1 != SmS0T1.Null) { answer += "." + smS0T1.toString(); }
    if (smS0T2 != SmS0T2.Null) { answer += "." + smS0T2.toString(); }
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    if (smS1S2T4 != SmS1S2T4.Null) { answer += "." + smS1S2T4.toString(); }
    if (smS1S2T6 != SmS1S2T6.Null) { answer += "." + smS1S2T6.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS0T1 getSmS0T1()
  {
    return smS0T1;
  }

  public SmS0T2 getSmS0T2()
  {
    return smS0T2;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public SmS1S2T4 getSmS1S2T4()
  {
    return smS1S2T4;
  }

  public SmS1S2T6 getSmS1S2T6()
  {
    return smS1S2T6;
  }

  public boolean goS1()
  {
    boolean wasEventProcessed = false;
    
    SmS0T1 aSmS0T1 = smS0T1;
    switch (aSmS0T1)
    {
      case t1:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT3()
  {
    boolean wasEventProcessed = false;
    
    SmS0T2 aSmS0T2 = smS0T2;
    switch (aSmS0T2)
    {
      case t2:
        exitSmS0T2();
        setSmS0T2(SmS0T2.t3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT5()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2T4 aSmS1S2T4 = smS1S2T4;
    switch (aSmS1S2T4)
    {
      case t4:
        exitSmS1S2T4();
        setSmS1S2T4(SmS1S2T4.t5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT7()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2T6 aSmS1S2T6 = smS1S2T6;
    switch (aSmS1S2T6)
    {
      case t6:
        exitSmS1S2T6();
        setSmS1S2T6(SmS1S2T6.t7);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s0:
        exitSmS0T1();
        exitSmS0T2();
        break;
      case s1:
        exitSmS1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        if (smS0T1 == SmS0T1.Null) { setSmS0T1(SmS0T1.t1); }
        if (smS0T2 == SmS0T2.Null) { setSmS0T2(SmS0T2.t2); }
        break;
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s2); }
        break;
    }
  }

  private void exitSmS0T1()
  {
    switch(smS0T1)
    {
      case t1:
        setSmS0T1(SmS0T1.Null);
        break;
    }
  }

  private void setSmS0T1(SmS0T1 aSmS0T1)
  {
    smS0T1 = aSmS0T1;
    if (sm != Sm.s0 && aSmS0T1 != SmS0T1.Null) { setSm(Sm.s0); }
  }

  private void exitSmS0T2()
  {
    switch(smS0T2)
    {
      case t2:
        setSmS0T2(SmS0T2.Null);
        break;
      case t3:
        setSmS0T2(SmS0T2.Null);
        break;
    }
  }

  private void setSmS0T2(SmS0T2 aSmS0T2)
  {
    smS0T2 = aSmS0T2;
    if (sm != Sm.s0 && aSmS0T2 != SmS0T2.Null) { setSm(Sm.s0); }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s2:
        exitSmS1S2T4();
        exitSmS1S2T6();
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1)
    {
      case s2:
        if (smS1S2T4 == SmS1S2T4.Null) { setSmS1S2T4(SmS1S2T4.t4); }
        if (smS1S2T6 == SmS1S2T6.Null) { setSmS1S2T6(SmS1S2T6.t6); }
        break;
    }
  }

  private void exitSmS1S2T4()
  {
    switch(smS1S2T4)
    {
      case t4:
        setSmS1S2T4(SmS1S2T4.Null);
        break;
      case t5:
        setSmS1S2T4(SmS1S2T4.Null);
        break;
    }
  }

  private void setSmS1S2T4(SmS1S2T4 aSmS1S2T4)
  {
    smS1S2T4 = aSmS1S2T4;
    if (smS1 != SmS1.s2 && aSmS1S2T4 != SmS1S2T4.Null) { setSmS1(SmS1.s2); }
  }

  private void exitSmS1S2T6()
  {
    switch(smS1S2T6)
    {
      case t6:
        setSmS1S2T6(SmS1S2T6.Null);
        break;
      case t7:
        setSmS1S2T6(SmS1S2T6.Null);
        break;
    }
  }

  private void setSmS1S2T6(SmS1S2T6 aSmS1S2T6)
  {
    smS1S2T6 = aSmS1S2T6;
    if (smS1 != SmS1.s2 && aSmS1S2T6 != SmS1S2T6.Null) { setSmS1(SmS1.s2); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "testFinalKeyword.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, Final }
  public enum SmS1 { Null, s2 }
  private Sm sm;
  private SmS1 smS1;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public boolean goToFinal()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s2:
        exitSm();
        setSm(Sm.Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s2); }
        break;
      case Final:
        delete();
        break;
    }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s2:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 4 "../transitionAction.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean register()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        // line 8 "../transitionAction.ump"
        System.out.println("transition");
        setStatus(Status.Open);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedWithConcurrensStatesCourseAttempt.ump"
public class CourseAttempt implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //CourseAttempt State Machines
  public enum CourseAttemptSM { studying, failed, passed }
  public enum CourseAttemptSMStudyingLab1 { Null, lab1, lab2 }
  public enum CourseAttemptSMStudyingTermProject { Null, termProject }
  public enum CourseAttemptSMStudyingFinalExam { Null, finalExam }
  private CourseAttemptSM courseAttemptSM;
  private CourseAttemptSMStudyingLab1 courseAttemptSMStudyingLab1;
  private CourseAttemptSMStudyingTermProject courseAttemptSMStudyingTermProject;
  private CourseAttemptSMStudyingFinalExam courseAttemptSMStudyingFinalExam;
  
  //enumeration type of messages accepted by CourseAttempt
  protected enum MessageType {  }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public CourseAttempt()
  {
    setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1.Null);
    setCourseAttemptSMStudyingTermProject(CourseAttemptSMStudyingTermProject.Null);
    setCourseAttemptSMStudyingFinalExam(CourseAttemptSMStudyingFinalExam.Null);
    setCourseAttemptSM(CourseAttemptSM.studying);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of CourseAttempt
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getCourseAttemptSMFullName()
  {
    String answer = courseAttemptSM.toString();
    if (courseAttemptSMStudyingLab1 != CourseAttemptSMStudyingLab1.Null) { answer += "." + courseAttemptSMStudyingLab1.toString(); }
    if (courseAttemptSMStudyingTermProject != CourseAttemptSMStudyingTermProject.Null) { answer += "." + courseAttemptSMStudyingTermProject.toString(); }
    if (courseAttemptSMStudyingFinalExam != CourseAttemptSMStudyingFinalExam.Null) { answer += "." + courseAttemptSMStudyingFinalExam.toString(); }
    return answer;
  }

  public CourseAttemptSM getCourseAttemptSM()
  {
    return courseAttemptSM;
  }

  public CourseAttemptSMStudyingLab1 getCourseAttemptSMStudyingLab1()
  {
    return courseAttemptSMStudyingLab1;
  }

  public CourseAttemptSMStudyingTermProject getCourseAttemptSMStudyingTermProject()
  {
    return courseAttemptSMStudyingTermProject;
  }

  public CourseAttemptSMStudyingFinalExam getCourseAttemptSMStudyingFinalExam()
  {
    return courseAttemptSMStudyingFinalExam;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    CourseAttemptSM aCourseAttemptSM = courseAttemptSM;
    switch (aCourseAttemptSM)
    {
      case studying:
        exitCourseAttemptSM();
        setCourseAttemptSM(CourseAttemptSM.passed);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitCourseAttemptSM()
  {
    switch(courseAttemptSM)
    {
      case studying:
        exitCourseAttemptSMStudyingLab1();
        exitCourseAttemptSMStudyingTermProject();
        exitCourseAttemptSMStudyingFinalExam();
        break;
    }
  }

  private void setCourseAttemptSM(CourseAttemptSM aCourseAttemptSM)
  {
    courseAttemptSM = aCourseAttemptSM;

    // entry actions and do activities
    switch(courseAttemptSM)
    {
      case studying:
        if (courseAttemptSMStudyingLab1 == CourseAttemptSMStudyingLab1.Null) { setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1.lab1); }
        if (courseAttemptSMStudyingTermProject == CourseAttemptSMStudyingTermProject.Null) { setCourseAttemptSMStudyingTermProject(CourseAttemptSMStudyingTermProject.termProject); }
        if (courseAttemptSMStudyingFinalExam == CourseAttemptSMStudyingFinalExam.Null) { setCourseAttemptSMStudyingFinalExam(CourseAttemptSMStudyingFinalExam.finalExam); }
        __autotransition1__();
        break;
    }
  }

  private void exitCourseAttemptSMStudyingLab1()
  {
    switch(courseAttemptSMStudyingLab1)
    {
      case lab1:
        setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1.Null);
        break;
      case lab2:
        // line 12 "../queuedWithConcurrensStatesCourseAttempt.ump"
        lab2Done();
        setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1.Null);
        break;
    }
  }

  private void setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1 aCourseAttemptSMStudyingLab1)
  {
    courseAttemptSMStudyingLab1 = aCourseAttemptSMStudyingLab1;
    if (courseAttemptSM != CourseAttemptSM.studying && aCourseAttemptSMStudyingLab1 != CourseAttemptSMStudyingLab1.Null) { setCourseAttemptSM(CourseAttemptSM.studying); }
  }

  private void exitCourseAttemptSMStudyingTermProject()
  {
    switch(courseAttemptSMStudyingTermProject)
    {
      case termProject:
        // line 18 "../queuedWithConcurrensStatesCourseAttempt.ump"
        projectDone();
        setCourseAttemptSMStudyingTermProject(CourseAttemptSMStudyingTermProject.Null);
        break;
    }
  }

  private void setCourseAttemptSMStudyingTermProject(CourseAttemptSMStudyingTermProject aCourseAttemptSMStudyingTermProject)
  {
    courseAttemptSMStudyingTermProject = aCourseAttemptSMStudyingTermProject;
    if (courseAttemptSM != CourseAttemptSM.studying && aCourseAttemptSMStudyingTermProject != CourseAttemptSMStudyingTermProject.Null) { setCourseAttemptSM(CourseAttemptSM.studying); }
  }

  private void exitCourseAttemptSMStudyingFinalExam()
  {
    switch(courseAttemptSMStudyingFinalExam)
    {
      case finalExam:
        // line 25 "../queuedWithConcurrensStatesCourseAttempt.ump"
        pass();
        setCourseAttemptSMStudyingFinalExam(CourseAttemptSMStudyingFinalExam.Null);
        break;
    }
  }

  private void setCourseAttemptSMStudyingFinalExam(CourseAttemptSMStudyingFinalExam aCourseAttemptSMStudyingFinalExam)
  {
    courseAttemptSMStudyingFinalExam = aCourseAttemptSMStudyingFinalExam;
    if (courseAttemptSM != CourseAttemptSM.studying && aCourseAttemptSMStudyingFinalExam != CourseAttemptSMStudyingFinalExam.Null) { setCourseAttemptSM(CourseAttemptSM.studying); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      { 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "testFinalKeyword_2.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, Final, s3 }
  public enum SmS1 { Null, s2 }
  public enum SmS3 { Null, s4 }
  public enum SmS3S4 { Null, s5 }
  private Sm sm;
  private SmS1 smS1;
  private SmS3 smS3;
  private SmS3S4 smS3S4;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSmS3(SmS3.Null);
    setSmS3S4(SmS3S4.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    if (smS3 != SmS3.Null) { answer += "." + smS3.toString(); }
    if (smS3S4 != SmS3S4.Null) { answer += "." + smS3S4.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public SmS3 getSmS3()
  {
    return smS3;
  }

  public SmS3S4 getSmS3S4()
  {
    return smS3S4;
  }

  public boolean goToS3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToFinal()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    SmS3S4 aSmS3S4 = smS3S4;
    switch (aSmS1)
    {
      case s2:
        exitSm();
        setSm(Sm.Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSmS3S4)
    {
      case s5:
        exitSm();
        setSm(Sm.Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
      case s3:
        exitSmS3();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s2); }
        break;
      case Final:
        delete();
        break;
      case s3:
        if (smS3 == SmS3.Null) { setSmS3(SmS3.s4); }
        break;
    }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s2:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }
  }

  private void exitSmS3()
  {
    switch(smS3)
    {
      case s4:
        exitSmS3S4();
        setSmS3(SmS3.Null);
        break;
    }
  }

  private void setSmS3(SmS3 aSmS3)
  {
    smS3 = aSmS3;
    if (sm != Sm.s3 && aSmS3 != SmS3.Null) { setSm(Sm.s3); }

    // entry actions and do activities
    switch(smS3)
    {
      case s4:
        if (smS3S4 == SmS3S4.Null) { setSmS3S4(SmS3S4.s5); }
        break;
    }
  }

  private void exitSmS3S4()
  {
    switch(smS3S4)
    {
      case s5:
        setSmS3S4(SmS3S4.Null);
        break;
    }
  }

  private void setSmS3S4(SmS3S4 aSmS3S4)
  {
    smS3S4 = aSmS3S4;
    if (smS3 != SmS3.s4 && aSmS3S4 != SmS3S4.Null) { setSmS3(SmS3.s4); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 4 "../FinalState.ump"
public class Mentor
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Mentor State Machines
  public enum Status { Ok, Final }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Mentor()
  {
    setStatus(Status.Ok);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Ok:
        setStatus(Status.Final);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case Final:
        delete();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 4 "../EventTransitionSpacing.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean register()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.Open);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "stateMachine_UnspecifiedReception.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open, Full, error1 }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean register()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.Full);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
        wasEventProcessed = unspecified(getStatus().toString(), "register");
    }

    return wasEventProcessed;
  }

  public boolean unspecified(String state, String event)
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.error1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean reject()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Full:
        setStatus(Status.Full);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case error1:
        setStatus(Status.Open);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case error1:
        __autotransition1__();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../entryExitActionDuplicates.ump"
public class Duplicate
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Duplicate State Machines
  public enum Sm { s0, s1 }
  private Sm sm;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Duplicate()
  {
    setSm(Sm.s0);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean e0()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s0:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      case s1:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s0:
        // line 9 "../entryExitActionDuplicates.ump"
        s0_exit1();
        // line 10 "../entryExitActionDuplicates.ump"
        s0_exit2();
        break;
      case s1:
        // line 16 "../entryExitActionDuplicates.ump"
        s1_exit1();
        // line 17 "../entryExitActionDuplicates.ump"
        s1_exit1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        // line 6 "../entryExitActionDuplicates.ump"
        s0_entr1();
        // line 7 "../entryExitActionDuplicates.ump"
        s0_entry2();
        break;
      case s1:
        // line 13 "../entryExitActionDuplicates.ump"
        s1_entry1();
        // line 14 "../entryExitActionDuplicates.ump"
        s1_entry1();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../testTwoParameterGuard.ump"
public class A_Guard
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //A_Guard State Machines
  public enum Status { S1, S2, S3 }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public A_Guard()
  {
    setStatus(Status.S1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean e1(B myB)
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case S1:
        if (checkGuard(myB))
        {
          setStatus(Status.S2);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e2(B myB,B mySecondB)
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case S2:
        if (checkGuard(myB))
        {
          setStatus(Status.S3);
          wasEventProcessed = true;
          break;
        }
        break;
      case S3:
        if (checkGuard(myB,mySecondB))
        {
          setStatus(Status.S1);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

  // line 19 "../testTwoParameterGuard.ump"
   private boolean checkGuard(B myB){
    return true;
  }

  // line 22 "../testTwoParameterGuard.ump"
   private boolean checkGuard(B myB, B mySecondB){
    return true;
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedWithNestingStatesATM.ump"
public class AutomatedTellerMachine implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //AutomatedTellerMachine State Machines
  public enum Sm { idle, maintenance, active }
  public enum SmActive { Null, validating, selecting, processing, printing }
  private Sm sm;
  private SmActive smActive;
  
  //enumeration type of messages accepted by AutomatedTellerMachine
  protected enum MessageType { cardInserted_M, maintain_M, isMaintained_M, cancel_M, validated_M, select_M, selectAnotherTransiction_M, finish_M, receiptPrinted_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public AutomatedTellerMachine()
  {
    setSmActive(SmActive.Null);
    setSm(Sm.idle);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of AutomatedTellerMachine
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smActive != SmActive.Null) { answer += "." + smActive.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmActive getSmActive()
  {
    return smActive;
  }

  public boolean _cardInserted()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case idle:
        setSm(Sm.active);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _maintain()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case idle:
        setSm(Sm.maintenance);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _isMaintained()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case maintenance:
        setSm(Sm.idle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _cancel()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case active:
        exitSm();
        setSm(Sm.idle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _validated()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case validating:
        exitSmActive();
        setSmActive(SmActive.selecting);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _select()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case selecting:
        exitSmActive();
        setSmActive(SmActive.processing);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _selectAnotherTransiction()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case processing:
        exitSmActive();
        setSmActive(SmActive.selecting);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _finish()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case processing:
        exitSmActive();
        setSmActive(SmActive.printing);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _receiptPrinted()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case printing:
        exitSm();
        setSm(Sm.idle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case active:
        exitSmActive();
        // line 18 "../queuedWithNestingStatesATM.ump"
        ejectCard();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case active:
        // line 17 "../queuedWithNestingStatesATM.ump"
        readCard();
        if (smActive == SmActive.Null) { setSmActive(SmActive.validating); }
        break;
    }
  }

  private void exitSmActive()
  {
    switch(smActive)
    {
      case validating:
        setSmActive(SmActive.Null);
        break;
      case selecting:
        setSmActive(SmActive.Null);
        break;
      case processing:
        setSmActive(SmActive.Null);
        break;
      case printing:
        setSmActive(SmActive.Null);
        break;
    }
  }

  private void setSmActive(SmActive aSmActive)
  {
    smActive = aSmActive;
    if (sm != Sm.active && aSmActive != SmActive.Null) { setSm(Sm.active); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void cardInserted ()
  {
    queue.put(new Message(MessageType.cardInserted_M, null));
  }

  public void maintain ()
  {
    queue.put(new Message(MessageType.maintain_M, null));
  }

  public void isMaintained ()
  {
    queue.put(new Message(MessageType.isMaintained_M, null));
  }

  public void cancel ()
  {
    queue.put(new Message(MessageType.cancel_M, null));
  }

  public void validated ()
  {
    queue.put(new Message(MessageType.validated_M, null));
  }

  public void select ()
  {
    queue.put(new Message(MessageType.select_M, null));
  }

  public void selectAnotherTransiction ()
  {
    queue.put(new Message(MessageType.selectAnotherTransiction_M, null));
  }

  public void finish ()
  {
    queue.put(new Message(MessageType.finish_M, null));
  }

  public void receiptPrinted ()
  {
    queue.put(new Message(MessageType.receiptPrinted_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case cardInserted_M:
          status = _cardInserted();
          break;
        case maintain_M:
          status = _maintain();
          break;
        case isMaintained_M:
          status = _isMaintained();
          break;
        case cancel_M:
          status = _cancel();
          break;
        case validated_M:
          status = _validated();
          break;
        case select_M:
          status = _select();
          break;
        case selectAnotherTransiction_M:
          status = _selectAnotherTransiction();
          break;
        case finish_M:
          status = _finish();
          break;
        case receiptPrinted_M:
          status = _receiptPrinted();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "eventWithArguments.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture Attributes
  private int brightness;

  //LightFixture State Machines
  public enum Bulb { Off, Dimmed, On }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    brightness = 0;
    setBulb(Bulb.Off);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setBrightness(int aBrightness)
  {
    boolean wasSet = false;
    brightness = aBrightness;
    wasSet = true;
    return wasSet;
  }

  public int getBrightness()
  {
    return brightness;
  }

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean turnDimmer(Integer lightval)
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        // line 6 "eventWithArguments.ump"
        setBrightness(lightval)
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case Dimmed:
        // line 12 "eventWithArguments.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case On:
        // line 16 "eventWithArguments.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean flipSwitch()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case Dimmed:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case On:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean entry()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Dimmed:
        if (dimmer>99)
        {
          setBulb(Bulb.On);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "brightness" + ":" + getBrightness()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../entryAction.ump"
public class Light
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Light State Machines
  public enum Status { On, Off }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Light()
  {
    setStatus(Status.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case On:
        setStatus(Status.Off);
        wasEventProcessed = true;
        break;
      case Off:
        setStatus(Status.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case On:
        // line 8 "../entryAction.ump"
        System.out.println("entry");
        // line 9 "../entryAction.ump"
        System.out.println("entry2");
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../refactorFinalState_invalidElementsInNestedFinalState.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Status { on, off, FINAL }
  public enum StatusFINAL { Null, nestedSm }
  public enum StatusFINALNestedSm { Null, nestedFinal }
  private Status status;
  private StatusFINAL statusFINAL;
  private StatusFINALNestedSm statusFINALNestedSm;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setStatusFINAL(StatusFINAL.Null);
    setStatusFINALNestedSm(StatusFINALNestedSm.Null);
    setStatus(Status.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    if (statusFINAL != StatusFINAL.Null) { answer += "." + statusFINAL.toString(); }
    if (statusFINALNestedSm != StatusFINALNestedSm.Null) { answer += "." + statusFINALNestedSm.toString(); }
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public StatusFINAL getStatusFINAL()
  {
    return statusFINAL;
  }

  public StatusFINALNestedSm getStatusFINALNestedSm()
  {
    return statusFINALNestedSm;
  }

  public boolean turnoff()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        setStatus(Status.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean powerOff()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        setStatus(Status.FINAL);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean turnOn()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case off:
        setStatus(Status.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitStatus()
  {
    switch(status)
    {
      case FINAL:
        exitStatusFINAL();
        break;
    }
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case FINAL:
        if (statusFINAL == StatusFINAL.Null) { setStatusFINAL(StatusFINAL.nestedSm); }
        break;
    }
  }

  private void exitStatusFINAL()
  {
    switch(statusFINAL)
    {
      case nestedSm:
        exitStatusFINALNestedSm();
        setStatusFINAL(StatusFINAL.Null);
        break;
    }
  }

  private void setStatusFINAL(StatusFINAL aStatusFINAL)
  {
    statusFINAL = aStatusFINAL;
    if (status != Status.FINAL && aStatusFINAL != StatusFINAL.Null) { setStatus(Status.FINAL); }

    // entry actions and do activities
    switch(statusFINAL)
    {
      case nestedSm:
        if (statusFINALNestedSm == StatusFINALNestedSm.Null) { setStatusFINALNestedSm(StatusFINALNestedSm.nestedFinal); }
        break;
    }
  }

  private void exitStatusFINALNestedSm()
  {
    switch(statusFINALNestedSm)
    {
      case nestedFinal:
        setStatusFINALNestedSm(StatusFINALNestedSm.Null);
        break;
    }
  }

  private void setStatusFINALNestedSm(StatusFINALNestedSm aStatusFINALNestedSm)
  {
    statusFINALNestedSm = aStatusFINALNestedSm;
    if (statusFINAL != StatusFINAL.nestedSm && aStatusFINALNestedSm != StatusFINALNestedSm.Null) { setStatusFINAL(StatusFINAL.nestedSm); }

    // entry actions and do activities
    switch(statusFINALNestedSm)
    {
      case nestedFinal:
        // line 15 "../refactorFinalState_invalidElementsInNestedFinalState.ump"
        entry();
        delete();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;

// line 12 "nestedStateMachineExtendedByClass.ump"
public class Animal extends ThingInWorld
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Animal Attributes
  private boolean isAlive;

  //Animal State Machines
  public enum State { alive, dead }
  public enum StateAlive { Null, normal, zombie }
  public enum StateAliveNormal { Null, baby, adult }
  private State state;
  private StateAlive stateAlive;
  private StateAliveNormal stateAliveNormal;

  //Animal Associations
  private List<ThingInWorld> drops;
  private World world;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Animal(boolean aIsAlive, World aWorld)
  {
    super();
    isAlive = aIsAlive;
    drops = new ArrayList<ThingInWorld>();
    boolean didAddWorld = setWorld(aWorld);
    if (!didAddWorld)
    {
      throw new RuntimeException("Unable to create animal due to world. See http://manual.umple.org?RE002ViolationofAssociationMultiplicity.html");
    }
    setStateAlive(StateAlive.Null);
    setStateAliveNormal(StateAliveNormal.Null);
    setState(State.alive);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setIsAlive(boolean aIsAlive)
  {
    boolean wasSet = false;
    isAlive = aIsAlive;
    wasSet = true;
    return wasSet;
  }

  public boolean getIsAlive()
  {
    return isAlive;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isIsAlive()
  {
    return isAlive;
  }

  public String getStateFullName()
  {
    String answer = state.toString();
    if (stateAlive != StateAlive.Null) { answer += "." + stateAlive.toString(); }
    if (stateAliveNormal != StateAliveNormal.Null) { answer += "." + stateAliveNormal.toString(); }
    return answer;
  }

  public State getState()
  {
    return state;
  }

  public StateAlive getStateAlive()
  {
    return stateAlive;
  }

  public StateAliveNormal getStateAliveNormal()
  {
    return stateAliveNormal;
  }

  public boolean kill()
  {
    boolean wasEventProcessed = false;
    
    State aState = state;
    switch (aState)
    {
      case alive:
        exitState();
        setState(State.dead);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean haveBaby()
  {
    boolean wasEventProcessed = false;
    
    StateAlive aStateAlive = stateAlive;
    switch (aStateAlive)
    {
      case zombie:
        exitStateAlive();
        setStateAliveNormal(StateAliveNormal.adult);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean growUp()
  {
    boolean wasEventProcessed = false;
    
    StateAliveNormal aStateAliveNormal = stateAliveNormal;
    switch (aStateAliveNormal)
    {
      case baby:
        exitStateAliveNormal();
        setStateAliveNormal(StateAliveNormal.adult);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean zombify()
  {
    boolean wasEventProcessed = false;
    
    StateAliveNormal aStateAliveNormal = stateAliveNormal;
    switch (aStateAliveNormal)
    {
      case adult:
        exitStateAlive();
        setStateAlive(StateAlive.zombie);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitState()
  {
    switch(state)
    {
      case alive:
        exitStateAlive();
        break;
    }
  }

  private void setState(State aState)
  {
    state = aState;

    // entry actions and do activities
    switch(state)
    {
      case alive:
        if (stateAlive == StateAlive.Null) { setStateAlive(StateAlive.normal); }
        break;
    }
  }

  private void exitStateAlive()
  {
    switch(stateAlive)
    {
      case normal:
        exitStateAliveNormal();
        setStateAlive(StateAlive.Null);
        break;
      case zombie:
        setStateAlive(StateAlive.Null);
        break;
    }
  }

  private void setStateAlive(StateAlive aStateAlive)
  {
    stateAlive = aStateAlive;
    if (state != State.alive && aStateAlive != StateAlive.Null) { setState(State.alive); }

    // entry actions and do activities
    switch(stateAlive)
    {
      case normal:
        if (stateAliveNormal == StateAliveNormal.Null) { setStateAliveNormal(StateAliveNormal.baby); }
        break;
    }
  }

  private void exitStateAliveNormal()
  {
    switch(stateAliveNormal)
    {
      case baby:
        setStateAliveNormal(StateAliveNormal.Null);
        break;
      case adult:
        setStateAliveNormal(StateAliveNormal.Null);
        break;
    }
  }

  private void setStateAliveNormal(StateAliveNormal aStateAliveNormal)
  {
    stateAliveNormal = aStateAliveNormal;
    if (stateAlive != StateAlive.normal && aStateAliveNormal != StateAliveNormal.Null) { setStateAlive(StateAlive.normal); }
  }
  /* Code from template association_GetMany */
  public ThingInWorld getDrop(int index)
  {
    ThingInWorld aDrop = drops.get(index);
    return aDrop;
  }

  public List<ThingInWorld> getDrops()
  {
    List<ThingInWorld> newDrops = Collections.unmodifiableList(drops);
    return newDrops;
  }

  public int numberOfDrops()
  {
    int number = drops.size();
    return number;
  }

  public boolean hasDrops()
  {
    boolean has = drops.size() > 0;
    return has;
  }

  public int indexOfDrop(ThingInWorld aDrop)
  {
    int index = drops.indexOf(aDrop);
    return index;
  }
  /* Code from template association_GetOne */
  public World getWorld()
  {
    return world;
  }
  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfDrops()
  {
    return 0;
  }
  /* Code from template association_AddManyToManyMethod */
  public boolean addDrop(ThingInWorld aDrop)
  {
    boolean wasAdded = false;
    if (drops.contains(aDrop)) { return false; }
    drops.add(aDrop);
    if (aDrop.indexOfAnimal(this) != -1)
    {
      wasAdded = true;
    }
    else
    {
      wasAdded = aDrop.addAnimal(this);
      if (!wasAdded)
      {
        drops.remove(aDrop);
      }
    }
    return wasAdded;
  }
  /* Code from template association_RemoveMany */
  public boolean removeDrop(ThingInWorld aDrop)
  {
    boolean wasRemoved = false;
    if (!drops.contains(aDrop))
    {
      return wasRemoved;
    }

    int oldIndex = drops.indexOf(aDrop);
    drops.remove(oldIndex);
    if (aDrop.indexOfAnimal(this) == -1)
    {
      wasRemoved = true;
    }
    else
    {
      wasRemoved = aDrop.removeAnimal(this);
      if (!wasRemoved)
      {
        drops.add(oldIndex,aDrop);
      }
    }
    return wasRemoved;
  }
  /* Code from template association_AddIndexControlFunctions */
  public boolean addDropAt(ThingInWorld aDrop, int index)
  {  
    boolean wasAdded = false;
    if(addDrop(aDrop))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfDrops()) { index = numberOfDrops() - 1; }
      drops.remove(aDrop);
      drops.add(index, aDrop);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveDropAt(ThingInWorld aDrop, int index)
  {
    boolean wasAdded = false;
    if(drops.contains(aDrop))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfDrops()) { index = numberOfDrops() - 1; }
      drops.remove(aDrop);
      drops.add(index, aDrop);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addDropAt(aDrop, index);
    }
    return wasAdded;
  }
  /* Code from template association_SetOneToMany */
  public boolean setWorld(World aWorld)
  {
    boolean wasSet = false;
    if (aWorld == null)
    {
      return wasSet;
    }

    World existingWorld = world;
    world = aWorld;
    if (existingWorld != null && !existingWorld.equals(aWorld))
    {
      existingWorld.removeAnimal(this);
    }
    world.addAnimal(this);
    wasSet = true;
    return wasSet;
  }

  public void delete()
  {
    ArrayList<ThingInWorld> copyOfDrops = new ArrayList<ThingInWorld>(drops);
    drops.clear();
    for(ThingInWorld aDrop : copyOfDrops)
    {
      aDrop.removeAnimal(this);
    }
    World placeholderWorld = world;
    this.world = null;
    if(placeholderWorld != null)
    {
      placeholderWorld.removeAnimal(this);
    }
    super.delete();
  }


  public String toString()
  {
    return super.toString() + "["+
            "isAlive" + ":" + getIsAlive()+ "]" + System.getProperties().getProperty("line.separator") +
            "  " + "world = "+(getWorld()!=null?Integer.toHexString(System.identityHashCode(getWorld())):"null");
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "multiplePooledStateMachine_EventlessStateMachine.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS1 { Null, s1a, s1b }
  private Sm sm;
  private SmS1 smS1;
  public enum Sm1 { s3, s4 }
  private Sm1 sm1;
  public enum Sm2 { q, s }
  private Sm2 sm2;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e2_M, e5_M, e6_M, null_M, e3_M, e4_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.e1_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.e2_M)));
    stateMessageMap.put(SmS1.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(SmS1.s1a,new HashSet<MessageType>(Arrays.asList(MessageType.e5_M)));
    stateMessageMap.put(SmS1.s1b,new HashSet<MessageType>(Arrays.asList(MessageType.e6_M)));
    stateMessageMap.put(Sm1.s3,new HashSet<MessageType>(Arrays.asList(MessageType.e3_M)));
    stateMessageMap.put(Sm1.s4,new HashSet<MessageType>(Arrays.asList(MessageType.e4_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSm(Sm.s1);
    setSm1(Sm1.s3);
    setSm2(Sm2.q);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    return answer;
  }

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    return answer;
  }

  public String getSm2FullName()
  {
    String answer = sm2.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public Sm2 getSm2()
  {
    return sm2;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSmS1();
        setSmS1(SmS1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s3:
        setSm1(Sm1.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e4()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s4:
        setSm1(Sm1.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e5()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1a:
        exitSmS1();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e6()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1b:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s1a); }
        break;
    }
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;
  }

  public boolean setSm2(Sm2 aSm2)
  {
    sm2 = aSm2;
    return true;
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s1a:
        setSmS1(SmS1.Null);
        break;
      case s1b:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSmS1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        if(stateMessageMap.get(getSm1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    pool.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    pool.put(new Message(MessageType.e2_M, null));
  }

  public void e5 ()
  {
    pool.put(new Message(MessageType.e5_M, null));
  }

  public void e6 ()
  {
    pool.put(new Message(MessageType.e6_M, null));
  }

  public void e3 ()
  {
    pool.put(new Message(MessageType.e3_M, null));
  }

  public void e4 ()
  {
    pool.put(new Message(MessageType.e4_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e5_M:
          status = _e5();
          break;
        case e6_M:
          status = _e6();
          break;
        case e3_M:
          status = _e3();
          break;
        case e4_M:
          status = _e4();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedSMwithConcurrentStatesTest.ump"
public class QueuedSMwithConcurrentStates implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //QueuedSMwithConcurrentStates State Machines
  public enum Sm { state1, state2, state3 }
  public enum SmState1SubState1 { Null, subState1 }
  public enum SmState1SubState2 { Null, subState2 }
  private Sm sm;
  private SmState1SubState1 smState1SubState1;
  private SmState1SubState2 smState1SubState2;
  
  //enumeration type of messages accepted by QueuedSMwithConcurrentStates
  protected enum MessageType { transit_M }
  
  MessageQueue queue;
  Thread removal;

  //QueuedSMwithConcurrentStates Do Activity Threads
  Thread doActivitySmState2Thread = null;
  Thread doActivitySmState3Thread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public QueuedSMwithConcurrentStates()
  {
    setSmState1SubState1(SmState1SubState1.Null);
    setSmState1SubState2(SmState1SubState2.Null);
    setSm(Sm.state1);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of QueuedSMwithConcurrentStates
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smState1SubState1 != SmState1SubState1.Null) { answer += "." + smState1SubState1.toString(); }
    if (smState1SubState2 != SmState1SubState2.Null) { answer += "." + smState1SubState2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmState1SubState1 getSmState1SubState1()
  {
    return smState1SubState1;
  }

  public SmState1SubState2 getSmState1SubState2()
  {
    return smState1SubState2;
  }

  public boolean _transit()
  {
    boolean wasEventProcessed = false;
    
    SmState1SubState1 aSmState1SubState1 = smState1SubState1;
    SmState1SubState2 aSmState1SubState2 = smState1SubState2;
    switch (aSmState1SubState1)
    {
      case subState1:
        exitSm();
        setSm(Sm.state2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSmState1SubState2)
    {
      case subState2:
        exitSm();
        setSm(Sm.state3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case state1:
        exitSmState1SubState1();
        exitSmState1SubState2();
        break;
      case state2:
        if (doActivitySmState2Thread != null) { doActivitySmState2Thread.interrupt(); }
        break;
      case state3:
        if (doActivitySmState3Thread != null) { doActivitySmState3Thread.interrupt(); }
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case state1:
        if (smState1SubState1 == SmState1SubState1.Null) { setSmState1SubState1(SmState1SubState1.subState1); }
        if (smState1SubState2 == SmState1SubState2.Null) { setSmState1SubState2(SmState1SubState2.subState2); }
        break;
      case state2:
        doActivitySmState2Thread = new DoActivityThread(this,"doActivitySmState2");
        break;
      case state3:
        doActivitySmState3Thread = new DoActivityThread(this,"doActivitySmState3");
        break;
    }
  }

  private void exitSmState1SubState1()
  {
    switch(smState1SubState1)
    {
      case subState1:
        setSmState1SubState1(SmState1SubState1.Null);
        break;
    }
  }

  private void setSmState1SubState1(SmState1SubState1 aSmState1SubState1)
  {
    smState1SubState1 = aSmState1SubState1;
    if (sm != Sm.state1 && aSmState1SubState1 != SmState1SubState1.Null) { setSm(Sm.state1); }
  }

  private void exitSmState1SubState2()
  {
    switch(smState1SubState2)
    {
      case subState2:
        setSmState1SubState2(SmState1SubState2.Null);
        break;
    }
  }

  private void setSmState1SubState2(SmState1SubState2 aSmState1SubState2)
  {
    smState1SubState2 = aSmState1SubState2;
    if (sm != Sm.state1 && aSmState1SubState2 != SmState1SubState2.Null) { setSm(Sm.state1); }
  }

  private void doActivitySmState2()
  {
    try
    {
      // line 18 "../queuedSMwithConcurrentStatesTest.ump"
      doTransition1();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private void doActivitySmState3()
  {
    try
    {
      // line 22 "../queuedSMwithConcurrentStatesTest.ump"
      doTransition2();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    QueuedSMwithConcurrentStates controller;
    String doActivityMethodName;
    
    public DoActivityThread(QueuedSMwithConcurrentStates aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivitySmState2".equals(doActivityMethodName))
      {
        controller.doActivitySmState2();
      }
        else if ("doActivitySmState3".equals(doActivityMethodName))
      {
        controller.doActivitySmState3();
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void transit ()
  {
    queue.put(new Message(MessageType.transit_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case transit_M:
          status = _transit();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../refactorFinalState_onlyEntryAction.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Status { on, off, FINAL }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setStatus(Status.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean turnoff()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        setStatus(Status.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean powerOff()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        setStatus(Status.FINAL);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean turnOn()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case off:
        setStatus(Status.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case FINAL:
        // line 13 "../refactorFinalState_onlyEntryAction.ump"
        entry();
        delete();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "parallelSm_diffNamesDiffStatesEntryExitActions.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1 }
  public enum SmS0T1 { Null, t1 }
  public enum SmS0T2 { Null, t2, t3 }
  public enum SmS1T4 { Null, t4, t5 }
  public enum SmS1T6 { Null, t6, t7 }
  private Sm sm;
  private SmS0T1 smS0T1;
  private SmS0T2 smS0T2;
  private SmS1T4 smS1T4;
  private SmS1T6 smS1T6;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS0T1(SmS0T1.Null);
    setSmS0T2(SmS0T2.Null);
    setSmS1T4(SmS1T4.Null);
    setSmS1T6(SmS1T6.Null);
    setSm(Sm.s0);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS0T1 != SmS0T1.Null) { answer += "." + smS0T1.toString(); }
    if (smS0T2 != SmS0T2.Null) { answer += "." + smS0T2.toString(); }
    if (smS1T4 != SmS1T4.Null) { answer += "." + smS1T4.toString(); }
    if (smS1T6 != SmS1T6.Null) { answer += "." + smS1T6.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS0T1 getSmS0T1()
  {
    return smS0T1;
  }

  public SmS0T2 getSmS0T2()
  {
    return smS0T2;
  }

  public SmS1T4 getSmS1T4()
  {
    return smS1T4;
  }

  public SmS1T6 getSmS1T6()
  {
    return smS1T6;
  }

  public boolean goS1()
  {
    boolean wasEventProcessed = false;
    
    SmS0T1 aSmS0T1 = smS0T1;
    switch (aSmS0T1)
    {
      case t1:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT3()
  {
    boolean wasEventProcessed = false;
    
    SmS0T2 aSmS0T2 = smS0T2;
    switch (aSmS0T2)
    {
      case t2:
        exitSmS0T2();
        setSmS0T2(SmS0T2.t3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT5()
  {
    boolean wasEventProcessed = false;
    
    SmS1T4 aSmS1T4 = smS1T4;
    switch (aSmS1T4)
    {
      case t4:
        exitSmS1T4();
        setSmS1T4(SmS1T4.t5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT7()
  {
    boolean wasEventProcessed = false;
    
    SmS1T6 aSmS1T6 = smS1T6;
    switch (aSmS1T6)
    {
      case t6:
        exitSmS1T6();
        setSmS1T6(SmS1T6.t7);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s0:
        exitSmS0T1();
        exitSmS0T2();
        break;
      case s1:
        exitSmS1T4();
        exitSmS1T6();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        if (smS0T1 == SmS0T1.Null) { setSmS0T1(SmS0T1.t1); }
        if (smS0T2 == SmS0T2.Null) { setSmS0T2(SmS0T2.t2); }
        break;
      case s1:
        if (smS1T4 == SmS1T4.Null) { setSmS1T4(SmS1T4.t4); }
        if (smS1T6 == SmS1T6.Null) { setSmS1T6(SmS1T6.t6); }
        break;
    }
  }

  private void exitSmS0T1()
  {
    switch(smS0T1)
    {
      case t1:
        setSmS0T1(SmS0T1.Null);
        break;
    }
  }

  private void setSmS0T1(SmS0T1 aSmS0T1)
  {
    smS0T1 = aSmS0T1;
    if (sm != Sm.s0 && aSmS0T1 != SmS0T1.Null) { setSm(Sm.s0); }
  }

  private void exitSmS0T2()
  {
    switch(smS0T2)
    {
      case t2:
        // line 10 "parallelSm_diffNamesDiffStatesEntryExitActions.ump"
        t2_exit_action();
        setSmS0T2(SmS0T2.Null);
        break;
      case t3:
        setSmS0T2(SmS0T2.Null);
        break;
    }
  }

  private void setSmS0T2(SmS0T2 aSmS0T2)
  {
    smS0T2 = aSmS0T2;
    if (sm != Sm.s0 && aSmS0T2 != SmS0T2.Null) { setSm(Sm.s0); }

    // entry actions and do activities
    switch(smS0T2)
    {
      case t2:
        // line 9 "parallelSm_diffNamesDiffStatesEntryExitActions.ump"
        t2_entry_action();
        break;
    }
  }

  private void exitSmS1T4()
  {
    switch(smS1T4)
    {
      case t4:
        setSmS1T4(SmS1T4.Null);
        break;
      case t5:
        setSmS1T4(SmS1T4.Null);
        break;
    }
  }

  private void setSmS1T4(SmS1T4 aSmS1T4)
  {
    smS1T4 = aSmS1T4;
    if (sm != Sm.s1 && aSmS1T4 != SmS1T4.Null) { setSm(Sm.s1); }
  }

  private void exitSmS1T6()
  {
    switch(smS1T6)
    {
      case t6:
        // line 23 "parallelSm_diffNamesDiffStatesEntryExitActions.ump"
        t6_exit_action();
        setSmS1T6(SmS1T6.Null);
        break;
      case t7:
        setSmS1T6(SmS1T6.Null);
        break;
    }
  }

  private void setSmS1T6(SmS1T6 aSmS1T6)
  {
    smS1T6 = aSmS1T6;
    if (sm != Sm.s1 && aSmS1T6 != SmS1T6.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1T6)
    {
      case t6:
        // line 22 "parallelSm_diffNamesDiffStatesEntryExitActions.ump"
        t6_entry_action();
        break;
    }
  }

  public void delete()
  {}

  // line 29 "parallelSm_diffNamesDiffStatesEntryExitActions.ump"
  public void t2_entry_action(){
    
  }

  // line 30 "parallelSm_diffNamesDiffStatesEntryExitActions.ump"
  public void t6_entry_action(){
    
  }

  // line 31 "parallelSm_diffNamesDiffStatesEntryExitActions.ump"
  public void t2_exit_action(){
    
  }

  // line 32 "parallelSm_diffNamesDiffStatesEntryExitActions.ump"
  public void t6_exit_action(){
    
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;

// line 1 "duplicateTimeoutVariableAndMethod.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm1 { s1, s2 }
  private Sm1 sm1;
  public enum Sm2 { s1, s2 }
  private Sm2 sm2;

  //Helper Variables
  private TimedEventHandler sm1_timeouts1Tos2Handler;
  private TimedEventHandler sm2_timeouts1Tos2Handler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm1(Sm1.s1);
    setSm2(Sm2.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    return answer;
  }

  public String getSm2FullName()
  {
    String answer = sm2.toString();
    return answer;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public Sm2 getSm2()
  {
    return sm2;
  }

  public boolean timeouts1Tos2()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    Sm2 aSm2 = sm2;
    switch (aSm1)
    {
      case s1:
        exitSm1();
        setSm1(Sm1.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSm2)
    {
      case s1:
        exitSm2();
        setSm2(Sm2.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm1()
  {
    switch(sm1)
    {
      case s1:
        stopSm1_timeouts1Tos2Handler();
        break;
    }
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;

    // entry actions and do activities
    switch(sm1)
    {
      case s1:
        startSm1_timeouts1Tos2Handler();
        break;
    }
  }

  private void exitSm2()
  {
    switch(sm2)
    {
      case s1:
        stopSm2_timeouts1Tos2Handler();
        break;
    }
  }

  private void setSm2(Sm2 aSm2)
  {
    sm2 = aSm2;

    // entry actions and do activities
    switch(sm2)
    {
      case s1:
        startSm2_timeouts1Tos2Handler();
        break;
    }
  }

  private void startSm1_timeouts1Tos2Handler()
  {
    sm1_timeouts1Tos2Handler = new TimedEventHandler(this,"sm1_timeouts1Tos2",1);
  }

  private void stopSm1_timeouts1Tos2Handler()
  {
    sm1_timeouts1Tos2Handler.stop();
  }

  private void startSm2_timeouts1Tos2Handler()
  {
    sm2_timeouts1Tos2Handler = new TimedEventHandler(this,"sm2_timeouts1Tos2",1);
  }

  private void stopSm2_timeouts1Tos2Handler()
  {
    sm2_timeouts1Tos2Handler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private X controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(X aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("sm1_timeouts1Tos2".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts1Tos2();
        if (shouldRestart)
        {
          controller.startSm1_timeouts1Tos2Handler();
        }
        return;
      }
      if ("sm2_timeouts1Tos2".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts1Tos2();
        if (shouldRestart)
        {
          controller.startSm2_timeouts1Tos2Handler();
        }
        return;
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../multipleGuardsSameEventWithDefaultNoGuard.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture Attributes
  private int brightness;

  //LightFixture State Machines
  public enum Bulb { On, Off, Amber }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    brightness = 0;
    setBulb(Bulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setBrightness(int aBrightness)
  {
    boolean wasSet = false;
    brightness = aBrightness;
    wasSet = true;
    return wasSet;
  }

  public int getBrightness()
  {
    return brightness;
  }

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean push()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case On:
        if (getBrightness()<1)
        {
          setBulb(Bulb.Off);
          wasEventProcessed = true;
          break;
        }
        if (getBrightness()>10)
        {
          setBulb(Bulb.Amber);
          wasEventProcessed = true;
          break;
        }
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "brightness" + ":" + getBrightness()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../refactorFinalState_empty.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Status { on, off, FINAL }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setStatus(Status.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean turnoff()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        setStatus(Status.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean powerOff()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        setStatus(Status.FINAL);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean turnOn()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case off:
        setStatus(Status.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case FINAL:
        delete();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "multipleQSM_EventlessStateMachine.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS1 { Null, s1a, s1b }
  private Sm sm;
  private SmS1 smS1;
  public enum Sm1 { s3, s4 }
  private Sm1 sm1;
  public enum Sm2 { q, s }
  private Sm2 sm2;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e2_M, e5_M, e6_M, e3_M, e4_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSm(Sm.s1);
    setSm1(Sm1.s3);
    setSm2(Sm2.q);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    return answer;
  }

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    return answer;
  }

  public String getSm2FullName()
  {
    String answer = sm2.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public Sm2 getSm2()
  {
    return sm2;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSmS1();
        setSmS1(SmS1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s3:
        setSm1(Sm1.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e4()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s4:
        setSm1(Sm1.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e5()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1a:
        exitSmS1();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e6()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1b:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s1a); }
        break;
    }
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;
  }

  public boolean setSm2(Sm2 aSm2)
  {
    sm2 = aSm2;
    return true;
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s1a:
        setSmS1(SmS1.Null);
        break;
      case s1b:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    queue.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    queue.put(new Message(MessageType.e2_M, null));
  }

  public void e5 ()
  {
    queue.put(new Message(MessageType.e5_M, null));
  }

  public void e6 ()
  {
    queue.put(new Message(MessageType.e6_M, null));
  }

  public void e3 ()
  {
    queue.put(new Message(MessageType.e3_M, null));
  }

  public void e4 ()
  {
    queue.put(new Message(MessageType.e4_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e5_M:
          status = _e5();
          break;
        case e6_M:
          status = _e6();
          break;
        case e3_M:
          status = _e3();
          break;
        case e4_M:
          status = _e4();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 16 "../SimpleStateMachineSpacing.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open, Full }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean setStatus(Status aStatus)
  {
    status = aStatus;
    return true;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedWithConcurrentStateMachines.ump"
public class QueuedWithConcurrentStateMachines implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //QueuedWithConcurrentStateMachines State Machines
  public enum Sm { s1, s2 }
  public enum SmS2S2a { Null, s2a }
  public enum SmS2S2b { Null, s2b }
  private Sm sm;
  private SmS2S2a smS2S2a;
  private SmS2S2b smS2S2b;
  
  //enumeration type of messages accepted by QueuedWithConcurrentStateMachines
  protected enum MessageType { e1_M, e2_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public QueuedWithConcurrentStateMachines()
  {
    setSmS2S2a(SmS2S2a.Null);
    setSmS2S2b(SmS2S2b.Null);
    setSm(Sm.s1);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of QueuedWithConcurrentStateMachines
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS2S2a != SmS2S2a.Null) { answer += "." + smS2S2a.toString(); }
    if (smS2S2b != SmS2S2b.Null) { answer += "." + smS2S2b.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS2S2a getSmS2S2a()
  {
    return smS2S2a;
  }

  public SmS2S2b getSmS2S2b()
  {
    return smS2S2b;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    SmS2S2a aSmS2S2a = smS2S2a;
    SmS2S2b aSmS2S2b = smS2S2b;
    switch (aSmS2S2a)
    {
      case s2a:
        exitSmS2S2a();
        setSmS2S2b(SmS2S2b.s2b);
        setSmS2S2a(SmS2S2a.s2a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSmS2S2b)
    {
      case s2b:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s2:
        exitSmS2S2a();
        exitSmS2S2b();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s2:
        if (smS2S2a == SmS2S2a.Null) { setSmS2S2a(SmS2S2a.s2a); }
        if (smS2S2b == SmS2S2b.Null) { setSmS2S2b(SmS2S2b.s2b); }
        break;
    }
  }

  private void exitSmS2S2a()
  {
    switch(smS2S2a)
    {
      case s2a:
        setSmS2S2a(SmS2S2a.Null);
        break;
    }
  }

  private void setSmS2S2a(SmS2S2a aSmS2S2a)
  {
    smS2S2a = aSmS2S2a;
    if (sm != Sm.s2 && aSmS2S2a != SmS2S2a.Null) { setSm(Sm.s2); }
  }

  private void exitSmS2S2b()
  {
    switch(smS2S2b)
    {
      case s2b:
        setSmS2S2b(SmS2S2b.Null);
        break;
    }
  }

  private void setSmS2S2b(SmS2S2b aSmS2S2b)
  {
    smS2S2b = aSmS2S2b;
    if (sm != Sm.s2 && aSmS2S2b != SmS2S2b.Null) { setSm(Sm.s2); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    queue.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    queue.put(new Message(MessageType.e2_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "testPooledwithNestedStates.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS2 { Null, s2a, s2b }
  private Sm sm;
  private SmS2 smS2;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e2_M, e3_M, e4_M, e5_M, null_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.e1_M, MessageType.e2_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.e3_M)));
    stateMessageMap.put(SmS2.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(SmS2.s2a,new HashSet<MessageType>(Arrays.asList(MessageType.e4_M)));
    stateMessageMap.put(SmS2.s2b,new HashSet<MessageType>(Arrays.asList(MessageType.e5_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS2(SmS2.Null);
    setSm(Sm.s1);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS2 != SmS2.Null) { answer += "." + smS2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS2 getSmS2()
  {
    return smS2;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSmS2(SmS2.s2b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e4()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2a:
        exitSmS2();
        setSmS2(SmS2.s2b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e5()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2b:
        exitSmS2();
        setSmS2(SmS2.s2a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s2:
        exitSmS2();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s2:
        if (smS2 == SmS2.Null) { setSmS2(SmS2.s2a); }
        break;
    }
  }

  private void exitSmS2()
  {
    switch(smS2)
    {
      case s2a:
        setSmS2(SmS2.Null);
        break;
      case s2b:
        setSmS2(SmS2.Null);
        break;
    }
  }

  private void setSmS2(SmS2 aSmS2)
  {
    smS2 = aSmS2;
    if (sm != Sm.s2 && aSmS2 != SmS2.Null) { setSm(Sm.s2); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSmS2()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    pool.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    pool.put(new Message(MessageType.e2_M, null));
  }

  public void e3 ()
  {
    pool.put(new Message(MessageType.e3_M, null));
  }

  public void e4 ()
  {
    pool.put(new Message(MessageType.e4_M, null));
  }

  public void e5 ()
  {
    pool.put(new Message(MessageType.e5_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e3_M:
          status = _e3();
          break;
        case e4_M:
          status = _e4();
          break;
        case e5_M:
          status = _e5();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "multiplePooledStateMachines_sameEvents.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2, s3, s4 }
  private Sm sm;
  public enum Sm2 { sm21, sm22 }
  private Sm2 sm2;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { ev1_M, ev5_M, ev2_M, ev3_M, ev4_M, ev7_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.ev1_M, MessageType.ev5_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.ev2_M)));
    stateMessageMap.put(Sm.s3,new HashSet<MessageType>(Arrays.asList(MessageType.ev3_M)));
    stateMessageMap.put(Sm.s4,new HashSet<MessageType>(Arrays.asList(MessageType.ev4_M)));
    stateMessageMap.put(Sm2.sm21,new HashSet<MessageType>(Arrays.asList(MessageType.ev1_M)));
    stateMessageMap.put(Sm2.sm22,new HashSet<MessageType>(Arrays.asList(MessageType.ev7_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
    setSm2(Sm2.sm21);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public String getSm2FullName()
  {
    String answer = sm2.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm2 getSm2()
  {
    return sm2;
  }

  public boolean _ev1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    Sm2 aSm2 = sm2;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSm2)
    {
      case sm21:
        setSm2(Sm2.sm22);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev5()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s3:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev4()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s4:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev7()
  {
    boolean wasEventProcessed = false;
    
    Sm2 aSm2 = sm2;
    switch (aSm2)
    {
      case sm22:
        setSm2(Sm2.sm21);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;
  }

  private void setSm2(Sm2 aSm2)
  {
    sm2 = aSm2;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        if(stateMessageMap.get(getSm2()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void ev1 ()
  {
    pool.put(new Message(MessageType.ev1_M, null));
  }

  public void ev5 ()
  {
    pool.put(new Message(MessageType.ev5_M, null));
  }

  public void ev2 ()
  {
    pool.put(new Message(MessageType.ev2_M, null));
  }

  public void ev3 ()
  {
    pool.put(new Message(MessageType.ev3_M, null));
  }

  public void ev4 ()
  {
    pool.put(new Message(MessageType.ev4_M, null));
  }

  public void ev7 ()
  {
    pool.put(new Message(MessageType.ev7_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case ev1_M:
          status = _ev1();
          break;
        case ev5_M:
          status = _ev5();
          break;
        case ev2_M:
          status = _ev2();
          break;
        case ev3_M:
          status = _ev3();
          break;
        case ev4_M:
          status = _ev4();
          break;
        case ev7_M:
          status = _ev7();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../concurrentStates_normal.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Status { Off, On }
  public enum StatusOnMotorIdle { Null, MotorIdle, MotorRunning }
  public enum StatusOnFanIdle { Null, FanIdle, FanRunning }
  private Status status;
  private StatusOnMotorIdle statusOnMotorIdle;
  private StatusOnFanIdle statusOnFanIdle;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setStatusOnMotorIdle(StatusOnMotorIdle.Null);
    setStatusOnFanIdle(StatusOnFanIdle.Null);
    setStatus(Status.Off);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    if (statusOnMotorIdle != StatusOnMotorIdle.Null) { answer += "." + statusOnMotorIdle.toString(); }
    if (statusOnFanIdle != StatusOnFanIdle.Null) { answer += "." + statusOnFanIdle.toString(); }
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public StatusOnMotorIdle getStatusOnMotorIdle()
  {
    return statusOnMotorIdle;
  }

  public StatusOnFanIdle getStatusOnFanIdle()
  {
    return statusOnFanIdle;
  }

  public boolean turnOn()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Off:
        setStatus(Status.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    StatusOnMotorIdle aStatusOnMotorIdle = statusOnMotorIdle;
    switch (aStatusOnMotorIdle)
    {
      case MotorIdle:
        exitStatusOnMotorIdle();
        setStatusOnMotorIdle(StatusOnMotorIdle.MotorRunning);
        wasEventProcessed = true;
        break;
      case MotorRunning:
        exitStatusOnMotorIdle();
        setStatusOnMotorIdle(StatusOnMotorIdle.MotorIdle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean flop()
  {
    boolean wasEventProcessed = false;
    
    StatusOnFanIdle aStatusOnFanIdle = statusOnFanIdle;
    switch (aStatusOnFanIdle)
    {
      case FanIdle:
        exitStatusOnFanIdle();
        setStatusOnFanIdle(StatusOnFanIdle.FanRunning);
        wasEventProcessed = true;
        break;
      case FanRunning:
        exitStatusOnFanIdle();
        setStatusOnFanIdle(StatusOnFanIdle.FanIdle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitStatus()
  {
    switch(status)
    {
      case On:
        exitStatusOnMotorIdle();
        exitStatusOnFanIdle();
        break;
    }
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case On:
        if (statusOnMotorIdle == StatusOnMotorIdle.Null) { setStatusOnMotorIdle(StatusOnMotorIdle.MotorIdle); }
        if (statusOnFanIdle == StatusOnFanIdle.Null) { setStatusOnFanIdle(StatusOnFanIdle.FanIdle); }
        break;
    }
  }

  private void exitStatusOnMotorIdle()
  {
    switch(statusOnMotorIdle)
    {
      case MotorIdle:
        setStatusOnMotorIdle(StatusOnMotorIdle.Null);
        break;
      case MotorRunning:
        setStatusOnMotorIdle(StatusOnMotorIdle.Null);
        break;
    }
  }

  private void setStatusOnMotorIdle(StatusOnMotorIdle aStatusOnMotorIdle)
  {
    statusOnMotorIdle = aStatusOnMotorIdle;
    if (status != Status.On && aStatusOnMotorIdle != StatusOnMotorIdle.Null) { setStatus(Status.On); }
  }

  private void exitStatusOnFanIdle()
  {
    switch(statusOnFanIdle)
    {
      case FanIdle:
        setStatusOnFanIdle(StatusOnFanIdle.Null);
        break;
      case FanRunning:
        setStatusOnFanIdle(StatusOnFanIdle.Null);
        break;
    }
  }

  private void setStatusOnFanIdle(StatusOnFanIdle aStatusOnFanIdle)
  {
    statusOnFanIdle = aStatusOnFanIdle;
    if (status != Status.On && aStatusOnFanIdle != StatusOnFanIdle.Null) { setStatus(Status.On); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../EmptyAndNonEmptyStates.ump"
public class Light
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Light State Machines
  public enum Status { On, Off }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Light()
  {
    setStatus(Status.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case On:
        setStatus(Status.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "pooledStateMachine_timedEvents_and_autoTansitions.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2, s3 }
  private Sm sm;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { timeouts2Tos3_M, null_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.timeouts2Tos3_M)));
    stateMessageMap.put(Sm.s3,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
  }

  //Helper Variables
  private TimedEventHandler timeouts2Tos3Handler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _timeouts2Tos3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        exitSm();
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s2:
        stopTimeouts2Tos3Handler();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        __autotransition1__();
        break;
      case s2:
        startTimeouts2Tos3Handler();
        break;
    }
  }

  private void startTimeouts2Tos3Handler()
  {
    timeouts2Tos3Handler = new TimedEventHandler(this,"timeouts2Tos3",10);
  }

  private void stopTimeouts2Tos3Handler()
  {
    timeouts2Tos3Handler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private X controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(X aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeouts2Tos3".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts2Tos3();
        if (shouldRestart)
        {
          controller.startTimeouts2Tos3Handler();
        }
        return;
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public boolean timeouts2Tos3 ()
  {
    boolean wasAdded = false;
    pool.put(new Message(MessageType.timeouts2Tos3_M, null));
    wasAdded = true;
    return wasAdded;
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case timeouts2Tos3_M:
          status = _timeouts2Tos3();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedSM_UnspecifiedRecep.ump"
public class AutomatedTellerMachine implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //AutomatedTellerMachine State Machines
  public enum Sm { idle, maintenance, active, error1, error2 }
  public enum SmActive { Null, validating, selecting, processing, printing }
  private Sm sm;
  private SmActive smActive;
  
  //enumeration type of messages accepted by AutomatedTellerMachine
  protected enum MessageType { cardInserted_M, maintain_M, isMaintained_M, cancel_M, validated_M, select_M, selectAnotherTransiction_M, finish_M, receiptPrinted_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public AutomatedTellerMachine()
  {
    setSmActive(SmActive.Null);
    setSm(Sm.idle);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of AutomatedTellerMachine
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smActive != SmActive.Null) { answer += "." + smActive.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmActive getSmActive()
  {
    return smActive;
  }

  public boolean _cardInserted()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case idle:
        setSm(Sm.active);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
        wasEventProcessed = unspecified(getSm().toString(), "cardInserted");
    }

    return wasEventProcessed;
  }

  public boolean _maintain()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case idle:
        setSm(Sm.maintenance);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
        wasEventProcessed = unspecified(getSm().toString(), "maintain");
    }

    return wasEventProcessed;
  }

  public boolean unspecified(String state, String event)
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    SmActive aSmActive = smActive;
    switch (aSm)
    {
      case idle:
        setSm(Sm.error1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSmActive)
    {
      case validating:
        exitSm();
        setSm(Sm.error2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _isMaintained()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case maintenance:
        setSm(Sm.idle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _cancel()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case active:
        exitSm();
        setSm(Sm.idle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case error1:
        setSm(Sm.idle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private boolean __autotransition2__()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case error2:
        setSmActive(SmActive.validating);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _validated()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case validating:
        exitSmActive();
        setSmActive(SmActive.selecting);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
        wasEventProcessed = unspecified(getSmActive().toString(), "validated");
    }

    return wasEventProcessed;
  }

  public boolean _select()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case selecting:
        exitSmActive();
        setSmActive(SmActive.processing);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _selectAnotherTransiction()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case processing:
        exitSmActive();
        setSmActive(SmActive.selecting);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _finish()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case processing:
        exitSmActive();
        setSmActive(SmActive.printing);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _receiptPrinted()
  {
    boolean wasEventProcessed = false;
    
    SmActive aSmActive = smActive;
    switch (aSmActive)
    {
      case printing:
        exitSm();
        setSm(Sm.idle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case active:
        exitSmActive();
        // line 19 "../queuedSM_UnspecifiedRecep.ump"
        ejectCard();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case active:
        // line 18 "../queuedSM_UnspecifiedRecep.ump"
        readCard();
        if (smActive == SmActive.Null) { setSmActive(SmActive.validating); }
        break;
      case error1:
        __autotransition1__();
        break;
      case error2:
        __autotransition2__();
        break;
    }
  }

  private void exitSmActive()
  {
    switch(smActive)
    {
      case validating:
        setSmActive(SmActive.Null);
        break;
      case selecting:
        setSmActive(SmActive.Null);
        break;
      case processing:
        setSmActive(SmActive.Null);
        break;
      case printing:
        setSmActive(SmActive.Null);
        break;
    }
  }

  private void setSmActive(SmActive aSmActive)
  {
    smActive = aSmActive;
    if (sm != Sm.active && aSmActive != SmActive.Null) { setSm(Sm.active); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void cardInserted ()
  {
    queue.put(new Message(MessageType.cardInserted_M, null));
  }

  public void maintain ()
  {
    queue.put(new Message(MessageType.maintain_M, null));
  }

  public void isMaintained ()
  {
    queue.put(new Message(MessageType.isMaintained_M, null));
  }

  public void cancel ()
  {
    queue.put(new Message(MessageType.cancel_M, null));
  }

  public void validated ()
  {
    queue.put(new Message(MessageType.validated_M, null));
  }

  public void select ()
  {
    queue.put(new Message(MessageType.select_M, null));
  }

  public void selectAnotherTransiction ()
  {
    queue.put(new Message(MessageType.selectAnotherTransiction_M, null));
  }

  public void finish ()
  {
    queue.put(new Message(MessageType.finish_M, null));
  }

  public void receiptPrinted ()
  {
    queue.put(new Message(MessageType.receiptPrinted_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case cardInserted_M:
          status = _cardInserted();
          break;
        case maintain_M:
          status = _maintain();
          break;
        case isMaintained_M:
          status = _isMaintained();
          break;
        case cancel_M:
          status = _cancel();
          break;
        case validated_M:
          status = _validated();
          break;
        case select_M:
          status = _select();
          break;
        case selectAnotherTransiction_M:
          status = _selectAnotherTransiction();
          break;
        case finish_M:
          status = _finish();
          break;
        case receiptPrinted_M:
          status = _receiptPrinted();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../doActivityNestedStateMachine.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open }
  public enum StatusOpen { Null, statusOpen }
  private Status status;
  private StatusOpen statusOpen;

  //Course Do Activity Threads
  Thread doActivityStatusOpenStatusOpenThread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatusOpen(StatusOpen.Null);
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    if (statusOpen != StatusOpen.Null) { answer += "." + statusOpen.toString(); }
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public StatusOpen getStatusOpen()
  {
    return statusOpen;
  }

  private void exitStatus()
  {
    switch(status)
    {
      case Open:
        exitStatusOpen();
        break;
    }
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case Open:
        if (statusOpen == StatusOpen.Null) { setStatusOpen(StatusOpen.statusOpen); }
        break;
    }
  }

  private void exitStatusOpen()
  {
    switch(statusOpen)
    {
      case statusOpen:
        if (doActivityStatusOpenStatusOpenThread != null) { doActivityStatusOpenStatusOpenThread.interrupt(); }
        setStatusOpen(StatusOpen.Null);
        break;
    }
  }

  private void setStatusOpen(StatusOpen aStatusOpen)
  {
    statusOpen = aStatusOpen;
    if (status != Status.Open && aStatusOpen != StatusOpen.Null) { setStatus(Status.Open); }

    // entry actions and do activities
    switch(statusOpen)
    {
      case statusOpen:
        doActivityStatusOpenStatusOpenThread = new DoActivityThread(this,"doActivityStatusOpenStatusOpen");
        break;
    }
  }

  private void doActivityStatusOpenStatusOpen()
  {
    try
    {
      // line 7 "../doActivityNestedStateMachine.ump"
      keepGoing();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    Course controller;
    String doActivityMethodName;
    
    public DoActivityThread(Course aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivityStatusOpenStatusOpen".equals(doActivityMethodName))
      {
        controller.doActivityStatusOpenStatusOpen();
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "stateMachine_unSpecifiedReception_QSM.ump"
public class QSMwithUnspecifiedRecep implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //QSMwithUnspecifiedRecep State Machines
  public enum Sm { s1, s2, error1, error2 }
  private Sm sm;
  
  //enumeration type of messages accepted by QSMwithUnspecifiedRecep
  protected enum MessageType { e1_M, e2_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public QSMwithUnspecifiedRecep()
  {
    setSm(Sm.s1);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of QSMwithUnspecifiedRecep
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
        wasEventProcessed = unspecified(getSm().toString(), "e1");
    }

    return wasEventProcessed;
  }

  public boolean unspecified(String state, String event)
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        // line 5 "stateMachine_unSpecifiedReception_QSM.ump"
        printError();
        setSm(Sm.error1);
        wasEventProcessed = true;
        break;
      case s2:
        setSm(Sm.error2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
        wasEventProcessed = unspecified(getSm().toString(), "e2");
    }

    return wasEventProcessed;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case error1:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private boolean __autotransition2__()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case error2:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case error1:
        __autotransition1__();
        break;
      case error2:
        __autotransition2__();
        break;
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    queue.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    queue.put(new Message(MessageType.e2_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
  // line 21 "stateMachine_unSpecifiedReception_QSM.ump"
  public void printError(){
    System.out.println("Unspecified Reception");
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../capitalizedStateMachineAttribute.ump"
public class Garage
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Garage State Machines
  public enum GarageDoor {  }
  private GarageDoor garageDoor;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Garage()
  {}

  //------------------------
  // INTERFACE
  //------------------------

  public String getGarageDoorFullName()
  {
    String answer = garageDoor.toString();
    return answer;
  }

  public GarageDoor getGarageDoor()
  {
    return garageDoor;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "stateMachineWithStringComparisonGuard.ump"
public class stateMachineWithStringComparisonGuard
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //stateMachineWithStringComparisonGuard Attributes
  private String cmdString;

  //stateMachineWithStringComparisonGuard State Machines
  public enum CommandControl { IDLE, CHECK_AVAILABILITY, COMMAND_VALIDITY, EXECUTION }
  private CommandControl commandControl;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public stateMachineWithStringComparisonGuard()
  {
    cmdString = "";
    setCommandControl(CommandControl.IDLE);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setCmdString(String aCmdString)
  {
    boolean wasSet = false;
    cmdString = aCmdString;
    wasSet = true;
    return wasSet;
  }

  public String getCmdString()
  {
    return cmdString;
  }

  public String getCommandControlFullName()
  {
    String answer = commandControl.toString();
    return answer;
  }

  public CommandControl getCommandControl()
  {
    return commandControl;
  }

  public boolean execute()
  {
    boolean wasEventProcessed = false;
    
    CommandControl aCommandControl = commandControl;
    switch (aCommandControl)
    {
      case IDLE:
        setCommandControl(CommandControl.CHECK_AVAILABILITY);
        wasEventProcessed = true;
        break;
      case CHECK_AVAILABILITY:
        if (!"".equals(getCmdString()))
        {
          setCommandControl(CommandControl.COMMAND_VALIDITY);
          wasEventProcessed = true;
          break;
        }
        break;
      case COMMAND_VALIDITY:
        if (isCommandValid(getCmdString()))
        {
          setCommandControl(CommandControl.EXECUTION);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setCommandControl(CommandControl aCommandControl)
  {
    commandControl = aCommandControl;
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "cmdString" + ":" + getCmdString()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 19 "../doActivity.ump"
public class Lamp
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Lamp State Machines
  public enum Status { On, Off }
  private Status status;

  //Lamp Do Activity Threads
  Thread doActivityStatusOnThread = null;
  Thread doActivityStatusOffThread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Lamp()
  {
    setStatus(Status.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean press()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case On:
        exitStatus();
        setStatus(Status.Off);
        wasEventProcessed = true;
        break;
      case Off:
        exitStatus();
        setStatus(Status.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitStatus()
  {
    switch(status)
    {
      case On:
        if (doActivityStatusOnThread != null) { doActivityStatusOnThread.interrupt(); }
        break;
      case Off:
        if (doActivityStatusOffThread != null) { doActivityStatusOffThread.interrupt(); }
        break;
    }
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case On:
        doActivityStatusOnThread = new DoActivityThread(this,"doActivityStatusOn");
        break;
      case Off:
        doActivityStatusOffThread = new DoActivityThread(this,"doActivityStatusOff");
        break;
    }
  }

  private void doActivityStatusOn()
  {
    try
    {
      // line 26 "../doActivity.ump"
      alsoDo();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private void doActivityStatusOff()
  {
    try
    {
      // line 32 "../doActivity.ump"
      keepDoing();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    Lamp controller;
    String doActivityMethodName;
    
    public DoActivityThread(Lamp aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivityStatusOn".equals(doActivityMethodName))
      {
        controller.doActivityStatusOn();
      }
        else if ("doActivityStatusOff".equals(doActivityMethodName))
      {
        controller.doActivityStatusOff();
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/
package example;
// line 2 "../queuedStateMachine_implementsInterface.ump"
public interface IX
{
  
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 4 "../queuedStateMachine_implementsInterface.ump"
public class X implements IX, Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1 }
  private Sm sm;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean _e()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e ()
  {
    queue.put(new Message(MessageType.e_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e_M:
          status = _e();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "multiplePooledStateMachine_nestedStates.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS1 { Null, s1a, s1b }
  private Sm sm;
  private SmS1 smS1;
  public enum Sm1 { s3, s4 }
  public enum Sm1S4 { Null, s4a, s4b }
  private Sm1 sm1;
  private Sm1S4 sm1S4;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e2_M, e5_M, e6_M, null_M, e3_M, e4_M, e7_M, e8_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.e1_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.e2_M)));
    stateMessageMap.put(SmS1.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(SmS1.s1a,new HashSet<MessageType>(Arrays.asList(MessageType.e5_M)));
    stateMessageMap.put(SmS1.s1b,new HashSet<MessageType>(Arrays.asList(MessageType.e6_M)));
    stateMessageMap.put(Sm1.s3,new HashSet<MessageType>(Arrays.asList(MessageType.e3_M)));
    stateMessageMap.put(Sm1.s4,new HashSet<MessageType>(Arrays.asList(MessageType.e4_M)));
    stateMessageMap.put(Sm1S4.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(Sm1S4.s4a,new HashSet<MessageType>(Arrays.asList(MessageType.e7_M)));
    stateMessageMap.put(Sm1S4.s4b,new HashSet<MessageType>(Arrays.asList(MessageType.e8_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSm(Sm.s1);
    setSm1S4(Sm1S4.Null);
    setSm1(Sm1.s3);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    return answer;
  }

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    if (sm1S4 != Sm1S4.Null) { answer += "." + sm1S4.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public Sm1S4 getSm1S4()
  {
    return sm1S4;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSmS1();
        setSmS1(SmS1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s3:
        setSm1(Sm1.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e4()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s4:
        exitSm1S4();
        setSm1S4(Sm1S4.s4a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e5()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1a:
        exitSmS1();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e6()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1b:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e7()
  {
    boolean wasEventProcessed = false;
    
    Sm1S4 aSm1S4 = sm1S4;
    switch (aSm1S4)
    {
      case s4a:
        exitSm1S4();
        setSm1S4(Sm1S4.s4b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e8()
  {
    boolean wasEventProcessed = false;
    
    Sm1S4 aSm1S4 = sm1S4;
    switch (aSm1S4)
    {
      case s4b:
        exitSm1();
        setSm1(Sm1.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s1a); }
        break;
    }
  }

  private void exitSm1()
  {
    switch(sm1)
    {
      case s4:
        exitSm1S4();
        break;
    }
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;

    // entry actions and do activities
    switch(sm1)
    {
      case s4:
        if (sm1S4 == Sm1S4.Null) { setSm1S4(Sm1S4.s4a); }
        break;
    }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s1a:
        setSmS1(SmS1.Null);
        break;
      case s1b:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }
  }

  private void exitSm1S4()
  {
    switch(sm1S4)
    {
      case s4a:
        setSm1S4(Sm1S4.Null);
        break;
      case s4b:
        setSm1S4(Sm1S4.Null);
        break;
    }
  }

  private void setSm1S4(Sm1S4 aSm1S4)
  {
    sm1S4 = aSm1S4;
    if (sm1 != Sm1.s4 && aSm1S4 != Sm1S4.Null) { setSm1(Sm1.s4); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSmS1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        if(stateMessageMap.get(getSm1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSm1S4()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    pool.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    pool.put(new Message(MessageType.e2_M, null));
  }

  public void e5 ()
  {
    pool.put(new Message(MessageType.e5_M, null));
  }

  public void e6 ()
  {
    pool.put(new Message(MessageType.e6_M, null));
  }

  public void e3 ()
  {
    pool.put(new Message(MessageType.e3_M, null));
  }

  public void e4 ()
  {
    pool.put(new Message(MessageType.e4_M, null));
  }

  public void e7 ()
  {
    pool.put(new Message(MessageType.e7_M, null));
  }

  public void e8 ()
  {
    pool.put(new Message(MessageType.e8_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e5_M:
          status = _e5();
          break;
        case e6_M:
          status = _e6();
          break;
        case e3_M:
          status = _e3();
          break;
        case e4_M:
          status = _e4();
          break;
        case e7_M:
          status = _e7();
          break;
        case e8_M:
          status = _e8();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedWithNestedStateMachines.ump"
public class QueuedWithNestedStateMachines implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //QueuedWithNestedStateMachines State Machines
  public enum Sm { s1, s2 }
  public enum SmS2 { Null, s2a, s2b }
  private Sm sm;
  private SmS2 smS2;
  
  //enumeration type of messages accepted by QueuedWithNestedStateMachines
  protected enum MessageType { e1_M, e2_M, e3_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public QueuedWithNestedStateMachines()
  {
    setSmS2(SmS2.Null);
    setSm(Sm.s1);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of QueuedWithNestedStateMachines
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS2 != SmS2.Null) { answer += "." + smS2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS2 getSmS2()
  {
    return smS2;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2a:
        exitSmS2();
        setSmS2(SmS2.s2b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2b:
        exitSmS2();
        setSmS2(SmS2.s2a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s2:
        exitSmS2();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s2:
        if (smS2 == SmS2.Null) { setSmS2(SmS2.s2a); }
        break;
    }
  }

  private void exitSmS2()
  {
    switch(smS2)
    {
      case s2a:
        setSmS2(SmS2.Null);
        break;
      case s2b:
        setSmS2(SmS2.Null);
        break;
    }
  }

  private void setSmS2(SmS2 aSmS2)
  {
    smS2 = aSmS2;
    if (sm != Sm.s2 && aSmS2 != SmS2.Null) { setSm(Sm.s2); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    queue.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    queue.put(new Message(MessageType.e2_M, null));
  }

  public void e3 ()
  {
    queue.put(new Message(MessageType.e3_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e3_M:
          status = _e3();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "checkExternalTransitions_withExitActions_1.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { on, off }
  public enum SmOn { Null, s1, s2 }
  public enum SmOnS1 { Null, m1, m2 }
  private Sm sm;
  private SmOn smOn;
  private SmOnS1 smOnS1;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmOn(SmOn.Null);
    setSmOnS1(SmOnS1.Null);
    setSm(Sm.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smOn != SmOn.Null) { answer += "." + smOn.toString(); }
    if (smOnS1 != SmOnS1.Null) { answer += "." + smOnS1.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmOn getSmOn()
  {
    return smOn;
  }

  public SmOnS1 getSmOnS1()
  {
    return smOnS1;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case on:
        exitSm();
        setSm(Sm.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case on:
        exitSm();
        setSm(Sm.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e3()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSmOn();
        setSmOn(SmOn.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e4()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSmOn();
        setSmOn(SmOn.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e5()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSm();
        setSm(Sm.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e6()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSm();
        setSm(Sm.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e7()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOnS1();
        setSmOnS1(SmOnS1.m2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e8()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOnS1();
        setSmOnS1(SmOnS1.m1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e9()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOn();
        setSmOn(SmOn.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e10()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOn();
        setSmOn(SmOn.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e11()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSm();
        setSm(Sm.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e12()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSm();
        setSm(Sm.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case on:
        exitSmOn();
        // line 4 "checkExternalTransitions_withExitActions_1.ump"
        on_exit_action();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case on:
        if (smOn == SmOn.Null) { setSmOn(SmOn.s1); }
        break;
    }
  }

  private void exitSmOn()
  {
    switch(smOn)
    {
      case s1:
        exitSmOnS1();
        // line 8 "checkExternalTransitions_withExitActions_1.ump"
        s1_exit_action();
        setSmOn(SmOn.Null);
        break;
      case s2:
        setSmOn(SmOn.Null);
        break;
    }
  }

  private void setSmOn(SmOn aSmOn)
  {
    smOn = aSmOn;
    if (sm != Sm.on && aSmOn != SmOn.Null) { setSm(Sm.on); }

    // entry actions and do activities
    switch(smOn)
    {
      case s1:
        if (smOnS1 == SmOnS1.Null) { setSmOnS1(SmOnS1.m1); }
        break;
    }
  }

  private void exitSmOnS1()
  {
    switch(smOnS1)
    {
      case m1:
        // line 14 "checkExternalTransitions_withExitActions_1.ump"
        m1_exit_action();
        setSmOnS1(SmOnS1.Null);
        break;
      case m2:
        setSmOnS1(SmOnS1.Null);
        break;
    }
  }

  private void setSmOnS1(SmOnS1 aSmOnS1)
  {
    smOnS1 = aSmOnS1;
    if (smOn != SmOn.s1 && aSmOnS1 != SmOnS1.Null) { setSmOn(SmOn.s1); }
  }

  public void delete()
  {}

  // line 28 "checkExternalTransitions_withExitActions_1.ump"
  public void on_exit_action(){
    System.out.println("exited on");
  }

  // line 29 "checkExternalTransitions_withExitActions_1.ump"
  public void s1_exit_action(){
    System.out.println("exited s1");
  }

  // line 30 "checkExternalTransitions_withExitActions_1.ump"
  public void m1_exit_action(){
    System.out.println("exited m1");
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "checkExternalTransitions_withExitActions_2.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { on, off }
  public enum SmOn { Null, m1, m2 }
  public enum SmOnM1 { Null, t2, t3 }
  private Sm sm;
  private SmOn smOn;
  private SmOnM1 smOnM1;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmOn(SmOn.Null);
    setSmOnM1(SmOnM1.Null);
    setSm(Sm.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smOn != SmOn.Null) { answer += "." + smOn.toString(); }
    if (smOnM1 != SmOnM1.Null) { answer += "." + smOnM1.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmOn getSmOn()
  {
    return smOn;
  }

  public SmOnM1 getSmOnM1()
  {
    return smOnM1;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case on:
        exitSm();
        setSm(Sm.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case m1:
        exitSmOn();
        setSmOn(SmOn.m2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e3()
  {
    boolean wasEventProcessed = false;
    
    SmOnM1 aSmOnM1 = smOnM1;
    switch (aSmOnM1)
    {
      case t2:
        exitSmOnM1();
        setSmOnM1(SmOnM1.t3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case on:
        exitSmOn();
        // line 4 "checkExternalTransitions_withExitActions_2.ump"
        on_exit_action();
        break;
      case off:
        // line 18 "checkExternalTransitions_withExitActions_2.ump"
        off_exit_action();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case on:
        if (smOn == SmOn.Null) { setSmOn(SmOn.m1); }
        break;
    }
  }

  private void exitSmOn()
  {
    switch(smOn)
    {
      case m1:
        exitSmOnM1();
        // line 7 "checkExternalTransitions_withExitActions_2.ump"
        m1_exit_action();
        setSmOn(SmOn.Null);
        break;
      case m2:
        setSmOn(SmOn.Null);
        break;
    }
  }

  private void setSmOn(SmOn aSmOn)
  {
    smOn = aSmOn;
    if (sm != Sm.on && aSmOn != SmOn.Null) { setSm(Sm.on); }

    // entry actions and do activities
    switch(smOn)
    {
      case m1:
        if (smOnM1 == SmOnM1.Null) { setSmOnM1(SmOnM1.t2); }
        break;
    }
  }

  private void exitSmOnM1()
  {
    switch(smOnM1)
    {
      case t2:
        // line 10 "checkExternalTransitions_withExitActions_2.ump"
        t2_exit_action();
        setSmOnM1(SmOnM1.Null);
        break;
      case t3:
        setSmOnM1(SmOnM1.Null);
        break;
    }
  }

  private void setSmOnM1(SmOnM1 aSmOnM1)
  {
    smOnM1 = aSmOnM1;
    if (smOn != SmOn.m1 && aSmOnM1 != SmOnM1.Null) { setSmOn(SmOn.m1); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../guardNegSymbolSpacing.ump"
public class Agent
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Agent State Machines
  public enum Status { follow, changing_lane, final }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Agent()
  {
    setStatus(Status.follow);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean change_lane()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case follow:
        setStatus(Status.changing_lane);
        wasEventProcessed = true;
        break;
      case changing_lane:
        if (not_achieved.equals(False))
        {
          setStatus(Status.changing_lane);
          wasEventProcessed = true;
          break;
        }
        if (not_achieved.equals(True))
        {
          setStatus(Status.final);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "parallelSm_sameNameDiffStates_2.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1 }
  public enum SmS0T1 { Null, t1 }
  public enum SmS0T2 { Null, t2, t3 }
  public enum SmS1 { Null, s2, s3 }
  public enum SmS1S2T1 { Null, t1, t4 }
  public enum SmS1S2T6 { Null, t6 }
  public enum SmS1S2T2 { Null, t2, t5 }
  public enum SmS1S3T7 { Null, t7, t8 }
  public enum SmS1S3T6 { Null, t6, t9 }
  private Sm sm;
  private SmS0T1 smS0T1;
  private SmS0T2 smS0T2;
  private SmS1 smS1;
  private SmS1S2T1 smS1S2T1;
  private SmS1S2T6 smS1S2T6;
  private SmS1S2T2 smS1S2T2;
  private SmS1S3T7 smS1S3T7;
  private SmS1S3T6 smS1S3T6;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS0T1(SmS0T1.Null);
    setSmS0T2(SmS0T2.Null);
    setSmS1(SmS1.Null);
    setSmS1S2T1(SmS1S2T1.Null);
    setSmS1S2T6(SmS1S2T6.Null);
    setSmS1S2T2(SmS1S2T2.Null);
    setSmS1S3T7(SmS1S3T7.Null);
    setSmS1S3T6(SmS1S3T6.Null);
    setSm(Sm.s0);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS0T1 != SmS0T1.Null) { answer += "." + smS0T1.toString(); }
    if (smS0T2 != SmS0T2.Null) { answer += "." + smS0T2.toString(); }
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    if (smS1S2T1 != SmS1S2T1.Null) { answer += "." + smS1S2T1.toString(); }
    if (smS1S2T6 != SmS1S2T6.Null) { answer += "." + smS1S2T6.toString(); }
    if (smS1S2T2 != SmS1S2T2.Null) { answer += "." + smS1S2T2.toString(); }
    if (smS1S3T7 != SmS1S3T7.Null) { answer += "." + smS1S3T7.toString(); }
    if (smS1S3T6 != SmS1S3T6.Null) { answer += "." + smS1S3T6.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS0T1 getSmS0T1()
  {
    return smS0T1;
  }

  public SmS0T2 getSmS0T2()
  {
    return smS0T2;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public SmS1S2T1 getSmS1S2T1()
  {
    return smS1S2T1;
  }

  public SmS1S2T6 getSmS1S2T6()
  {
    return smS1S2T6;
  }

  public SmS1S2T2 getSmS1S2T2()
  {
    return smS1S2T2;
  }

  public SmS1S3T7 getSmS1S3T7()
  {
    return smS1S3T7;
  }

  public SmS1S3T6 getSmS1S3T6()
  {
    return smS1S3T6;
  }

  public boolean goS1()
  {
    boolean wasEventProcessed = false;
    
    SmS0T1 aSmS0T1 = smS0T1;
    SmS0T2 aSmS0T2 = smS0T2;
    switch (aSmS0T1)
    {
      case t1:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSmS0T2)
    {
      case t2:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT4()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2T1 aSmS1S2T1 = smS1S2T1;
    switch (aSmS1S2T1)
    {
      case t1:
        exitSmS1S2T1();
        setSmS1S2T1(SmS1S2T1.t4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT5()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2T6 aSmS1S2T6 = smS1S2T6;
    SmS1S2T2 aSmS1S2T2 = smS1S2T2;
    switch (aSmS1S2T6)
    {
      case t6:
        exitSmS1S2T6();
        setSmS1S2T2(SmS1S2T2.t5);
        setSmS1S2T6(SmS1S2T6.t6);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSmS1S2T2)
    {
      case t2:
        exitSmS1S2T2();
        setSmS1S2T2(SmS1S2T2.t5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT8()
  {
    boolean wasEventProcessed = false;
    
    SmS1S3T7 aSmS1S3T7 = smS1S3T7;
    switch (aSmS1S3T7)
    {
      case t7:
        exitSmS1S3T7();
        setSmS1S3T7(SmS1S3T7.t8);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT9()
  {
    boolean wasEventProcessed = false;
    
    SmS1S3T6 aSmS1S3T6 = smS1S3T6;
    switch (aSmS1S3T6)
    {
      case t6:
        exitSmS1S3T6();
        setSmS1S3T6(SmS1S3T6.t9);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s0:
        exitSmS0T1();
        exitSmS0T2();
        break;
      case s1:
        exitSmS1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        if (smS0T1 == SmS0T1.Null) { setSmS0T1(SmS0T1.t1); }
        if (smS0T2 == SmS0T2.Null) { setSmS0T2(SmS0T2.t2); }
        break;
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s2); }
        break;
    }
  }

  private void exitSmS0T1()
  {
    switch(smS0T1)
    {
      case t1:
        setSmS0T1(SmS0T1.Null);
        break;
    }
  }

  private void setSmS0T1(SmS0T1 aSmS0T1)
  {
    smS0T1 = aSmS0T1;
    if (sm != Sm.s0 && aSmS0T1 != SmS0T1.Null) { setSm(Sm.s0); }
  }

  private void exitSmS0T2()
  {
    switch(smS0T2)
    {
      case t2:
        setSmS0T2(SmS0T2.Null);
        break;
      case t3:
        setSmS0T2(SmS0T2.Null);
        break;
    }
  }

  private void setSmS0T2(SmS0T2 aSmS0T2)
  {
    smS0T2 = aSmS0T2;
    if (sm != Sm.s0 && aSmS0T2 != SmS0T2.Null) { setSm(Sm.s0); }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s2:
        exitSmS1S2T1();
        exitSmS1S2T6();
        exitSmS1S2T2();
        setSmS1(SmS1.Null);
        break;
      case s3:
        exitSmS1S3T7();
        exitSmS1S3T6();
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1)
    {
      case s2:
        if (smS1S2T1 == SmS1S2T1.Null) { setSmS1S2T1(SmS1S2T1.t1); }
        if (smS1S2T6 == SmS1S2T6.Null) { setSmS1S2T6(SmS1S2T6.t6); }
        if (smS1S2T2 == SmS1S2T2.Null) { setSmS1S2T2(SmS1S2T2.t2); }
        break;
      case s3:
        if (smS1S3T7 == SmS1S3T7.Null) { setSmS1S3T7(SmS1S3T7.t7); }
        if (smS1S3T6 == SmS1S3T6.Null) { setSmS1S3T6(SmS1S3T6.t6); }
        break;
    }
  }

  private void exitSmS1S2T1()
  {
    switch(smS1S2T1)
    {
      case t1:
        setSmS1S2T1(SmS1S2T1.Null);
        break;
      case t4:
        setSmS1S2T1(SmS1S2T1.Null);
        break;
    }
  }

  private void setSmS1S2T1(SmS1S2T1 aSmS1S2T1)
  {
    smS1S2T1 = aSmS1S2T1;
    if (smS1 != SmS1.s2 && aSmS1S2T1 != SmS1S2T1.Null) { setSmS1(SmS1.s2); }
  }

  private void exitSmS1S2T6()
  {
    switch(smS1S2T6)
    {
      case t6:
        setSmS1S2T6(SmS1S2T6.Null);
        break;
    }
  }

  private void setSmS1S2T6(SmS1S2T6 aSmS1S2T6)
  {
    smS1S2T6 = aSmS1S2T6;
    if (smS1 != SmS1.s2 && aSmS1S2T6 != SmS1S2T6.Null) { setSmS1(SmS1.s2); }
  }

  private void exitSmS1S2T2()
  {
    switch(smS1S2T2)
    {
      case t2:
        setSmS1S2T2(SmS1S2T2.Null);
        break;
      case t5:
        setSmS1S2T2(SmS1S2T2.Null);
        break;
    }
  }

  private void setSmS1S2T2(SmS1S2T2 aSmS1S2T2)
  {
    smS1S2T2 = aSmS1S2T2;
    if (smS1 != SmS1.s2 && aSmS1S2T2 != SmS1S2T2.Null) { setSmS1(SmS1.s2); }
  }

  private void exitSmS1S3T7()
  {
    switch(smS1S3T7)
    {
      case t7:
        setSmS1S3T7(SmS1S3T7.Null);
        break;
      case t8:
        setSmS1S3T7(SmS1S3T7.Null);
        break;
    }
  }

  private void setSmS1S3T7(SmS1S3T7 aSmS1S3T7)
  {
    smS1S3T7 = aSmS1S3T7;
    if (smS1 != SmS1.s3 && aSmS1S3T7 != SmS1S3T7.Null) { setSmS1(SmS1.s3); }
  }

  private void exitSmS1S3T6()
  {
    switch(smS1S3T6)
    {
      case t6:
        setSmS1S3T6(SmS1S3T6.Null);
        break;
      case t9:
        setSmS1S3T6(SmS1S3T6.Null);
        break;
    }
  }

  private void setSmS1S3T6(SmS1S3T6 aSmS1S3T6)
  {
    smS1S3T6 = aSmS1S3T6;
    if (smS1 != SmS1.s3 && aSmS1S3T6 != SmS1S3T6.Null) { setSmS1(SmS1.s3); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 13 "../EventTransitionSpacing.ump"
public class Light
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Light State Machines
  public enum Bulb { Off, On }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Light()
  {
    setBulb(Bulb.Off);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      case On:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "checkExternalTransitions_concurrentStateMachines_2.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s4 }
  public enum SmS1S2 { Null, s2 }
  public enum SmS1S2A { Null, a }
  public enum SmS1S2AA { Null, t1, t2 }
  public enum SmS1S2B { Null, b }
  public enum SmS1S2BB { Null, t3, t4 }
  public enum SmS1S3 { Null, s3 }
  public enum SmS1S3S3 { Null, t5, t6 }
  private Sm sm;
  private SmS1S2 smS1S2;
  private SmS1S2A smS1S2A;
  private SmS1S2AA smS1S2AA;
  private SmS1S2B smS1S2B;
  private SmS1S2BB smS1S2BB;
  private SmS1S3 smS1S3;
  private SmS1S3S3 smS1S3S3;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1S2(SmS1S2.Null);
    setSmS1S2A(SmS1S2A.Null);
    setSmS1S2AA(SmS1S2AA.Null);
    setSmS1S2B(SmS1S2B.Null);
    setSmS1S2BB(SmS1S2BB.Null);
    setSmS1S3(SmS1S3.Null);
    setSmS1S3S3(SmS1S3S3.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1S2 != SmS1S2.Null) { answer += "." + smS1S2.toString(); }
    if (smS1S2A != SmS1S2A.Null) { answer += "." + smS1S2A.toString(); }
    if (smS1S2AA != SmS1S2AA.Null) { answer += "." + smS1S2AA.toString(); }
    if (smS1S2B != SmS1S2B.Null) { answer += "." + smS1S2B.toString(); }
    if (smS1S2BB != SmS1S2BB.Null) { answer += "." + smS1S2BB.toString(); }
    if (smS1S3 != SmS1S3.Null) { answer += "." + smS1S3.toString(); }
    if (smS1S3S3 != SmS1S3S3.Null) { answer += "." + smS1S3S3.toString(); }
    if (smS1S2AA != SmS1S2AA.Null) { answer += "." + smS1S2AA.toString(); }
    if (smS1S2BB != SmS1S2BB.Null) { answer += "." + smS1S2BB.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1S2 getSmS1S2()
  {
    return smS1S2;
  }

  public SmS1S2A getSmS1S2A()
  {
    return smS1S2A;
  }

  public SmS1S2AA getSmS1S2AA()
  {
    return smS1S2AA;
  }

  public SmS1S2B getSmS1S2B()
  {
    return smS1S2B;
  }

  public SmS1S2BB getSmS1S2BB()
  {
    return smS1S2BB;
  }

  public SmS1S3 getSmS1S3()
  {
    return smS1S3;
  }

  public SmS1S3S3 getSmS1S3S3()
  {
    return smS1S3S3;
  }

  public boolean goToT2()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2AA aSmS1S2AA = smS1S2AA;
    switch (aSmS1S2AA)
    {
      case t1:
        exitSmS1S2AA();
        setSmS1S2AA(SmS1S2AA.t2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToT4()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2AA aSmS1S2AA = smS1S2AA;
    switch (aSmS1S2AA)
    {
      case t2:
        exitSmS1S2();
        setSmS1S2BB(SmS1S2BB.t4);
        setSmS1S2A(SmS1S2A.a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToT5()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2BB aSmS1S2BB = smS1S2BB;
    switch (aSmS1S2BB)
    {
      case t3:
        exitSmS1S2();
        setSmS1S3S3(SmS1S3S3.t5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToS4()
  {
    boolean wasEventProcessed = false;
    
    SmS1S2BB aSmS1S2BB = smS1S2BB;
    switch (aSmS1S2BB)
    {
      case t4:
        exitSm();
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToT6()
  {
    boolean wasEventProcessed = false;
    
    SmS1S3S3 aSmS1S3S3 = smS1S3S3;
    switch (aSmS1S3S3)
    {
      case t5:
        exitSmS1S3S3();
        setSmS1S3S3(SmS1S3S3.t6);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToAT2()
  {
    boolean wasEventProcessed = false;
    
    SmS1S3S3 aSmS1S3S3 = smS1S3S3;
    switch (aSmS1S3S3)
    {
      case t6:
        exitSmS1S2();
        setSmS1S2AA(SmS1S2AA.t2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1S2();
        exitSmS1S3();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1S2 == SmS1S2.Null) { setSmS1S2(SmS1S2.s2); }
        if (smS1S3 == SmS1S3.Null) { setSmS1S3(SmS1S3.s3); }
        break;
    }
  }

  private void exitSmS1S2()
  {
    switch(smS1S2)
    {
      case s2:
        exitSmS1S2A();
        exitSmS1S2B();
        setSmS1S2(SmS1S2.Null);
        break;
    }
  }

  private void setSmS1S2(SmS1S2 aSmS1S2)
  {
    smS1S2 = aSmS1S2;
    if (sm != Sm.s1 && aSmS1S2 != SmS1S2.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1S2)
    {
      case s2:
        if (smS1S2A == SmS1S2A.Null) { setSmS1S2A(SmS1S2A.a); }
        if (smS1S2B == SmS1S2B.Null) { setSmS1S2B(SmS1S2B.b); }
        break;
    }
  }

  private void exitSmS1S2A()
  {
    switch(smS1S2A)
    {
      case a:
        exitSmS1S2AA();
        // line 6 "checkExternalTransitions_concurrentStateMachines_2.ump"
        exit_a_action();
        setSmS1S2A(SmS1S2A.Null);
        break;
    }
  }

  private void setSmS1S2A(SmS1S2A aSmS1S2A)
  {
    smS1S2A = aSmS1S2A;
    if (smS1S2 != SmS1S2.s2 && aSmS1S2A != SmS1S2A.Null) { setSmS1S2(SmS1S2.s2); }

    // entry actions and do activities
    switch(smS1S2A)
    {
      case a:
        if (smS1S2AA == SmS1S2AA.Null) { setSmS1S2AA(SmS1S2AA.t1); }
        break;
    }
  }

  private void exitSmS1S2AA()
  {
    switch(smS1S2AA)
    {
      case t1:
        setSmS1S2AA(SmS1S2AA.Null);
        break;
      case t2:
        setSmS1S2AA(SmS1S2AA.Null);
        break;
    }
  }

  private void setSmS1S2AA(SmS1S2AA aSmS1S2AA)
  {
    smS1S2AA = aSmS1S2AA;
    if (smS1S2A != SmS1S2A.a && aSmS1S2AA != SmS1S2AA.Null) { setSmS1S2A(SmS1S2A.a); }
  }

  private void exitSmS1S2B()
  {
    switch(smS1S2B)
    {
      case b:
        exitSmS1S2BB();
        // line 16 "checkExternalTransitions_concurrentStateMachines_2.ump"
        exit_b_action();
        setSmS1S2B(SmS1S2B.Null);
        break;
    }
  }

  private void setSmS1S2B(SmS1S2B aSmS1S2B)
  {
    smS1S2B = aSmS1S2B;
    if (smS1S2 != SmS1S2.s2 && aSmS1S2B != SmS1S2B.Null) { setSmS1S2(SmS1S2.s2); }

    // entry actions and do activities
    switch(smS1S2B)
    {
      case b:
        if (smS1S2BB == SmS1S2BB.Null) { setSmS1S2BB(SmS1S2BB.t3); }
        break;
    }
  }

  private void exitSmS1S2BB()
  {
    switch(smS1S2BB)
    {
      case t3:
        setSmS1S2BB(SmS1S2BB.Null);
        break;
      case t4:
        setSmS1S2BB(SmS1S2BB.Null);
        break;
    }
  }

  private void setSmS1S2BB(SmS1S2BB aSmS1S2BB)
  {
    smS1S2BB = aSmS1S2BB;
    if (smS1S2B != SmS1S2B.b && aSmS1S2BB != SmS1S2BB.Null) { setSmS1S2B(SmS1S2B.b); }
  }

  private void exitSmS1S3()
  {
    switch(smS1S3)
    {
      case s3:
        exitSmS1S3S3();
        setSmS1S3(SmS1S3.Null);
        break;
    }
  }

  private void setSmS1S3(SmS1S3 aSmS1S3)
  {
    smS1S3 = aSmS1S3;
    if (sm != Sm.s1 && aSmS1S3 != SmS1S3.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1S3)
    {
      case s3:
        if (smS1S3S3 == SmS1S3S3.Null) { setSmS1S3S3(SmS1S3S3.t5); }
        break;
    }
  }

  private void exitSmS1S3S3()
  {
    switch(smS1S3S3)
    {
      case t5:
        setSmS1S3S3(SmS1S3S3.Null);
        break;
      case t6:
        setSmS1S3S3(SmS1S3S3.Null);
        break;
    }
  }

  private void setSmS1S3S3(SmS1S3S3 aSmS1S3S3)
  {
    smS1S3S3 = aSmS1S3S3;
    if (smS1S3 != SmS1S3.s3 && aSmS1S3S3 != SmS1S3S3.Null) { setSmS1S3(SmS1S3.s3); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../entryExitActionNoTransitions.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Bulb { On, Off }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setBulb(Bulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  private void exitBulb()
  {
    switch(bulb)
    {
      case On:
        // line 7 "../entryExitActionNoTransitions.ump"
        doExit();
        break;
    }
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case On:
        // line 6 "../entryExitActionNoTransitions.ump"
        doEntry();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../exitAction.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Bulb { On, Off }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setBulb(Bulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean push()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case On:
        exitBulb();
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitBulb()
  {
    switch(bulb)
    {
      case On:
        // line 8 "../exitAction.ump"
        blahblah;
        break;
    }
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "noDefaultEntryMethodGenerated.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { on, off }
  public enum SmOn { Null, s1, s2 }
  public enum SmOnS1 { Null, m1, m2 }
  public enum SmOff { Null, s3, s4 }
  private Sm sm;
  private SmOn smOn;
  private SmOnS1 smOnS1;
  private SmOff smOff;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmOn(SmOn.Null);
    setSmOnS1(SmOnS1.Null);
    setSmOff(SmOff.Null);
    setSm(Sm.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smOn != SmOn.Null) { answer += "." + smOn.toString(); }
    if (smOnS1 != SmOnS1.Null) { answer += "." + smOnS1.toString(); }
    if (smOff != SmOff.Null) { answer += "." + smOff.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmOn getSmOn()
  {
    return smOn;
  }

  public SmOnS1 getSmOnS1()
  {
    return smOnS1;
  }

  public SmOff getSmOff()
  {
    return smOff;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case on:
        exitSm();
        setSm(Sm.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSmOn();
        setSmOn(SmOn.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e3()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSm();
        setSm(Sm.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e4()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOnS1();
        setSmOnS1(SmOnS1.m2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e5()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOn();
        setSmOn(SmOn.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e6()
  {
    boolean wasEventProcessed = false;
    
    SmOff aSmOff = smOff;
    switch (aSmOff)
    {
      case s3:
        exitSmOff();
        setSmOff(SmOff.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case on:
        exitSmOn();
        break;
      case off:
        exitSmOff();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case on:
        // line 4 "noDefaultEntryMethodGenerated.ump"
        on_entry_action();
        if (smOn == SmOn.Null) { setSmOn(SmOn.s1); }
        break;
      case off:
        if (smOff == SmOff.Null) { setSmOff(SmOff.s3); }
        break;
    }
  }

  private void exitSmOn()
  {
    switch(smOn)
    {
      case s1:
        exitSmOnS1();
        setSmOn(SmOn.Null);
        break;
      case s2:
        setSmOn(SmOn.Null);
        break;
    }
  }

  private void setSmOn(SmOn aSmOn)
  {
    smOn = aSmOn;
    if (sm != Sm.on && aSmOn != SmOn.Null) { setSm(Sm.on); }

    // entry actions and do activities
    switch(smOn)
    {
      case s1:
        // line 7 "noDefaultEntryMethodGenerated.ump"
        s1_entry_action();
        if (smOnS1 == SmOnS1.Null) { setSmOnS1(SmOnS1.m1); }
        break;
    }
  }

  private void exitSmOnS1()
  {
    switch(smOnS1)
    {
      case m1:
        setSmOnS1(SmOnS1.Null);
        break;
      case m2:
        setSmOnS1(SmOnS1.Null);
        break;
    }
  }

  private void setSmOnS1(SmOnS1 aSmOnS1)
  {
    smOnS1 = aSmOnS1;
    if (smOn != SmOn.s1 && aSmOnS1 != SmOnS1.Null) { setSmOn(SmOn.s1); }

    // entry actions and do activities
    switch(smOnS1)
    {
      case m1:
        // line 11 "noDefaultEntryMethodGenerated.ump"
        m1_entry_action();
        break;
    }
  }

  private void exitSmOff()
  {
    switch(smOff)
    {
      case s3:
        setSmOff(SmOff.Null);
        break;
      case s4:
        setSmOff(SmOff.Null);
        break;
    }
  }

  private void setSmOff(SmOff aSmOff)
  {
    smOff = aSmOff;
    if (sm != Sm.off && aSmOff != SmOff.Null) { setSm(Sm.off); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "nestedStateMachineExtendedByMultipleClasses.ump"
public class Animal
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Animal Attributes
  private boolean isAlive;

  //Animal State Machines
  public enum State { alive, dead }
  public enum StateAlive { Null, normal, zombie }
  private State state;
  private StateAlive stateAlive;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Animal(boolean aIsAlive)
  {
    isAlive = aIsAlive;
    setStateAlive(StateAlive.Null);
    setState(State.alive);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setIsAlive(boolean aIsAlive)
  {
    boolean wasSet = false;
    isAlive = aIsAlive;
    wasSet = true;
    return wasSet;
  }

  public boolean getIsAlive()
  {
    return isAlive;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isIsAlive()
  {
    return isAlive;
  }

  public String getStateFullName()
  {
    String answer = state.toString();
    if (stateAlive != StateAlive.Null) { answer += "." + stateAlive.toString(); }
    return answer;
  }

  public State getState()
  {
    return state;
  }

  public StateAlive getStateAlive()
  {
    return stateAlive;
  }

  public boolean kill()
  {
    boolean wasEventProcessed = false;
    
    State aState = state;
    switch (aState)
    {
      case alive:
        exitState();
        setState(State.dead);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean zombify()
  {
    boolean wasEventProcessed = false;
    
    StateAlive aStateAlive = stateAlive;
    switch (aStateAlive)
    {
      case normal:
        exitStateAlive();
        setStateAlive(StateAlive.zombie);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean haveBaby()
  {
    boolean wasEventProcessed = false;
    
    StateAlive aStateAlive = stateAlive;
    switch (aStateAlive)
    {
      case zombie:
        exitStateAlive();
        setStateAlive(StateAlive.normal);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitState()
  {
    switch(state)
    {
      case alive:
        exitStateAlive();
        break;
    }
  }

  private void setState(State aState)
  {
    state = aState;

    // entry actions and do activities
    switch(state)
    {
      case alive:
        if (stateAlive == StateAlive.Null) { setStateAlive(StateAlive.normal); }
        break;
    }
  }

  private void exitStateAlive()
  {
    switch(stateAlive)
    {
      case normal:
        setStateAlive(StateAlive.Null);
        break;
      case zombie:
        setStateAlive(StateAlive.Null);
        break;
    }
  }

  private void setStateAlive(StateAlive aStateAlive)
  {
    stateAlive = aStateAlive;
    if (state != State.alive && aStateAlive != StateAlive.Null) { setState(State.alive); }
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "isAlive" + ":" + getIsAlive()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "eventWithArguments_1.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture Attributes
  private int brightness;

  //LightFixture State Machines
  public enum Bulb { Off, Dimmed, On }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    brightness = 0;
    setBulb(Bulb.Off);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setBrightness(int aBrightness)
  {
    boolean wasSet = false;
    brightness = aBrightness;
    wasSet = true;
    return wasSet;
  }

  public int getBrightness()
  {
    return brightness;
  }

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean turnDimmer(Integer lightval,Double lightval_1)
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        // line 6 "eventWithArguments_1.ump"
        setBrightness(lightval)
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case Dimmed:
        // line 12 "eventWithArguments_1.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case On:
        // line 16 "eventWithArguments_1.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean flipSwitch()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case Dimmed:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case On:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean entry()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Dimmed:
        if (dimmer>99)
        {
          setBulb(Bulb.On);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "brightness" + ":" + getBrightness()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../eventWithArguments_2.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean register(String name,Integer age,Double grades)
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.Open);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 4 "../SimpleStateMachineSpacing.ump"
public class Mentor
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Mentor State Machines
  public enum Status {  }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Mentor()
  {}

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedStateMachine_2.ump"
public class GarageDoor implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //GarageDoor State Machines
  public enum Status { Open, Closing, Closed, Opening, HalfOpen }
  private Status status;
  
  //enumeration type of messages accepted by GarageDoor
  protected enum MessageType { buttonOrObstacle_M, reachBottom_M, reachTop_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public GarageDoor()
  {
    setStatus(Status.Open);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of GarageDoor
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean _buttonOrObstacle()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.Closing);
        wasEventProcessed = true;
        break;
      case Closing:
        setStatus(Status.Opening);
        wasEventProcessed = true;
        break;
      case Closed:
        setStatus(Status.Opening);
        wasEventProcessed = true;
        break;
      case Opening:
        setStatus(Status.HalfOpen);
        wasEventProcessed = true;
        break;
      case HalfOpen:
        setStatus(Status.Opening);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _reachBottom()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Closing:
        setStatus(Status.Closed);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _reachTop()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Opening:
        setStatus(Status.Open);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void buttonOrObstacle ()
  {
    queue.put(new Message(MessageType.buttonOrObstacle_M, null));
  }

  public void reachBottom ()
  {
    queue.put(new Message(MessageType.reachBottom_M, null));
  }

  public void reachTop ()
  {
    queue.put(new Message(MessageType.reachTop_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case buttonOrObstacle_M:
          status = _buttonOrObstacle();
          break;
        case reachBottom_M:
          status = _reachBottom();
          break;
        case reachTop_M:
          status = _reachTop();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;

// line 1 "nestedStates_Two_TimedTransition.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS1 { Null, s1a, s1b }
  public enum SmS2 { Null, s2a, s2b }
  private Sm sm;
  private SmS1 smS1;
  private SmS2 smS2;

  //Helper Variables
  private TimedEventHandler timeouts1aTos1bHandler;
  private TimedEventHandler timeouts2bTos1bHandler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSmS2(SmS2.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    if (smS2 != SmS2.Null) { answer += "." + smS2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public SmS2 getSmS2()
  {
    return smS2;
  }

  public boolean timeouts1aTos1b()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1a:
        exitSmS1();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1b:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2a:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean timeouts2bTos1b()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2b:
        exitSm();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
      case s2:
        exitSmS2();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s1a); }
        break;
      case s2:
        if (smS2 == SmS2.Null) { setSmS2(SmS2.s2a); }
        break;
    }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s1a:
        setSmS1(SmS1.Null);
        stopTimeouts1aTos1bHandler();
        break;
      case s1b:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1)
    {
      case s1a:
        startTimeouts1aTos1bHandler();
        break;
    }
  }

  private void exitSmS2()
  {
    switch(smS2)
    {
      case s2a:
        setSmS2(SmS2.Null);
        break;
      case s2b:
        setSmS2(SmS2.Null);
        stopTimeouts2bTos1bHandler();
        break;
    }
  }

  private void setSmS2(SmS2 aSmS2)
  {
    smS2 = aSmS2;
    if (sm != Sm.s2 && aSmS2 != SmS2.Null) { setSm(Sm.s2); }

    // entry actions and do activities
    switch(smS2)
    {
      case s2b:
        startTimeouts2bTos1bHandler();
        break;
    }
  }

  private void startTimeouts1aTos1bHandler()
  {
    timeouts1aTos1bHandler = new TimedEventHandler(this,"timeouts1aTos1b",2);
  }

  private void stopTimeouts1aTos1bHandler()
  {
    timeouts1aTos1bHandler.stop();
  }

  private void startTimeouts2bTos1bHandler()
  {
    timeouts2bTos1bHandler = new TimedEventHandler(this,"timeouts2bTos1b",3);
  }

  private void stopTimeouts2bTos1bHandler()
  {
    timeouts2bTos1bHandler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private X controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(X aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeouts1aTos1b".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts1aTos1b();
        if (shouldRestart)
        {
          controller.startTimeouts1aTos1bHandler();
        }
        return;
      }
      if ("timeouts2bTos1b".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts2bTos1b();
        if (shouldRestart)
        {
          controller.startTimeouts2bTos1bHandler();
        }
        return;
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "queuedStateMachine_timedTransition_1.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1, s2, s3, s4 }
  private Sm sm;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { ev0_M, timeouts1Tos2_M, ev2_M, ev3_M }
  
  MessageQueue queue;
  Thread removal;

  //Helper Variables
  private TimedEventHandler timeouts1Tos2Handler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s0);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean _ev0()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s0:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _timeouts1Tos2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s3:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        stopTimeouts1Tos2Handler();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        // line 4 "queuedStateMachine_timedTransition_1.ump"
        a();
        break;
      case s1:
        startTimeouts1Tos2Handler();
        break;
    }
  }

  private void startTimeouts1Tos2Handler()
  {
    timeouts1Tos2Handler = new TimedEventHandler(this,"timeouts1Tos2",2);
  }

  private void stopTimeouts1Tos2Handler()
  {
    timeouts1Tos2Handler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private X controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(X aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeouts1Tos2".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts1Tos2();
        if (shouldRestart)
        {
          controller.startTimeouts1Tos2Handler();
        }
        return;
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void ev0 ()
  {
    queue.put(new Message(MessageType.ev0_M, null));
  }

  public boolean timeouts1Tos2 ()
  {
    boolean wasAdded = false;
    queue.put(new Message(MessageType.timeouts1Tos2_M, null));
    wasAdded = true;
    return wasAdded;
  }

  public void ev2 ()
  {
    queue.put(new Message(MessageType.ev2_M, null));
  }

  public void ev3 ()
  {
    queue.put(new Message(MessageType.ev3_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case ev0_M:
          status = _ev0();
          break;
        case timeouts1Tos2_M:
          status = _timeouts1Tos2();
          break;
        case ev2_M:
          status = _ev2();
          break;
        case ev3_M:
          status = _ev3();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
  // line 19 "queuedStateMachine_timedTransition_1.ump"
  public void a(){
    System.out.println("a running");
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "queuedStateMachine_timedTransition_2.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1, s2, s3, s4 }
  private Sm sm;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { ev0_M, timeouts1Tos2_M, ev1_M, ev2_M, ev3_M }
  
  MessageQueue queue;
  Thread removal;

  //Helper Variables
  private TimedEventHandler timeouts1Tos2Handler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s0);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean _ev0()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s0:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _timeouts1Tos2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s3:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        stopTimeouts1Tos2Handler();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        // line 4 "queuedStateMachine_timedTransition_2.ump"
        a();
        break;
      case s1:
        startTimeouts1Tos2Handler();
        break;
    }
  }

  private void startTimeouts1Tos2Handler()
  {
    timeouts1Tos2Handler = new TimedEventHandler(this,"timeouts1Tos2",2);
  }

  private void stopTimeouts1Tos2Handler()
  {
    timeouts1Tos2Handler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private X controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(X aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeouts1Tos2".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts1Tos2();
        if (shouldRestart)
        {
          controller.startTimeouts1Tos2Handler();
        }
        return;
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void ev0 ()
  {
    queue.put(new Message(MessageType.ev0_M, null));
  }

  public boolean timeouts1Tos2 ()
  {
    boolean wasAdded = false;
    queue.put(new Message(MessageType.timeouts1Tos2_M, null));
    wasAdded = true;
    return wasAdded;
  }

  public void ev1 ()
  {
    queue.put(new Message(MessageType.ev1_M, null));
  }

  public void ev2 ()
  {
    queue.put(new Message(MessageType.ev2_M, null));
  }

  public void ev3 ()
  {
    queue.put(new Message(MessageType.ev3_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case ev0_M:
          status = _ev0();
          break;
        case timeouts1Tos2_M:
          status = _timeouts1Tos2();
          break;
        case ev1_M:
          status = _ev1();
          break;
        case ev2_M:
          status = _ev2();
          break;
        case ev3_M:
          status = _ev3();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
  // line 20 "queuedStateMachine_timedTransition_2.ump"
  public void a(){
    System.out.println("a running");
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "exitActionSelfTransition.ump"
public class A
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //A Attributes
  private boolean result;

  //A State Machines
  public enum Sm { created, initialized }
  private Sm sm;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public A()
  {
    result = false;
    setSm(Sm.created);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setResult(boolean aResult)
  {
    boolean wasSet = false;
    result = aResult;
    wasSet = true;
    return wasSet;
  }

  public boolean getResult()
  {
    return result;
  }

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean init()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case created:
        if (getResult()==false)
        {
          exitSm();
          setSm(Sm.created);
          wasEventProcessed = true;
          break;
        }
        if (getResult()==true)
        {
          exitSm();
          setSm(Sm.initialized);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean getback()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case initialized:
        setSm(Sm.created);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case created:
        // line 5 "exitActionSelfTransition.ump"
        execute_exit_code();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case created:
        // line 6 "exitActionSelfTransition.ump"
        execute_entry_code();
        break;
    }
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "result" + ":" + getResult()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "guardNameBothAttributeAndMethod2.ump"
public class A
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //A Attributes
  private boolean repeatCheck;

  //A State Machines
  public enum Status { s1, s2 }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public A()
  {
    repeatCheck = false;
    setStatus(Status.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setRepeatCheck(boolean aRepeatCheck)
  {
    boolean wasSet = false;
    repeatCheck = aRepeatCheck;
    wasSet = true;
    return wasSet;
  }

  public boolean getRepeatCheck()
  {
    return repeatCheck;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isRepeatCheck()
  {
    return repeatCheck;
  }

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case s1:
        if (getRepeatCheck()<repeatCheck(z))
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case s1:
        __autotransition1__();
        break;
    }
  }

  public void delete()
  {}

  // line 11 "guardNameBothAttributeAndMethod2.ump"
  public Boolean repeatCheck(){
    return true;
  }


  public String toString()
  {
    return super.toString() + "["+
            "repeatCheck" + ":" + getRepeatCheck()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "guardNameBothAttributeAndMethod3.ump"
public class A
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //A Attributes
  private boolean repeatCheck;

  //A State Machines
  public enum Status { s1, s2 }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public A()
  {
    repeatCheck = false;
    setStatus(Status.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setRepeatCheck(boolean aRepeatCheck)
  {
    boolean wasSet = false;
    repeatCheck = aRepeatCheck;
    wasSet = true;
    return wasSet;
  }

  public boolean getRepeatCheck()
  {
    return repeatCheck;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isRepeatCheck()
  {
    return repeatCheck;
  }

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case s1:
        if (getRepeatCheck()!=repeatCheck())
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case s1:
        __autotransition1__();
        break;
    }
  }

  public void delete()
  {}

  // line 11 "guardNameBothAttributeAndMethod3.ump"
  public Boolean repeatCheck(){
    return true;
  }


  public String toString()
  {
    return super.toString() + "["+
            "repeatCheck" + ":" + getRepeatCheck()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "doActivityMulti.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  private Sm sm;

  //X Do Activity Threads
  Thread doActivity0SmS1Thread = null;
  Thread doActivity1SmS1Thread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        if (doActivity0SmS1Thread != null) { doActivity0SmS1Thread.interrupt(); }
        if (doActivity1SmS1Thread != null) { doActivity1SmS1Thread.interrupt(); }
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        doActivity0SmS1Thread = new DoActivityThread(this,"doActivity0SmS1");
        doActivity1SmS1Thread = new DoActivityThread(this,"doActivity1SmS1");
        break;
    }
  }

  private void doActivity0SmS1()
  {
    try
    {
      // line 4 "doActivityMulti.ump"
      blah1();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private void doActivity1SmS1()
  {
    try
    {
      // line 5 "doActivityMulti.ump"
      blah2();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    X controller;
    String doActivityMethodName;
    
    public DoActivityThread(X aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivity0SmS1".equals(doActivityMethodName))
      {
        controller.doActivity0SmS1();
      }
        else if ("doActivity1SmS1".equals(doActivityMethodName))
      {
        controller.doActivity1SmS1();
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "pooledStateMachine_UnspecifiedReception.ump"
public class PooledSMwithUnspecifiedReception implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //PooledSMwithUnspecifiedReception State Machines
  public enum Sm { s1, s2, error1 }
  private Sm sm;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by PooledSMwithUnspecifiedReception
  protected enum MessageType { e1_M, unspecified_M, null_M }

  // Map for a PooledSMwithUnspecifiedReception pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.e1_M, MessageType.unspecified_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(Sm.error1,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public PooledSMwithUnspecifiedReception()
  {
    setSm(Sm.s1);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of PooledSMwithUnspecifiedReception
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _unspecified()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.error1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case error1:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case error1:
        __autotransition1__();
        break;
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    pool.put(new Message(MessageType.e1_M, null));
  }

  public void unspecified ()
  {
    pool.put(new Message(MessageType.unspecified_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case unspecified_M:
          status = _unspecified();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "parallelSm_sameNameDiffStates.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1 }
  public enum SmS0T1 { Null, t1 }
  public enum SmS0T2 { Null, t2, t3 }
  public enum SmS1T1 { Null, t1, t4 }
  public enum SmS1T2 { Null, t2, t5 }
  private Sm sm;
  private SmS0T1 smS0T1;
  private SmS0T2 smS0T2;
  private SmS1T1 smS1T1;
  private SmS1T2 smS1T2;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS0T1(SmS0T1.Null);
    setSmS0T2(SmS0T2.Null);
    setSmS1T1(SmS1T1.Null);
    setSmS1T2(SmS1T2.Null);
    setSm(Sm.s0);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS0T1 != SmS0T1.Null) { answer += "." + smS0T1.toString(); }
    if (smS0T2 != SmS0T2.Null) { answer += "." + smS0T2.toString(); }
    if (smS1T1 != SmS1T1.Null) { answer += "." + smS1T1.toString(); }
    if (smS1T2 != SmS1T2.Null) { answer += "." + smS1T2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS0T1 getSmS0T1()
  {
    return smS0T1;
  }

  public SmS0T2 getSmS0T2()
  {
    return smS0T2;
  }

  public SmS1T1 getSmS1T1()
  {
    return smS1T1;
  }

  public SmS1T2 getSmS1T2()
  {
    return smS1T2;
  }

  public boolean goS1()
  {
    boolean wasEventProcessed = false;
    
    SmS0T1 aSmS0T1 = smS0T1;
    switch (aSmS0T1)
    {
      case t1:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT3()
  {
    boolean wasEventProcessed = false;
    
    SmS0T2 aSmS0T2 = smS0T2;
    switch (aSmS0T2)
    {
      case t2:
        exitSmS0T2();
        setSmS0T2(SmS0T2.t3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT4()
  {
    boolean wasEventProcessed = false;
    
    SmS1T1 aSmS1T1 = smS1T1;
    switch (aSmS1T1)
    {
      case t1:
        exitSmS1T1();
        setSmS1T1(SmS1T1.t4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT5()
  {
    boolean wasEventProcessed = false;
    
    SmS1T2 aSmS1T2 = smS1T2;
    switch (aSmS1T2)
    {
      case t2:
        exitSmS1T2();
        setSmS1T2(SmS1T2.t5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s0:
        exitSmS0T1();
        exitSmS0T2();
        break;
      case s1:
        exitSmS1T1();
        exitSmS1T2();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        if (smS0T1 == SmS0T1.Null) { setSmS0T1(SmS0T1.t1); }
        if (smS0T2 == SmS0T2.Null) { setSmS0T2(SmS0T2.t2); }
        break;
      case s1:
        if (smS1T1 == SmS1T1.Null) { setSmS1T1(SmS1T1.t1); }
        if (smS1T2 == SmS1T2.Null) { setSmS1T2(SmS1T2.t2); }
        break;
    }
  }

  private void exitSmS0T1()
  {
    switch(smS0T1)
    {
      case t1:
        setSmS0T1(SmS0T1.Null);
        break;
    }
  }

  private void setSmS0T1(SmS0T1 aSmS0T1)
  {
    smS0T1 = aSmS0T1;
    if (sm != Sm.s0 && aSmS0T1 != SmS0T1.Null) { setSm(Sm.s0); }
  }

  private void exitSmS0T2()
  {
    switch(smS0T2)
    {
      case t2:
        setSmS0T2(SmS0T2.Null);
        break;
      case t3:
        setSmS0T2(SmS0T2.Null);
        break;
    }
  }

  private void setSmS0T2(SmS0T2 aSmS0T2)
  {
    smS0T2 = aSmS0T2;
    if (sm != Sm.s0 && aSmS0T2 != SmS0T2.Null) { setSm(Sm.s0); }
  }

  private void exitSmS1T1()
  {
    switch(smS1T1)
    {
      case t1:
        setSmS1T1(SmS1T1.Null);
        break;
      case t4:
        setSmS1T1(SmS1T1.Null);
        break;
    }
  }

  private void setSmS1T1(SmS1T1 aSmS1T1)
  {
    smS1T1 = aSmS1T1;
    if (sm != Sm.s1 && aSmS1T1 != SmS1T1.Null) { setSm(Sm.s1); }
  }

  private void exitSmS1T2()
  {
    switch(smS1T2)
    {
      case t2:
        setSmS1T2(SmS1T2.Null);
        break;
      case t5:
        setSmS1T2(SmS1T2.Null);
        break;
    }
  }

  private void setSmS1T2(SmS1T2 aSmS1T2)
  {
    smS1T2 = aSmS1T2;
    if (sm != Sm.s1 && aSmS1T2 != SmS1T2.Null) { setSm(Sm.s1); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 13 "../EventTransition.ump"
public class Light
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Light State Machines
  public enum Bulb { Off, On }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Light()
  {
    setBulb(Bulb.Off);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      case On:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "stateMachineWithNegativeNumberGuard.ump"
public class stateMachineWithNegativeNumberGuard
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //stateMachineWithNegativeNumberGuard State Machines
  public enum Status { on, off }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public stateMachineWithNegativeNumberGuard()
  {
    setStatus(Status.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean turnOff(Integer pn)
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case on:
        if (pn>-1)
        {
          setStatus(Status.off);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean turnOn()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case off:
        setStatus(Status.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "noDefaultEntryMethodGenerated_2.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { on, idle, off }
  private Sm sm;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean turnOff()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case on:
        setSm(Sm.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goIdle()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case on:
        setSm(Sm.idle);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean buttonPressed()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case idle:
        setSm(Sm.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean turnOn()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case off:
        setSm(Sm.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../doActivityNoTransitions.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Bulb { On, Off }
  private Bulb bulb;

  //LightFixture Do Activity Threads
  Thread doActivityBulbOnThread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setBulb(Bulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  private void exitBulb()
  {
    switch(bulb)
    {
      case On:
        if (doActivityBulbOnThread != null) { doActivityBulbOnThread.interrupt(); }
        break;
    }
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case On:
        doActivityBulbOnThread = new DoActivityThread(this,"doActivityBulbOn");
        break;
    }
  }

  private void doActivityBulbOn()
  {
    try
    {
      // line 6 "../doActivityNoTransitions.ump"
      doActivity();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    LightFixture controller;
    String doActivityMethodName;
    
    public DoActivityThread(LightFixture aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivityBulbOn".equals(doActivityMethodName))
      {
        controller.doActivityBulbOn();
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedStateMachine_withParameters.ump"
public class LightFixture implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture Attributes
  private int brightness;

  //LightFixture State Machines
  public enum Bulb { Off, Dimmed, On }
  private Bulb bulb;
  
  //enumeration type of messages accepted by LightFixture
  protected enum MessageType { turnDimmer_M, flipSwitch_M, entry_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    brightness = 0;
    setBulb(Bulb.Off);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of LightFixture
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setBrightness(int aBrightness)
  {
    boolean wasSet = false;
    brightness = aBrightness;
    wasSet = true;
    return wasSet;
  }

  public int getBrightness()
  {
    return brightness;
  }

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean _turnDimmer(Integer lightval)
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        // line 8 "../queuedStateMachine_withParameters.ump"
        setBrightness(lightval)
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case Dimmed:
        // line 14 "../queuedStateMachine_withParameters.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case On:
        // line 18 "../queuedStateMachine_withParameters.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _flipSwitch()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case Dimmed:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case On:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _entry()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Dimmed:
        if (dimmer>99)
        {
          setBulb(Bulb.On);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void turnDimmer (Integer lightval)
  {
    Vector<Object> v = new Vector<Object>(1);
    v.add(0, lightval);
    queue.put(new Message(MessageType.turnDimmer_M, v));
  }

  public void flipSwitch ()
  {
    queue.put(new Message(MessageType.flipSwitch_M, null));
  }

  public void entry ()
  {
    queue.put(new Message(MessageType.entry_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case turnDimmer_M:
          status = _turnDimmer((Integer) m.param.elementAt(0));
          break;
        case flipSwitch_M:
          status = _flipSwitch();
          break;
        case entry_M:
          status = _entry();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }

  public String toString()
  {
    return super.toString() + "["+
            "brightness" + ":" + getBrightness()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "multipleQSMe_nestedStates.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS1 { Null, s1a, s1b }
  private Sm sm;
  private SmS1 smS1;
  public enum Sm1 { s3, s4 }
  public enum Sm1S4 { Null, s4a, s4b }
  private Sm1 sm1;
  private Sm1S4 sm1S4;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e2_M, e5_M, e6_M, e3_M, e4_M, e7_M, e8_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSm(Sm.s1);
    setSm1S4(Sm1S4.Null);
    setSm1(Sm1.s3);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    return answer;
  }

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    if (sm1S4 != Sm1S4.Null) { answer += "." + sm1S4.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public Sm1S4 getSm1S4()
  {
    return sm1S4;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSmS1();
        setSmS1(SmS1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s3:
        setSm1(Sm1.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e4()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s4:
        exitSm1S4();
        setSm1S4(Sm1S4.s4a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e5()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1a:
        exitSmS1();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e6()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1b:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e7()
  {
    boolean wasEventProcessed = false;
    
    Sm1S4 aSm1S4 = sm1S4;
    switch (aSm1S4)
    {
      case s4a:
        exitSm1S4();
        setSm1S4(Sm1S4.s4b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e8()
  {
    boolean wasEventProcessed = false;
    
    Sm1S4 aSm1S4 = sm1S4;
    switch (aSm1S4)
    {
      case s4b:
        exitSm1();
        setSm1(Sm1.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s1a); }
        break;
    }
  }

  private void exitSm1()
  {
    switch(sm1)
    {
      case s4:
        exitSm1S4();
        break;
    }
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;

    // entry actions and do activities
    switch(sm1)
    {
      case s4:
        if (sm1S4 == Sm1S4.Null) { setSm1S4(Sm1S4.s4a); }
        break;
    }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s1a:
        setSmS1(SmS1.Null);
        break;
      case s1b:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }
  }

  private void exitSm1S4()
  {
    switch(sm1S4)
    {
      case s4a:
        setSm1S4(Sm1S4.Null);
        break;
      case s4b:
        setSm1S4(Sm1S4.Null);
        break;
    }
  }

  private void setSm1S4(Sm1S4 aSm1S4)
  {
    sm1S4 = aSm1S4;
    if (sm1 != Sm1.s4 && aSm1S4 != Sm1S4.Null) { setSm1(Sm1.s4); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    queue.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    queue.put(new Message(MessageType.e2_M, null));
  }

  public void e5 ()
  {
    queue.put(new Message(MessageType.e5_M, null));
  }

  public void e6 ()
  {
    queue.put(new Message(MessageType.e6_M, null));
  }

  public void e3 ()
  {
    queue.put(new Message(MessageType.e3_M, null));
  }

  public void e4 ()
  {
    queue.put(new Message(MessageType.e4_M, null));
  }

  public void e7 ()
  {
    queue.put(new Message(MessageType.e7_M, null));
  }

  public void e8 ()
  {
    queue.put(new Message(MessageType.e8_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e5_M:
          status = _e5();
          break;
        case e6_M:
          status = _e6();
          break;
        case e3_M:
          status = _e3();
          break;
        case e4_M:
          status = _e4();
          break;
        case e7_M:
          status = _e7();
          break;
        case e8_M:
          status = _e8();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "queuedStateMachine_timedEvents_and_autoTansitions.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2, s3 }
  private Sm sm;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { timeouts2Tos3_M }
  
  MessageQueue queue;
  Thread removal;

  //Helper Variables
  private TimedEventHandler timeouts2Tos3Handler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _timeouts2Tos3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        exitSm();
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s2:
        stopTimeouts2Tos3Handler();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        __autotransition1__();
        break;
      case s2:
        startTimeouts2Tos3Handler();
        break;
    }
  }

  private void startTimeouts2Tos3Handler()
  {
    timeouts2Tos3Handler = new TimedEventHandler(this,"timeouts2Tos3",10);
  }

  private void stopTimeouts2Tos3Handler()
  {
    timeouts2Tos3Handler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private X controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(X aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeouts2Tos3".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts2Tos3();
        if (shouldRestart)
        {
          controller.startTimeouts2Tos3Handler();
        }
        return;
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public boolean timeouts2Tos3 ()
  {
    boolean wasAdded = false;
    queue.put(new Message(MessageType.timeouts2Tos3_M, null));
    wasAdded = true;
    return wasAdded;
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case timeouts2Tos3_M:
          status = _timeouts2Tos3();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "pooledStateMachine_timedTransition_1.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1, s2, s3, s4 }
  private Sm sm;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { ev0_M, timeouts1Tos2_M, ev2_M, ev3_M, null_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s0,new HashSet<MessageType>(Arrays.asList(MessageType.ev0_M)));
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.timeouts1Tos2_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.ev2_M)));
    stateMessageMap.put(Sm.s3,new HashSet<MessageType>(Arrays.asList(MessageType.ev3_M)));
    stateMessageMap.put(Sm.s4,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
  }

  //Helper Variables
  private TimedEventHandler timeouts1Tos2Handler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s0);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean _ev0()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s0:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _timeouts1Tos2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s3:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        stopTimeouts1Tos2Handler();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        // line 4 "pooledStateMachine_timedTransition_1.ump"
        a();
        break;
      case s1:
        startTimeouts1Tos2Handler();
        break;
    }
  }

  private void startTimeouts1Tos2Handler()
  {
    timeouts1Tos2Handler = new TimedEventHandler(this,"timeouts1Tos2",2);
  }

  private void stopTimeouts1Tos2Handler()
  {
    timeouts1Tos2Handler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private X controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(X aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeouts1Tos2".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts1Tos2();
        if (shouldRestart)
        {
          controller.startTimeouts1Tos2Handler();
        }
        return;
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void ev0 ()
  {
    pool.put(new Message(MessageType.ev0_M, null));
  }

  public boolean timeouts1Tos2 ()
  {
    boolean wasAdded = false;
    pool.put(new Message(MessageType.timeouts1Tos2_M, null));
    wasAdded = true;
    return wasAdded;
  }

  public void ev2 ()
  {
    pool.put(new Message(MessageType.ev2_M, null));
  }

  public void ev3 ()
  {
    pool.put(new Message(MessageType.ev3_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case ev0_M:
          status = _ev0();
          break;
        case timeouts1Tos2_M:
          status = _timeouts1Tos2();
          break;
        case ev2_M:
          status = _ev2();
          break;
        case ev3_M:
          status = _ev3();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
  // line 19 "pooledStateMachine_timedTransition_1.ump"
  public void a(){
    System.out.println("a running");
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "pooledStateMachine_timedTransition_2.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1, s2, s3, s4 }
  private Sm sm;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { ev0_M, timeouts1Tos2_M, ev1_M, ev2_M, ev3_M, null_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s0,new HashSet<MessageType>(Arrays.asList(MessageType.ev0_M)));
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.timeouts1Tos2_M, MessageType.ev1_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.ev2_M)));
    stateMessageMap.put(Sm.s3,new HashSet<MessageType>(Arrays.asList(MessageType.ev3_M)));
    stateMessageMap.put(Sm.s4,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
  }

  //Helper Variables
  private TimedEventHandler timeouts1Tos2Handler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s0);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean _ev0()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s0:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _timeouts1Tos2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s3:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        stopTimeouts1Tos2Handler();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        // line 4 "pooledStateMachine_timedTransition_2.ump"
        a();
        break;
      case s1:
        startTimeouts1Tos2Handler();
        break;
    }
  }

  private void startTimeouts1Tos2Handler()
  {
    timeouts1Tos2Handler = new TimedEventHandler(this,"timeouts1Tos2",2);
  }

  private void stopTimeouts1Tos2Handler()
  {
    timeouts1Tos2Handler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private X controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(X aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeouts1Tos2".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts1Tos2();
        if (shouldRestart)
        {
          controller.startTimeouts1Tos2Handler();
        }
        return;
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void ev0 ()
  {
    pool.put(new Message(MessageType.ev0_M, null));
  }

  public boolean timeouts1Tos2 ()
  {
    boolean wasAdded = false;
    pool.put(new Message(MessageType.timeouts1Tos2_M, null));
    wasAdded = true;
    return wasAdded;
  }

  public void ev1 ()
  {
    pool.put(new Message(MessageType.ev1_M, null));
  }

  public void ev2 ()
  {
    pool.put(new Message(MessageType.ev2_M, null));
  }

  public void ev3 ()
  {
    pool.put(new Message(MessageType.ev3_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case ev0_M:
          status = _ev0();
          break;
        case timeouts1Tos2_M:
          status = _timeouts1Tos2();
          break;
        case ev1_M:
          status = _ev1();
          break;
        case ev2_M:
          status = _ev2();
          break;
        case ev3_M:
          status = _ev3();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
  // line 20 "pooledStateMachine_timedTransition_2.ump"
  public void a(){
    System.out.println("a running");
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../doActivitiesWithAutoTransition.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Bulb { On, Off }
  private Bulb bulb;

  //LightFixture Do Activity Threads
  Thread doActivity0BulbOnThread = null;
  Thread doActivity1BulbOnThread = null;
  Thread doActivity0BulbOffThread = null;
  Thread doActivity1BulbOffThread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setBulb(Bulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case On:
        exitBulb();
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private boolean __autotransition2__()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        exitBulb();
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitBulb()
  {
    switch(bulb)
    {
      case On:
        if (doActivity0BulbOnThread != null) { doActivity0BulbOnThread.interrupt(); }
        if (doActivity1BulbOnThread != null) { doActivity1BulbOnThread.interrupt(); }
        break;
      case Off:
        if (doActivity0BulbOffThread != null) { doActivity0BulbOffThread.interrupt(); }
        if (doActivity1BulbOffThread != null) { doActivity1BulbOffThread.interrupt(); }
        break;
    }
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case On:
        doActivity0BulbOnThread = new DoActivityThread(this,"doActivity0BulbOn");
        doActivity1BulbOnThread = new DoActivityThread(this,"doActivity1BulbOn");
        break;
      case Off:
        doActivity0BulbOffThread = new DoActivityThread(this,"doActivity0BulbOff");
        doActivity1BulbOffThread = new DoActivityThread(this,"doActivity1BulbOff");
        break;
    }
  }

  private void doActivity0BulbOn()
  {
    try
    {
      // line 6 "../doActivitiesWithAutoTransition.ump"
      onActivity1();
      Thread.sleep(1);
      doActivity1BulbOnThread.join();
      __autotransition1__();
    }
    catch (InterruptedException e)
    {

    }
  }

  private void doActivity1BulbOn()
  {
    try
    {
      // line 7 "../doActivitiesWithAutoTransition.ump"
      onActivity2();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private void doActivity0BulbOff()
  {
    try
    {
      // line 10 "../doActivitiesWithAutoTransition.ump"
      offActivity1();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private void doActivity1BulbOff()
  {
    try
    {
      // line 11 "../doActivitiesWithAutoTransition.ump"
      offActivity2();
      Thread.sleep(1);
      doActivity0BulbOffThread.join();
      __autotransition2__();
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    LightFixture controller;
    String doActivityMethodName;
    
    public DoActivityThread(LightFixture aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivity0BulbOn".equals(doActivityMethodName))
      {
        controller.doActivity0BulbOn();
      }
        else if ("doActivity1BulbOn".equals(doActivityMethodName))
      {
        controller.doActivity1BulbOn();
      }
        else if ("doActivity0BulbOff".equals(doActivityMethodName))
      {
        controller.doActivity0BulbOff();
      }
        else if ("doActivity1BulbOff".equals(doActivityMethodName))
      {
        controller.doActivity1BulbOff();
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedStateMachine_timedEvents.ump"
public class Mentor implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Mentor Attributes
  private int howLongUntilOk;

  //Mentor State Machines
  public enum Status { Ok, NotOk }
  private Status status;
  
  //enumeration type of messages accepted by Mentor
  protected enum MessageType { timeoutOkToNotOk_M, timeoutNotOkToOk_M }
  
  MessageQueue queue;
  Thread removal;

  //Helper Variables
  private TimedEventHandler timeoutOkToNotOkHandler;
  private TimedEventHandler timeoutNotOkToOkHandler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Mentor()
  {
    howLongUntilOk = 3;
    setStatus(Status.Ok);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of Mentor
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setHowLongUntilOk(int aHowLongUntilOk)
  {
    boolean wasSet = false;
    howLongUntilOk = aHowLongUntilOk;
    wasSet = true;
    return wasSet;
  }

  public int getHowLongUntilOk()
  {
    return howLongUntilOk;
  }

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean _timeoutOkToNotOk()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Ok:
        exitStatus();
        setStatus(Status.NotOk);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _timeoutNotOkToOk()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case NotOk:
        exitStatus();
        setStatus(Status.Ok);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitStatus()
  {
    switch(status)
    {
      case Ok:
        stopTimeoutOkToNotOkHandler();
        break;
      case NotOk:
        stopTimeoutNotOkToOkHandler();
        break;
    }
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case Ok:
        startTimeoutOkToNotOkHandler();
        break;
      case NotOk:
        startTimeoutNotOkToOkHandler();
        break;
    }
  }

  private void startTimeoutOkToNotOkHandler()
  {
    timeoutOkToNotOkHandler = new TimedEventHandler(this,"timeoutOkToNotOk",4);
  }

  private void stopTimeoutOkToNotOkHandler()
  {
    timeoutOkToNotOkHandler.stop();
  }

  private void startTimeoutNotOkToOkHandler()
  {
    timeoutNotOkToOkHandler = new TimedEventHandler(this,"timeoutNotOkToOk",howLongUntilOk);
  }

  private void stopTimeoutNotOkToOkHandler()
  {
    timeoutNotOkToOkHandler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private Mentor controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(Mentor aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeoutOkToNotOk".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeoutOkToNotOk();
        if (shouldRestart)
        {
          controller.startTimeoutOkToNotOkHandler();
        }
        return;
      }
      if ("timeoutNotOkToOk".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeoutNotOkToOk();
        if (shouldRestart)
        {
          controller.startTimeoutNotOkToOkHandler();
        }
        return;
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public boolean timeoutOkToNotOk ()
  {
    boolean wasAdded = false;
    queue.put(new Message(MessageType.timeoutOkToNotOk_M, null));
    wasAdded = true;
    return wasAdded;
  }

  public boolean timeoutNotOkToOk ()
  {
    boolean wasAdded = false;
    queue.put(new Message(MessageType.timeoutNotOkToOk_M, null));
    wasAdded = true;
    return wasAdded;
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case timeoutOkToNotOk_M:
          status = _timeoutOkToNotOk();
          break;
        case timeoutNotOkToOk_M:
          status = _timeoutNotOkToOk();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }

  public String toString()
  {
    return super.toString() + "["+
            "howLongUntilOk" + ":" + getHowLongUntilOk()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../twoEventsWithArguments.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open, Full }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean register(String name,Integer age,Double grades)
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.Open);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean reject(String firstName)
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Full:
        setStatus(Status.Full);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "multipleQSM.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS1 { Null, s1a, s1b }
  private Sm sm;
  private SmS1 smS1;
  public enum Sm1 { s3, s4 }
  private Sm1 sm1;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e2_M, e5_M, e6_M, e3_M, e4_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSm(Sm.s1);
    setSm1(Sm1.s3);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    return answer;
  }

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSmS1();
        setSmS1(SmS1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s3:
        setSm1(Sm1.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e4()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s4:
        setSm1(Sm1.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e5()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1a:
        exitSmS1();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e6()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1b:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s1a); }
        break;
    }
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s1a:
        setSmS1(SmS1.Null);
        break;
      case s1b:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    queue.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    queue.put(new Message(MessageType.e2_M, null));
  }

  public void e5 ()
  {
    queue.put(new Message(MessageType.e5_M, null));
  }

  public void e6 ()
  {
    queue.put(new Message(MessageType.e6_M, null));
  }

  public void e3 ()
  {
    queue.put(new Message(MessageType.e3_M, null));
  }

  public void e4 ()
  {
    queue.put(new Message(MessageType.e4_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e5_M:
          status = _e5();
          break;
        case e6_M:
          status = _e6();
          break;
        case e3_M:
          status = _e3();
          break;
        case e4_M:
          status = _e4();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../pooledStateMachine_withParameters.ump"
public class LightFixture implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture Attributes
  private int brightness;

  //LightFixture State Machines
  public enum Bulb { Off, Dimmed, On }
  private Bulb bulb;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by LightFixture
  protected enum MessageType { turnDimmer_M, flipSwitch_M, entry_M }

  // Map for a LightFixture pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Bulb.Off,new HashSet<MessageType>(Arrays.asList(MessageType.turnDimmer_M, MessageType.flipSwitch_M)));
    stateMessageMap.put(Bulb.Dimmed,new HashSet<MessageType>(Arrays.asList(MessageType.entry_M, MessageType.flipSwitch_M, MessageType.turnDimmer_M)));
    stateMessageMap.put(Bulb.On,new HashSet<MessageType>(Arrays.asList(MessageType.flipSwitch_M, MessageType.turnDimmer_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    brightness = 0;
    setBulb(Bulb.Off);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of LightFixture
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setBrightness(int aBrightness)
  {
    boolean wasSet = false;
    brightness = aBrightness;
    wasSet = true;
    return wasSet;
  }

  public int getBrightness()
  {
    return brightness;
  }

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean _turnDimmer(Integer lightval)
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        // line 8 "../pooledStateMachine_withParameters.ump"
        setBrightness(lightval)
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case Dimmed:
        // line 14 "../pooledStateMachine_withParameters.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case On:
        // line 18 "../pooledStateMachine_withParameters.ump"
        setBrightness(lightval)
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _flipSwitch()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.Dimmed);
        wasEventProcessed = true;
        break;
      case Dimmed:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case On:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _entry()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Dimmed:
        if (dimmer>99)
        {
          setBulb(Bulb.On);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getBulb()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void turnDimmer (Integer lightval)
  {
    Vector<Object> v = new Vector<Object>(1);
    v.add(0, lightval);
    pool.put(new Message(MessageType.turnDimmer_M, v));
  }

  public void flipSwitch ()
  {
    pool.put(new Message(MessageType.flipSwitch_M, null));
  }

  public void entry ()
  {
    pool.put(new Message(MessageType.entry_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case turnDimmer_M:
          status = _turnDimmer((Integer) m.param.elementAt(0));
          break;
        case flipSwitch_M:
          status = _flipSwitch();
          break;
        case entry_M:
          status = _entry();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }

  public String toString()
  {
    return super.toString() + "["+
            "brightness" + ":" + getBrightness()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../nestedStates_exitInnerBeforeOutter.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Bulb { Off, On }
  public enum BulbOn { Null, Normal, Dimmed }
  private Bulb bulb;
  private BulbOn bulbOn;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setBulbOn(BulbOn.Null);
    setBulb(Bulb.Off);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    if (bulbOn != BulbOn.Null) { answer += "." + bulbOn.toString(); }
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public BulbOn getBulbOn()
  {
    return bulbOn;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      case On:
        exitBulb();
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean touch()
  {
    boolean wasEventProcessed = false;
    
    BulbOn aBulbOn = bulbOn;
    switch (aBulbOn)
    {
      case Normal:
        exitBulbOn();
        setBulbOn(BulbOn.Dimmed);
        wasEventProcessed = true;
        break;
      case Dimmed:
        exitBulb();
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitBulb()
  {
    switch(bulb)
    {
      case On:
        exitBulbOn();
        // line 10 "../nestedStates_exitInnerBeforeOutter.ump"
        print("Show Me Last (Exit)");
        break;
    }
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case On:
        if (bulbOn == BulbOn.Null) { setBulbOn(BulbOn.Normal); }
        break;
    }
  }

  private void exitBulbOn()
  {
    switch(bulbOn)
    {
      case Normal:
        setBulbOn(BulbOn.Null);
        break;
      case Dimmed:
        setBulbOn(BulbOn.Null);
        break;
    }
  }

  private void setBulbOn(BulbOn aBulbOn)
  {
    bulbOn = aBulbOn;
    if (bulb != Bulb.On && aBulbOn != BulbOn.Null) { setBulb(Bulb.On); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 4 "../SimpleStateMachine.ump"
public class Mentor
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Mentor State Machines
  public enum Status {  }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Mentor()
  {}

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "eventlessStateMachine_PooledStateMachine.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { q, s }
  private Sm sm;
  public enum Sm1 { s1, s2 }
  public enum Sm1S1 { Null, s1a, s1b }
  private Sm1 sm1;
  private Sm1S1 sm1S1;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { null_M, e1_M, e2_M, e5_M, e6_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm1.s1,new HashSet<MessageType>(Arrays.asList(MessageType.e1_M)));
    stateMessageMap.put(Sm1.s2,new HashSet<MessageType>(Arrays.asList(MessageType.e2_M)));
    stateMessageMap.put(Sm1S1.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(Sm1S1.s1a,new HashSet<MessageType>(Arrays.asList(MessageType.e5_M)));
    stateMessageMap.put(Sm1S1.s1b,new HashSet<MessageType>(Arrays.asList(MessageType.e6_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.q);
    setSm1S1(Sm1S1.Null);
    setSm1(Sm1.s1);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    if (sm1S1 != Sm1S1.Null) { answer += "." + sm1S1.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public Sm1S1 getSm1S1()
  {
    return sm1S1;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s1:
        exitSm1S1();
        setSm1S1(Sm1S1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s2:
        setSm1(Sm1.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e5()
  {
    boolean wasEventProcessed = false;
    
    Sm1S1 aSm1S1 = sm1S1;
    switch (aSm1S1)
    {
      case s1a:
        exitSm1S1();
        setSm1S1(Sm1S1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e6()
  {
    boolean wasEventProcessed = false;
    
    Sm1S1 aSm1S1 = sm1S1;
    switch (aSm1S1)
    {
      case s1b:
        exitSm1();
        setSm1(Sm1.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean setSm(Sm aSm)
  {
    sm = aSm;
    return true;
  }

  private void exitSm1()
  {
    switch(sm1)
    {
      case s1:
        exitSm1S1();
        break;
    }
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;

    // entry actions and do activities
    switch(sm1)
    {
      case s1:
        if (sm1S1 == Sm1S1.Null) { setSm1S1(Sm1S1.s1a); }
        break;
    }
  }

  private void exitSm1S1()
  {
    switch(sm1S1)
    {
      case s1a:
        setSm1S1(Sm1S1.Null);
        break;
      case s1b:
        setSm1S1(Sm1S1.Null);
        break;
    }
  }

  private void setSm1S1(Sm1S1 aSm1S1)
  {
    sm1S1 = aSm1S1;
    if (sm1 != Sm1.s1 && aSm1S1 != Sm1S1.Null) { setSm1(Sm1.s1); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSm1S1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    pool.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    pool.put(new Message(MessageType.e2_M, null));
  }

  public void e5 ()
  {
    pool.put(new Message(MessageType.e5_M, null));
  }

  public void e6 ()
  {
    pool.put(new Message(MessageType.e6_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e5_M:
          status = _e5();
          break;
        case e6_M:
          status = _e6();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;

// line 1 "nestedStates_timedTransition.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS1 { Null, s1a, s1b }
  private Sm sm;
  private SmS1 smS1;

  //Helper Variables
  private TimedEventHandler timeouts1aTos1bHandler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean timeouts1aTos1b()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1a:
        exitSmS1();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1b:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s1a); }
        break;
    }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s1a:
        setSmS1(SmS1.Null);
        stopTimeouts1aTos1bHandler();
        break;
      case s1b:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1)
    {
      case s1a:
        startTimeouts1aTos1bHandler();
        break;
    }
  }

  private void startTimeouts1aTos1bHandler()
  {
    timeouts1aTos1bHandler = new TimedEventHandler(this,"timeouts1aTos1b",2);
  }

  private void stopTimeouts1aTos1bHandler()
  {
    timeouts1aTos1bHandler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private X controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(X aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeouts1aTos1b".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeouts1aTos1b();
        if (shouldRestart)
        {
          controller.startTimeouts1aTos1bHandler();
        }
        return;
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "eventlessStateMachine_QueuedStateMachine.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { q, s }
  private Sm sm;
  public enum Sm1 { s1, s2 }
  public enum Sm1S1 { Null, s1a, s1b }
  private Sm1 sm1;
  private Sm1S1 sm1S1;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e2_M, e5_M, e6_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.q);
    setSm1S1(Sm1S1.Null);
    setSm1(Sm1.s1);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    if (sm1S1 != Sm1S1.Null) { answer += "." + sm1S1.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public Sm1S1 getSm1S1()
  {
    return sm1S1;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s1:
        exitSm1S1();
        setSm1S1(Sm1S1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s2:
        setSm1(Sm1.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e5()
  {
    boolean wasEventProcessed = false;
    
    Sm1S1 aSm1S1 = sm1S1;
    switch (aSm1S1)
    {
      case s1a:
        exitSm1S1();
        setSm1S1(Sm1S1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e6()
  {
    boolean wasEventProcessed = false;
    
    Sm1S1 aSm1S1 = sm1S1;
    switch (aSm1S1)
    {
      case s1b:
        exitSm1();
        setSm1(Sm1.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean setSm(Sm aSm)
  {
    sm = aSm;
    return true;
  }

  private void exitSm1()
  {
    switch(sm1)
    {
      case s1:
        exitSm1S1();
        break;
    }
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;

    // entry actions and do activities
    switch(sm1)
    {
      case s1:
        if (sm1S1 == Sm1S1.Null) { setSm1S1(Sm1S1.s1a); }
        break;
    }
  }

  private void exitSm1S1()
  {
    switch(sm1S1)
    {
      case s1a:
        setSm1S1(Sm1S1.Null);
        break;
      case s1b:
        setSm1S1(Sm1S1.Null);
        break;
    }
  }

  private void setSm1S1(Sm1S1 aSm1S1)
  {
    sm1S1 = aSm1S1;
    if (sm1 != Sm1.s1 && aSm1S1 != Sm1S1.Null) { setSm1(Sm1.s1); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    queue.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    queue.put(new Message(MessageType.e2_M, null));
  }

  public void e5 ()
  {
    queue.put(new Message(MessageType.e5_M, null));
  }

  public void e6 ()
  {
    queue.put(new Message(MessageType.e6_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e5_M:
          status = _e5();
          break;
        case e6_M:
          status = _e6();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../sameEvent_twoStates_differentStateMachines.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Bulb { On, Off }
  private Bulb bulb;
  public enum AnotherBulb { On, Amber }
  private AnotherBulb anotherBulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setBulb(Bulb.On);
    setAnotherBulb(AnotherBulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public String getAnotherBulbFullName()
  {
    String answer = anotherBulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public AnotherBulb getAnotherBulb()
  {
    return anotherBulb;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    AnotherBulb aAnotherBulb = anotherBulb;
    switch (aBulb)
    {
      case On:
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      case Off:
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aAnotherBulb)
    {
      case On:
        setAnotherBulb(AnotherBulb.Amber);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean unflip()
  {
    boolean wasEventProcessed = false;
    
    AnotherBulb aAnotherBulb = anotherBulb;
    switch (aAnotherBulb)
    {
      case Amber:
        setAnotherBulb(AnotherBulb.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  private void setAnotherBulb(AnotherBulb aAnotherBulb)
  {
    anotherBulb = aAnotherBulb;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../nestedStates_UnspecifiedReception.ump"
public class NestedStatesWthSameEventNames
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //NestedStatesWthSameEventNames State Machines
  public enum Sm { nestedState1, nestedState2, state5 }
  public enum SmNestedState1 { Null, state1, state2 }
  public enum SmNestedState2 { Null, state3, state4 }
  private Sm sm;
  private SmNestedState1 smNestedState1;
  private SmNestedState2 smNestedState2;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public NestedStatesWthSameEventNames()
  {
    setSmNestedState1(SmNestedState1.Null);
    setSmNestedState2(SmNestedState2.Null);
    setSm(Sm.nestedState1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smNestedState1 != SmNestedState1.Null) { answer += "." + smNestedState1.toString(); }
    if (smNestedState2 != SmNestedState2.Null) { answer += "." + smNestedState2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmNestedState1 getSmNestedState1()
  {
    return smNestedState1;
  }

  public SmNestedState2 getSmNestedState2()
  {
    return smNestedState2;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    SmNestedState1 aSmNestedState1 = smNestedState1;
    switch (aSmNestedState1)
    {
      case state1:
        exitSmNestedState1();
        setSmNestedState1(SmNestedState1.state2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
        wasEventProcessed = unspecified(getSmNestedState1().toString(), "e1");
    }

    return wasEventProcessed;
  }

  public boolean unspecified(String state, String event)
  {
    boolean wasEventProcessed = false;
    
    SmNestedState1 aSmNestedState1 = smNestedState1;
    SmNestedState2 aSmNestedState2 = smNestedState2;
    switch (aSmNestedState1)
    {
      case state1:
        exitSmNestedState1();
        setSmNestedState1(SmNestedState1.state1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSmNestedState2)
    {
      case state4:
        exitSm();
        setSm(Sm.nestedState2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    SmNestedState1 aSmNestedState1 = smNestedState1;
    switch (aSmNestedState1)
    {
      case state2:
        exitSm();
        setSm(Sm.state5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e4()
  {
    boolean wasEventProcessed = false;
    
    SmNestedState2 aSmNestedState2 = smNestedState2;
    switch (aSmNestedState2)
    {
      case state4:
        exitSm();
        setSm(Sm.state5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
        wasEventProcessed = unspecified(getSmNestedState2().toString(), "e4");
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case nestedState1:
        exitSmNestedState1();
        break;
      case nestedState2:
        exitSmNestedState2();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case nestedState1:
        if (smNestedState1 == SmNestedState1.Null) { setSmNestedState1(SmNestedState1.state1); }
        break;
      case nestedState2:
        if (smNestedState2 == SmNestedState2.Null) { setSmNestedState2(SmNestedState2.state3); }
        break;
    }
  }

  private void exitSmNestedState1()
  {
    switch(smNestedState1)
    {
      case state1:
        setSmNestedState1(SmNestedState1.Null);
        break;
      case state2:
        setSmNestedState1(SmNestedState1.Null);
        break;
    }
  }

  private void setSmNestedState1(SmNestedState1 aSmNestedState1)
  {
    smNestedState1 = aSmNestedState1;
    if (sm != Sm.nestedState1 && aSmNestedState1 != SmNestedState1.Null) { setSm(Sm.nestedState1); }
  }

  private void exitSmNestedState2()
  {
    switch(smNestedState2)
    {
      case state3:
        setSmNestedState2(SmNestedState2.Null);
        break;
      case state4:
        setSmNestedState2(SmNestedState2.Null);
        break;
    }
  }

  private void setSmNestedState2(SmNestedState2 aSmNestedState2)
  {
    smNestedState2 = aSmNestedState2;
    if (sm != Sm.nestedState2 && aSmNestedState2 != SmNestedState2.Null) { setSm(Sm.nestedState2); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../nestedStates.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Bulb { Off, On }
  public enum BulbOn { Null, Normal, Dimmed }
  private Bulb bulb;
  private BulbOn bulbOn;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setBulbOn(BulbOn.Null);
    setBulb(Bulb.Off);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    if (bulbOn != BulbOn.Null) { answer += "." + bulbOn.toString(); }
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public BulbOn getBulbOn()
  {
    return bulbOn;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      case On:
        exitBulb();
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean touch()
  {
    boolean wasEventProcessed = false;
    
    BulbOn aBulbOn = bulbOn;
    switch (aBulbOn)
    {
      case Normal:
        exitBulbOn();
        setBulbOn(BulbOn.Dimmed);
        wasEventProcessed = true;
        break;
      case Dimmed:
        exitBulb();
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitBulb()
  {
    switch(bulb)
    {
      case On:
        exitBulbOn();
        break;
    }
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case On:
        if (bulbOn == BulbOn.Null) { setBulbOn(BulbOn.Normal); }
        break;
    }
  }

  private void exitBulbOn()
  {
    switch(bulbOn)
    {
      case Normal:
        setBulbOn(BulbOn.Null);
        break;
      case Dimmed:
        setBulbOn(BulbOn.Null);
        break;
    }
  }

  private void setBulbOn(BulbOn aBulbOn)
  {
    bulbOn = aBulbOn;
    if (bulb != Bulb.On && aBulbOn != BulbOn.Null) { setBulb(Bulb.On); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;

// line 1 "nestedStates_StateMachine_timedEvent.ump"
public class Window
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Window State Machines
  public enum WindowController { Stationary, SafetyMechanism }
  public enum WindowControllerStationary { Null, NormalStationary }
  private WindowController windowController;
  private WindowControllerStationary windowControllerStationary;

  //Helper Variables
  private TimedEventHandler timeoutSafetyMechanismToStationaryHandler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Window()
  {
    setWindowControllerStationary(WindowControllerStationary.Null);
    setWindowController(WindowController.Stationary);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getWindowControllerFullName()
  {
    String answer = windowController.toString();
    if (windowControllerStationary != WindowControllerStationary.Null) { answer += "." + windowControllerStationary.toString(); }
    return answer;
  }

  public WindowController getWindowController()
  {
    return windowController;
  }

  public WindowControllerStationary getWindowControllerStationary()
  {
    return windowControllerStationary;
  }

  public boolean timeoutSafetyMechanismToStationary()
  {
    boolean wasEventProcessed = false;
    
    WindowController aWindowController = windowController;
    switch (aWindowController)
    {
      case SafetyMechanism:
        exitWindowController();
        setWindowController(WindowController.Stationary);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean down()
  {
    boolean wasEventProcessed = false;
    
    WindowControllerStationary aWindowControllerStationary = windowControllerStationary;
    switch (aWindowControllerStationary)
    {
      case NormalStationary:
        exitWindowController();
        setWindowController(WindowController.SafetyMechanism);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitWindowController()
  {
    switch(windowController)
    {
      case Stationary:
        exitWindowControllerStationary();
        break;
      case SafetyMechanism:
        stopTimeoutSafetyMechanismToStationaryHandler();
        break;
    }
  }

  private void setWindowController(WindowController aWindowController)
  {
    windowController = aWindowController;

    // entry actions and do activities
    switch(windowController)
    {
      case Stationary:
        // line 7 "nestedStates_StateMachine_timedEvent.ump"
        
        if (windowControllerStationary == WindowControllerStationary.Null) { setWindowControllerStationary(WindowControllerStationary.NormalStationary); }
        break;
      case SafetyMechanism:
        // line 18 "nestedStates_StateMachine_timedEvent.ump"
        System.out.println("Safety mechanism");
        startTimeoutSafetyMechanismToStationaryHandler();
        break;
    }
  }

  private void exitWindowControllerStationary()
  {
    switch(windowControllerStationary)
    {
      case NormalStationary:
        setWindowControllerStationary(WindowControllerStationary.Null);
        break;
    }
  }

  private void setWindowControllerStationary(WindowControllerStationary aWindowControllerStationary)
  {
    windowControllerStationary = aWindowControllerStationary;
    if (windowController != WindowController.Stationary && aWindowControllerStationary != WindowControllerStationary.Null) { setWindowController(WindowController.Stationary); }

    // entry actions and do activities
    switch(windowControllerStationary)
    {
      case NormalStationary:
        // line 11 "nestedStates_StateMachine_timedEvent.ump"
        System.out.println("Window is stopped");
        break;
    }
  }

  private void startTimeoutSafetyMechanismToStationaryHandler()
  {
    timeoutSafetyMechanismToStationaryHandler = new TimedEventHandler(this,"timeoutSafetyMechanismToStationary",100);
  }

  private void stopTimeoutSafetyMechanismToStationaryHandler()
  {
    timeoutSafetyMechanismToStationaryHandler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private Window controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(Window aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeoutSafetyMechanismToStationary".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeoutSafetyMechanismToStationary();
        if (shouldRestart)
        {
          controller.startTimeoutSafetyMechanismToStationaryHandler();
        }
        return;
      }
    }
  }

  public void delete()
  {}

  // line 25 "nestedStates_StateMachine_timedEvent.ump"
   public static  void main(String [] argc){
    Thread.currentThread().setUncaughtExceptionHandler(new UmpleExceptionHandler());
    Thread.setDefaultUncaughtExceptionHandler(new UmpleExceptionHandler());
    new Window1();
  }

  public static class UmpleExceptionHandler implements Thread.UncaughtExceptionHandler
  {
    public void uncaughtException(Thread t, Throwable e)
    {
      translate(e);
      if(e.getCause()!=null)
      {
        translate(e.getCause());
      }
      e.printStackTrace();
    }
    public void translate(Throwable e)
    {
      java.util.List<StackTraceElement> result = new java.util.ArrayList<StackTraceElement>();
      StackTraceElement[] elements = e.getStackTrace();
      try
      {
        for(StackTraceElement element:elements)
        {
          String className = element.getClassName();
          String methodName = element.getMethodName();
          boolean methodFound = false;
          int index = className.lastIndexOf('.')+1;
          try {
            java.lang.reflect.Method query = this.getClass().getMethod(className.substring(index)+"_"+methodName,new Class[]{});
            UmpleSourceData sourceInformation = (UmpleSourceData)query.invoke(this,new Object[]{});
            for(int i=0;i<sourceInformation.size();++i)
            {
              // To compensate for any offsets caused by injected code we need to loop through the other references to this function
              //  and adjust the start / length of the function.
              int functionStart = sourceInformation.getJavaLine(i) + (("main".equals(methodName))?3:1);
              int functionEnd = functionStart + sourceInformation.getLength(i);
              int afterInjectionLines = 0;
              //  We can leverage the fact that all inject statements are added to the uncaught exception list 
              //   before the functions that they are within
              for (int j = 0; j < i; j++) {
                if (sourceInformation.getJavaLine(j) - 1 >= functionStart &&
                    sourceInformation.getJavaLine(j) - 1 <= functionEnd &&
                    sourceInformation.getJavaLine(j) - 1 <= element.getLineNumber()) {
                    // A before injection, +2 for the comments surrounding the injected code
                    if (sourceInformation.getJavaLine(j) - 1 == functionStart) {
                        functionStart += sourceInformation.getLength(j) + 2;
                        functionEnd += sourceInformation.getLength(j) + 2;
                    } else {
                        // An after injection
                        afterInjectionLines += sourceInformation.getLength(j) + 2;
                        functionEnd += sourceInformation.getLength(j) + 2;
                    }
                }
              }
              int distanceFromStart = element.getLineNumber() - functionStart - afterInjectionLines;
              if(distanceFromStart>=0&&distanceFromStart<=sourceInformation.getLength(i))
              {
                result.add(new StackTraceElement(element.getClassName(),element.getMethodName(),sourceInformation.getFileName(i),sourceInformation.getUmpleLine(i)+distanceFromStart));
                methodFound = true;
                break;
              }
            }
          }
          catch (Exception e2){}
          if(!methodFound)
          {
            result.add(element);
          }
        }
      }
      catch (Exception e1)
      {
        e1.printStackTrace();
      }
      e.setStackTrace(result.toArray(new StackTraceElement[0]));
    }
  //The following methods Map Java lines back to their original Umple file / line    
    public UmpleSourceData Window_setWindowControllerStationary(){ return new UmpleSourceData().setFileNames("nestedStates_StateMachine_timedEvent.ump").setUmpleLines(10).setJavaLines(147).setLengths(1);}
    public UmpleSourceData Window_main(){ return new UmpleSourceData().setFileNames("nestedStates_StateMachine_timedEvent.ump").setUmpleLines(24).setJavaLines(199).setLengths(1);}
    public UmpleSourceData Window_setWindowController(){ return new UmpleSourceData().setFileNames("nestedStates_StateMachine_timedEvent.ump","nestedStates_StateMachine_timedEvent.ump").setUmpleLines(6, 17).setJavaLines(115, 120).setLengths(1, 1);}

  }
  public static class UmpleSourceData
  {
    String[] umpleFileNames;
    Integer[] umpleLines;
    Integer[] umpleJavaLines;
    Integer[] umpleLengths;
    
    public UmpleSourceData(){
    }
    public String getFileName(int i){
      return umpleFileNames[i];
    }
    public Integer getUmpleLine(int i){
      return umpleLines[i];
    }
    public Integer getJavaLine(int i){
      return umpleJavaLines[i];
    }
    public Integer getLength(int i){
      return umpleLengths[i];
    }
    public UmpleSourceData setFileNames(String... filenames){
      umpleFileNames = filenames;
      return this;
    }
    public UmpleSourceData setUmpleLines(Integer... umplelines){
      umpleLines = umplelines;
      return this;
    }
    public UmpleSourceData setJavaLines(Integer... javalines){
      umpleJavaLines = javalines;
      return this;
    }
    public UmpleSourceData setLengths(Integer... lengths){
      umpleLengths = lengths;
      return this;
    }
    public int size(){
      return umpleFileNames.length;
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../BeforeAndAfter_StateMachineSet.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Light { On, Off }
  private Light light;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setLight(Light.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getLightFullName()
  {
    String answer = light.toString();
    return answer;
  }

  public Light getLight()
  {
    return light;
  }

  public boolean flip()
  {
    boolean wasEventProcessed = false;
    
    Light aLight = light;
    switch (aLight)
    {
      case On:
        setLight(Light.Off);
        wasEventProcessed = true;
        break;
      case Off:
        setLight(Light.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setLight(Light aLight)
  {
    // line 16 "../BeforeAndAfter_StateMachineSet.ump"
    System.out.println("About to flip");
    // END OF UMPLE BEFORE INJECTION
    light = aLight;
    // line 12 "../BeforeAndAfter_StateMachineSet.ump"
    System.out.println("Just flipped");
    // END OF UMPLE AFTER INJECTION
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../multipleGuardsSameEvent.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture Attributes
  private int brightness;

  //LightFixture State Machines
  public enum Bulb { On, Off, Amber }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    brightness = 0;
    setBulb(Bulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setBrightness(int aBrightness)
  {
    boolean wasSet = false;
    brightness = aBrightness;
    wasSet = true;
    return wasSet;
  }

  public int getBrightness()
  {
    return brightness;
  }

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean push()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case On:
        if (getBrightness()<1)
        {
          setBulb(Bulb.Off);
          wasEventProcessed = true;
          break;
        }
        if (getBrightness()>10)
        {
          setBulb(Bulb.Amber);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "brightness" + ":" + getBrightness()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 4 "../externalStateMachine.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open, Closed }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean register()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.Closed);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean deregister()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Closed:
        setStatus(Status.Open);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../guardSpacing.ump"
public class Garage
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Garage Attributes
  private boolean entranceClear;

  //Garage State Machines
  public enum GarageDoor { Open, Closing }
  private GarageDoor garageDoor;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Garage(boolean aEntranceClear)
  {
    entranceClear = aEntranceClear;
    setGarageDoor(GarageDoor.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setEntranceClear(boolean aEntranceClear)
  {
    boolean wasSet = false;
    entranceClear = aEntranceClear;
    wasSet = true;
    return wasSet;
  }

  public boolean getEntranceClear()
  {
    return entranceClear;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isEntranceClear()
  {
    return entranceClear;
  }

  public String getGarageDoorFullName()
  {
    String answer = garageDoor.toString();
    return answer;
  }

  public GarageDoor getGarageDoor()
  {
    return garageDoor;
  }

  public boolean pressButton()
  {
    boolean wasEventProcessed = false;
    
    GarageDoor aGarageDoor = garageDoor;
    switch (aGarageDoor)
    {
      case Open:
        if (getEntranceClear())
        {
          setGarageDoor(GarageDoor.Closing);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setGarageDoor(GarageDoor aGarageDoor)
  {
    garageDoor = aGarageDoor;
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "entranceClear" + ":" + getEntranceClear()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../pooledStateMachine.ump"
public class Course implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open, Full }
  private Status status;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by Course
  protected enum MessageType { register_M, reject_M }

  // Map for a Course pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Status.Open,new HashSet<MessageType>(Arrays.asList(MessageType.register_M)));
    stateMessageMap.put(Status.Full,new HashSet<MessageType>(Arrays.asList(MessageType.reject_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of Course
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean _register()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.Full);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _reject()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Full:
        setStatus(Status.Full);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getStatus()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void register ()
  {
    pool.put(new Message(MessageType.register_M, null));
  }

  public void reject ()
  {
    pool.put(new Message(MessageType.reject_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case register_M:
          status = _register();
          break;
        case reject_M:
          status = _reject();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedStateMachine.ump"
public class Course implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open, Full }
  private Status status;
  
  //enumeration type of messages accepted by Course
  protected enum MessageType { register_M, reject_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of Course
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean _register()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.Full);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _reject()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Full:
        setStatus(Status.Full);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void register ()
  {
    queue.put(new Message(MessageType.register_M, null));
  }

  public void reject ()
  {
    queue.put(new Message(MessageType.reject_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case register_M:
          status = _register();
          break;
        case reject_M:
          status = _reject();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1 }
  public enum SmS0T1 { Null, t1 }
  public enum SmS0T2 { Null, t2, t3 }
  public enum SmS1T1 { Null, t1, t4 }
  public enum SmS1T2 { Null, t2, t5 }
  private Sm sm;
  private SmS0T1 smS0T1;
  private SmS0T2 smS0T2;
  private SmS1T1 smS1T1;
  private SmS1T2 smS1T2;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS0T1(SmS0T1.Null);
    setSmS0T2(SmS0T2.Null);
    setSmS1T1(SmS1T1.Null);
    setSmS1T2(SmS1T2.Null);
    setSm(Sm.s0);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS0T1 != SmS0T1.Null) { answer += "." + smS0T1.toString(); }
    if (smS0T2 != SmS0T2.Null) { answer += "." + smS0T2.toString(); }
    if (smS1T1 != SmS1T1.Null) { answer += "." + smS1T1.toString(); }
    if (smS1T2 != SmS1T2.Null) { answer += "." + smS1T2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS0T1 getSmS0T1()
  {
    return smS0T1;
  }

  public SmS0T2 getSmS0T2()
  {
    return smS0T2;
  }

  public SmS1T1 getSmS1T1()
  {
    return smS1T1;
  }

  public SmS1T2 getSmS1T2()
  {
    return smS1T2;
  }

  public boolean goS1()
  {
    boolean wasEventProcessed = false;
    
    SmS0T1 aSmS0T1 = smS0T1;
    switch (aSmS0T1)
    {
      case t1:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT3()
  {
    boolean wasEventProcessed = false;
    
    SmS0T2 aSmS0T2 = smS0T2;
    switch (aSmS0T2)
    {
      case t2:
        exitSmS0T2();
        setSmS0T2(SmS0T2.t3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT4()
  {
    boolean wasEventProcessed = false;
    
    SmS1T1 aSmS1T1 = smS1T1;
    switch (aSmS1T1)
    {
      case t1:
        exitSmS1T1();
        setSmS1T1(SmS1T1.t4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT5()
  {
    boolean wasEventProcessed = false;
    
    SmS1T2 aSmS1T2 = smS1T2;
    switch (aSmS1T2)
    {
      case t2:
        exitSmS1T2();
        setSmS1T2(SmS1T2.t5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s0:
        exitSmS0T1();
        exitSmS0T2();
        break;
      case s1:
        exitSmS1T1();
        exitSmS1T2();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        if (smS0T1 == SmS0T1.Null) { setSmS0T1(SmS0T1.t1); }
        if (smS0T2 == SmS0T2.Null) { setSmS0T2(SmS0T2.t2); }
        break;
      case s1:
        if (smS1T1 == SmS1T1.Null) { setSmS1T1(SmS1T1.t1); }
        if (smS1T2 == SmS1T2.Null) { setSmS1T2(SmS1T2.t2); }
        break;
    }
  }

  private void exitSmS0T1()
  {
    switch(smS0T1)
    {
      case t1:
        // line 6 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
        s0_t1_exit();
        setSmS0T1(SmS0T1.Null);
        break;
    }
  }

  private void setSmS0T1(SmS0T1 aSmS0T1)
  {
    smS0T1 = aSmS0T1;
    if (sm != Sm.s0 && aSmS0T1 != SmS0T1.Null) { setSm(Sm.s0); }

    // entry actions and do activities
    switch(smS0T1)
    {
      case t1:
        // line 5 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
        s0_t1_entry();
        break;
    }
  }

  private void exitSmS0T2()
  {
    switch(smS0T2)
    {
      case t2:
        // line 12 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
        s0_t2_exit();
        setSmS0T2(SmS0T2.Null);
        break;
      case t3:
        setSmS0T2(SmS0T2.Null);
        break;
    }
  }

  private void setSmS0T2(SmS0T2 aSmS0T2)
  {
    smS0T2 = aSmS0T2;
    if (sm != Sm.s0 && aSmS0T2 != SmS0T2.Null) { setSm(Sm.s0); }

    // entry actions and do activities
    switch(smS0T2)
    {
      case t2:
        // line 11 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
        s0_t2_entry();
        break;
    }
  }

  private void exitSmS1T1()
  {
    switch(smS1T1)
    {
      case t1:
        // line 20 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
        s1_t1_exit();
        setSmS1T1(SmS1T1.Null);
        break;
      case t4:
        setSmS1T1(SmS1T1.Null);
        break;
    }
  }

  private void setSmS1T1(SmS1T1 aSmS1T1)
  {
    smS1T1 = aSmS1T1;
    if (sm != Sm.s1 && aSmS1T1 != SmS1T1.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1T1)
    {
      case t1:
        // line 19 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
        s1_t1_entry();
        break;
    }
  }

  private void exitSmS1T2()
  {
    switch(smS1T2)
    {
      case t2:
        // line 27 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
        s1_t2_exit();
        setSmS1T2(SmS1T2.Null);
        break;
      case t5:
        setSmS1T2(SmS1T2.Null);
        break;
    }
  }

  private void setSmS1T2(SmS1T2 aSmS1T2)
  {
    smS1T2 = aSmS1T2;
    if (sm != Sm.s1 && aSmS1T2 != SmS1T2.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1T2)
    {
      case t2:
        // line 26 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
        s1_t2_entry();
        break;
    }
  }

  public void delete()
  {}

  // line 34 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
  public void s0_t1_entry(){
    
  }

  // line 35 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
  public void s0_t2_entry(){
    
  }

  // line 36 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
  public void s1_t1_entry(){
    
  }

  // line 37 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
  public void s1_t2_entry(){
    
  }

  // line 38 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
  public void s0_t1_exit(){
    
  }

  // line 39 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
  public void s0_t2_exit(){
    
  }

  // line 40 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
  public void s1_t1_exit(){
    
  }

  // line 41 "parallelSm_sameNameDiffStatesEntryExitActions.ump"
  public void s1_t2_exit(){
    
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 9 "../SimpleStateMachineSpacing.ump"
public class Student
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Student State Machines
  public enum Grade { Pass }
  private Grade grade;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Student()
  {
    setGrade(Grade.Pass);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getGradeFullName()
  {
    String answer = grade.toString();
    return answer;
  }

  public Grade getGrade()
  {
    return grade;
  }

  public boolean setGrade(Grade aGrade)
  {
    grade = aGrade;
    return true;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../stateMachineSpacing1.ump"
public class Garage
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Garage State Machines
  public enum GarageDoor { Closed, Opening }
  private GarageDoor garageDoor;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Garage()
  {
    setGarageDoor(GarageDoor.Closed);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getGarageDoorFullName()
  {
    String answer = garageDoor.toString();
    return answer;
  }

  public GarageDoor getGarageDoor()
  {
    return garageDoor;
  }

  public boolean pressButton()
  {
    boolean wasEventProcessed = false;
    
    GarageDoor aGarageDoor = garageDoor;
    switch (aGarageDoor)
    {
      case Closed:
        // line 7 "../stateMachineSpacing1.ump"
        turnLightOn();
        setGarageDoor(GarageDoor.Opening);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setGarageDoor(GarageDoor aGarageDoor)
  {
    garageDoor = aGarageDoor;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../stateMachineSpacing2.ump"
public class Garage
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Garage State Machines
  public enum GarageDoor { Closed, Opening }
  private GarageDoor garageDoor;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Garage()
  {
    setGarageDoor(GarageDoor.Closed);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getGarageDoorFullName()
  {
    String answer = garageDoor.toString();
    return answer;
  }

  public GarageDoor getGarageDoor()
  {
    return garageDoor;
  }

  public boolean pressButton()
  {
    boolean wasEventProcessed = false;
    
    GarageDoor aGarageDoor = garageDoor;
    switch (aGarageDoor)
    {
      case Closed:
        // line 7 "../stateMachineSpacing2.ump"
        turnLightOn();
        setGarageDoor(GarageDoor.Opening);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setGarageDoor(GarageDoor aGarageDoor)
  {
    garageDoor = aGarageDoor;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../pooledStateMachineWithConcurrentStates_autoTransition.ump"
public class CourseAttempt implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //CourseAttempt State Machines
  public enum CourseAttemptSM { studying, failed, passed }
  public enum CourseAttemptSMStudyingLab1 { Null, lab1, lab2 }
  public enum CourseAttemptSMStudyingTermProject { Null, termProject }
  public enum CourseAttemptSMStudyingFinalExam { Null, finalExam }
  private CourseAttemptSM courseAttemptSM;
  private CourseAttemptSMStudyingLab1 courseAttemptSMStudyingLab1;
  private CourseAttemptSMStudyingTermProject courseAttemptSMStudyingTermProject;
  private CourseAttemptSMStudyingFinalExam courseAttemptSMStudyingFinalExam;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by CourseAttempt
  protected enum MessageType { null_M }

  // Map for a CourseAttempt pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(CourseAttemptSM.studying,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(CourseAttemptSM.failed,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(CourseAttemptSM.passed,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(CourseAttemptSMStudyingLab1.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(CourseAttemptSMStudyingLab1.lab1,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(CourseAttemptSMStudyingLab1.lab2,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(CourseAttemptSMStudyingTermProject.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(CourseAttemptSMStudyingTermProject.termProject,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(CourseAttemptSMStudyingFinalExam.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(CourseAttemptSMStudyingFinalExam.finalExam,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public CourseAttempt()
  {
    setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1.Null);
    setCourseAttemptSMStudyingTermProject(CourseAttemptSMStudyingTermProject.Null);
    setCourseAttemptSMStudyingFinalExam(CourseAttemptSMStudyingFinalExam.Null);
    setCourseAttemptSM(CourseAttemptSM.studying);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of CourseAttempt
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getCourseAttemptSMFullName()
  {
    String answer = courseAttemptSM.toString();
    if (courseAttemptSMStudyingLab1 != CourseAttemptSMStudyingLab1.Null) { answer += "." + courseAttemptSMStudyingLab1.toString(); }
    if (courseAttemptSMStudyingTermProject != CourseAttemptSMStudyingTermProject.Null) { answer += "." + courseAttemptSMStudyingTermProject.toString(); }
    if (courseAttemptSMStudyingFinalExam != CourseAttemptSMStudyingFinalExam.Null) { answer += "." + courseAttemptSMStudyingFinalExam.toString(); }
    return answer;
  }

  public CourseAttemptSM getCourseAttemptSM()
  {
    return courseAttemptSM;
  }

  public CourseAttemptSMStudyingLab1 getCourseAttemptSMStudyingLab1()
  {
    return courseAttemptSMStudyingLab1;
  }

  public CourseAttemptSMStudyingTermProject getCourseAttemptSMStudyingTermProject()
  {
    return courseAttemptSMStudyingTermProject;
  }

  public CourseAttemptSMStudyingFinalExam getCourseAttemptSMStudyingFinalExam()
  {
    return courseAttemptSMStudyingFinalExam;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    CourseAttemptSM aCourseAttemptSM = courseAttemptSM;
    switch (aCourseAttemptSM)
    {
      case studying:
        exitCourseAttemptSM();
        setCourseAttemptSM(CourseAttemptSM.passed);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitCourseAttemptSM()
  {
    switch(courseAttemptSM)
    {
      case studying:
        exitCourseAttemptSMStudyingLab1();
        exitCourseAttemptSMStudyingTermProject();
        exitCourseAttemptSMStudyingFinalExam();
        break;
    }
  }

  private void setCourseAttemptSM(CourseAttemptSM aCourseAttemptSM)
  {
    courseAttemptSM = aCourseAttemptSM;

    // entry actions and do activities
    switch(courseAttemptSM)
    {
      case studying:
        if (courseAttemptSMStudyingLab1 == CourseAttemptSMStudyingLab1.Null) { setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1.lab1); }
        if (courseAttemptSMStudyingTermProject == CourseAttemptSMStudyingTermProject.Null) { setCourseAttemptSMStudyingTermProject(CourseAttemptSMStudyingTermProject.termProject); }
        if (courseAttemptSMStudyingFinalExam == CourseAttemptSMStudyingFinalExam.Null) { setCourseAttemptSMStudyingFinalExam(CourseAttemptSMStudyingFinalExam.finalExam); }
        __autotransition1__();
        break;
    }
  }

  private void exitCourseAttemptSMStudyingLab1()
  {
    switch(courseAttemptSMStudyingLab1)
    {
      case lab1:
        setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1.Null);
        break;
      case lab2:
        // line 12 "../pooledStateMachineWithConcurrentStates_autoTransition.ump"
        lab2Done();
        setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1.Null);
        break;
    }
  }

  private void setCourseAttemptSMStudyingLab1(CourseAttemptSMStudyingLab1 aCourseAttemptSMStudyingLab1)
  {
    courseAttemptSMStudyingLab1 = aCourseAttemptSMStudyingLab1;
    if (courseAttemptSM != CourseAttemptSM.studying && aCourseAttemptSMStudyingLab1 != CourseAttemptSMStudyingLab1.Null) { setCourseAttemptSM(CourseAttemptSM.studying); }
  }

  private void exitCourseAttemptSMStudyingTermProject()
  {
    switch(courseAttemptSMStudyingTermProject)
    {
      case termProject:
        // line 18 "../pooledStateMachineWithConcurrentStates_autoTransition.ump"
        projectDone();
        setCourseAttemptSMStudyingTermProject(CourseAttemptSMStudyingTermProject.Null);
        break;
    }
  }

  private void setCourseAttemptSMStudyingTermProject(CourseAttemptSMStudyingTermProject aCourseAttemptSMStudyingTermProject)
  {
    courseAttemptSMStudyingTermProject = aCourseAttemptSMStudyingTermProject;
    if (courseAttemptSM != CourseAttemptSM.studying && aCourseAttemptSMStudyingTermProject != CourseAttemptSMStudyingTermProject.Null) { setCourseAttemptSM(CourseAttemptSM.studying); }
  }

  private void exitCourseAttemptSMStudyingFinalExam()
  {
    switch(courseAttemptSMStudyingFinalExam)
    {
      case finalExam:
        // line 25 "../pooledStateMachineWithConcurrentStates_autoTransition.ump"
        pass();
        setCourseAttemptSMStudyingFinalExam(CourseAttemptSMStudyingFinalExam.Null);
        break;
    }
  }

  private void setCourseAttemptSMStudyingFinalExam(CourseAttemptSMStudyingFinalExam aCourseAttemptSMStudyingFinalExam)
  {
    courseAttemptSMStudyingFinalExam = aCourseAttemptSMStudyingFinalExam;
    if (courseAttemptSM != CourseAttemptSM.studying && aCourseAttemptSMStudyingFinalExam != CourseAttemptSMStudyingFinalExam.Null) { setCourseAttemptSM(CourseAttemptSM.studying); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getCourseAttemptSM()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getCourseAttemptSMStudyingLab1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getCourseAttemptSMStudyingTermProject()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getCourseAttemptSMStudyingFinalExam()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      { 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "parallelSm_diffNamesDiffStates.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s0, s1 }
  public enum SmS0T1 { Null, t1 }
  public enum SmS0T2 { Null, t2, t3 }
  public enum SmS1T4 { Null, t4, t5 }
  public enum SmS1T6 { Null, t6, t7 }
  private Sm sm;
  private SmS0T1 smS0T1;
  private SmS0T2 smS0T2;
  private SmS1T4 smS1T4;
  private SmS1T6 smS1T6;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS0T1(SmS0T1.Null);
    setSmS0T2(SmS0T2.Null);
    setSmS1T4(SmS1T4.Null);
    setSmS1T6(SmS1T6.Null);
    setSm(Sm.s0);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS0T1 != SmS0T1.Null) { answer += "." + smS0T1.toString(); }
    if (smS0T2 != SmS0T2.Null) { answer += "." + smS0T2.toString(); }
    if (smS1T4 != SmS1T4.Null) { answer += "." + smS1T4.toString(); }
    if (smS1T6 != SmS1T6.Null) { answer += "." + smS1T6.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS0T1 getSmS0T1()
  {
    return smS0T1;
  }

  public SmS0T2 getSmS0T2()
  {
    return smS0T2;
  }

  public SmS1T4 getSmS1T4()
  {
    return smS1T4;
  }

  public SmS1T6 getSmS1T6()
  {
    return smS1T6;
  }

  public boolean goS1()
  {
    boolean wasEventProcessed = false;
    
    SmS0T1 aSmS0T1 = smS0T1;
    switch (aSmS0T1)
    {
      case t1:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT3()
  {
    boolean wasEventProcessed = false;
    
    SmS0T2 aSmS0T2 = smS0T2;
    switch (aSmS0T2)
    {
      case t2:
        exitSmS0T2();
        setSmS0T2(SmS0T2.t3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT5()
  {
    boolean wasEventProcessed = false;
    
    SmS1T4 aSmS1T4 = smS1T4;
    switch (aSmS1T4)
    {
      case t4:
        exitSmS1T4();
        setSmS1T4(SmS1T4.t5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goT7()
  {
    boolean wasEventProcessed = false;
    
    SmS1T6 aSmS1T6 = smS1T6;
    switch (aSmS1T6)
    {
      case t6:
        exitSmS1T6();
        setSmS1T6(SmS1T6.t7);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s0:
        exitSmS0T1();
        exitSmS0T2();
        break;
      case s1:
        exitSmS1T4();
        exitSmS1T6();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s0:
        if (smS0T1 == SmS0T1.Null) { setSmS0T1(SmS0T1.t1); }
        if (smS0T2 == SmS0T2.Null) { setSmS0T2(SmS0T2.t2); }
        break;
      case s1:
        if (smS1T4 == SmS1T4.Null) { setSmS1T4(SmS1T4.t4); }
        if (smS1T6 == SmS1T6.Null) { setSmS1T6(SmS1T6.t6); }
        break;
    }
  }

  private void exitSmS0T1()
  {
    switch(smS0T1)
    {
      case t1:
        setSmS0T1(SmS0T1.Null);
        break;
    }
  }

  private void setSmS0T1(SmS0T1 aSmS0T1)
  {
    smS0T1 = aSmS0T1;
    if (sm != Sm.s0 && aSmS0T1 != SmS0T1.Null) { setSm(Sm.s0); }
  }

  private void exitSmS0T2()
  {
    switch(smS0T2)
    {
      case t2:
        setSmS0T2(SmS0T2.Null);
        break;
      case t3:
        setSmS0T2(SmS0T2.Null);
        break;
    }
  }

  private void setSmS0T2(SmS0T2 aSmS0T2)
  {
    smS0T2 = aSmS0T2;
    if (sm != Sm.s0 && aSmS0T2 != SmS0T2.Null) { setSm(Sm.s0); }
  }

  private void exitSmS1T4()
  {
    switch(smS1T4)
    {
      case t4:
        setSmS1T4(SmS1T4.Null);
        break;
      case t5:
        setSmS1T4(SmS1T4.Null);
        break;
    }
  }

  private void setSmS1T4(SmS1T4 aSmS1T4)
  {
    smS1T4 = aSmS1T4;
    if (sm != Sm.s1 && aSmS1T4 != SmS1T4.Null) { setSm(Sm.s1); }
  }

  private void exitSmS1T6()
  {
    switch(smS1T6)
    {
      case t6:
        setSmS1T6(SmS1T6.Null);
        break;
      case t7:
        setSmS1T6(SmS1T6.Null);
        break;
    }
  }

  private void setSmS1T6(SmS1T6 aSmS1T6)
  {
    smS1T6 = aSmS1T6;
    if (sm != Sm.s1 && aSmS1T6 != SmS1T6.Null) { setSm(Sm.s1); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../entryExitTransitionAction.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Bulb { On, Off }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setBulb(Bulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean push()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case On:
        exitBulb();
        // line 10 "../entryExitTransitionAction.ump"
        doTransition();
        setBulb(Bulb.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitBulb()
  {
    switch(bulb)
    {
      case On:
        // line 9 "../entryExitTransitionAction.ump"
        doExit();
        break;
    }
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case On:
        // line 8 "../entryExitTransitionAction.ump"
        doEntry();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;

// line 4 "../timedEvent.ump"
public class Mentor
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Mentor Attributes
  private int howLongUntilOk;

  //Mentor State Machines
  public enum Status { Ok, NotOkay, NotOk }
  private Status status;

  //Helper Variables
  private TimedEventHandler timeoutOkToNotOkHandler;
  private TimedEventHandler timeoutNotOkayToOkHandler;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Mentor()
  {
    howLongUntilOk = 3;
    setStatus(Status.Ok);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setHowLongUntilOk(int aHowLongUntilOk)
  {
    boolean wasSet = false;
    howLongUntilOk = aHowLongUntilOk;
    wasSet = true;
    return wasSet;
  }

  public int getHowLongUntilOk()
  {
    return howLongUntilOk;
  }

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean timeoutOkToNotOk()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Ok:
        exitStatus();
        setStatus(Status.NotOk);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean timeoutNotOkayToOk()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case NotOkay:
        exitStatus();
        setStatus(Status.Ok);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitStatus()
  {
    switch(status)
    {
      case Ok:
        stopTimeoutOkToNotOkHandler();
        break;
      case NotOkay:
        stopTimeoutNotOkayToOkHandler();
        break;
    }
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case Ok:
        startTimeoutOkToNotOkHandler();
        break;
      case NotOkay:
        startTimeoutNotOkayToOkHandler();
        break;
    }
  }

  private void startTimeoutOkToNotOkHandler()
  {
    timeoutOkToNotOkHandler = new TimedEventHandler(this,"timeoutOkToNotOk",4);
  }

  private void stopTimeoutOkToNotOkHandler()
  {
    timeoutOkToNotOkHandler.stop();
  }

  private void startTimeoutNotOkayToOkHandler()
  {
    timeoutNotOkayToOkHandler = new TimedEventHandler(this,"timeoutNotOkayToOk",howLongUntilOk);
  }

  private void stopTimeoutNotOkayToOkHandler()
  {
    timeoutNotOkayToOkHandler.stop();
  }

  public static class TimedEventHandler extends TimerTask  
  {
    private Mentor controller;
    private String timeoutMethodName;
    private double howLongInSeconds;
    private Timer timer;
    
    public TimedEventHandler(Mentor aController, String aTimeoutMethodName, double aHowLongInSeconds)
    {
      controller = aController;
      timeoutMethodName = aTimeoutMethodName;
      howLongInSeconds = aHowLongInSeconds;
      timer = new Timer();
      timer.schedule(this, (long)howLongInSeconds*1000);
    }
    
    public void stop()
    {
      timer.cancel();
    }
    
    public void run ()
    {
      if ("timeoutOkToNotOk".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeoutOkToNotOk();
        if (shouldRestart)
        {
          controller.startTimeoutOkToNotOkHandler();
        }
        return;
      }
      if ("timeoutNotOkayToOk".equals(timeoutMethodName))
      {
        boolean shouldRestart = !controller.timeoutNotOkayToOk();
        if (shouldRestart)
        {
          controller.startTimeoutNotOkayToOkHandler();
        }
        return;
      }
    }
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "howLongUntilOk" + ":" + getHowLongUntilOk()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "testMultipleQSMs.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X Attributes
  private String ev;

  //X State Machines
  public enum Sm { s1, s2, s3, s4 }
  private Sm sm;
  public enum Sm2 { sm21, sm22 }
  private Sm2 sm2;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { ev1_M, ev5_M, ev2_M, ev3_M, ev4_M, ev7_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    ev = "";
    setSm(Sm.s1);
    setSm2(Sm2.sm21);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setEv(String aEv)
  {
    boolean wasSet = false;
    ev = aEv;
    wasSet = true;
    return wasSet;
  }

  public String getEv()
  {
    return ev;
  }

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public String getSm2FullName()
  {
    String answer = sm2.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm2 getSm2()
  {
    return sm2;
  }

  public boolean _ev1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    Sm2 aSm2 = sm2;
    switch (aSm)
    {
      case s1:
        // line 5 "testMultipleQSMs.ump"
        ev="ev1";
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSm2)
    {
      case sm21:
        // line 25 "testMultipleQSMs.ump"
        ev="ev1 in sm2";
        setSm2(Sm2.sm22);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    // line 19 "testMultipleQSMs.ump"
    if(wasEventProcessed)
          System.out.println(ev);
    // END OF UMPLE AFTER INJECTION
    return wasEventProcessed;
  }

  public boolean _ev5()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        // line 6 "testMultipleQSMs.ump"
        ev="ev5";
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    // line 19 "testMultipleQSMs.ump"
    if(wasEventProcessed)
          System.out.println(ev);
    // END OF UMPLE AFTER INJECTION
    return wasEventProcessed;
  }

  public boolean _ev2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        // line 9 "testMultipleQSMs.ump"
        ev="ev2";
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    // line 19 "testMultipleQSMs.ump"
    if(wasEventProcessed)
          System.out.println(ev);
    // END OF UMPLE AFTER INJECTION
    return wasEventProcessed;
  }

  public boolean _ev3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s3:
        // line 12 "testMultipleQSMs.ump"
        ev="ev3";
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    // line 19 "testMultipleQSMs.ump"
    if(wasEventProcessed)
          System.out.println(ev);
    // END OF UMPLE AFTER INJECTION
    return wasEventProcessed;
  }

  public boolean _ev4()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s4:
        // line 15 "testMultipleQSMs.ump"
        ev="ev4";
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    // line 19 "testMultipleQSMs.ump"
    if(wasEventProcessed)
          System.out.println(ev);
    // END OF UMPLE AFTER INJECTION
    return wasEventProcessed;
  }

  public boolean _ev7()
  {
    boolean wasEventProcessed = false;
    
    Sm2 aSm2 = sm2;
    switch (aSm2)
    {
      case sm22:
        // line 28 "testMultipleQSMs.ump"
        ev="ev7 in sm2";
        setSm2(Sm2.sm21);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    // line 19 "testMultipleQSMs.ump"
    if(wasEventProcessed)
          System.out.println(ev);
    // END OF UMPLE AFTER INJECTION
    return wasEventProcessed;
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;
  }

  private void setSm2(Sm2 aSm2)
  {
    sm2 = aSm2;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void ev1 ()
  {
    queue.put(new Message(MessageType.ev1_M, null));
  }

  public void ev5 ()
  {
    queue.put(new Message(MessageType.ev5_M, null));
  }

  public void ev2 ()
  {
    queue.put(new Message(MessageType.ev2_M, null));
  }

  public void ev3 ()
  {
    queue.put(new Message(MessageType.ev3_M, null));
  }

  public void ev4 ()
  {
    queue.put(new Message(MessageType.ev4_M, null));
  }

  public void ev7 ()
  {
    queue.put(new Message(MessageType.ev7_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case ev1_M:
          status = _ev1();
          break;
        case ev5_M:
          status = _ev5();
          break;
        case ev2_M:
          status = _ev2();
          break;
        case ev3_M:
          status = _ev3();
          break;
        case ev4_M:
          status = _ev4();
          break;
        case ev7_M:
          status = _ev7();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }

  public String toString()
  {
    return super.toString() + "["+
            "ev" + ":" + getEv()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../activeObject.ump"
public class Lamp
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Lamp Attributes
  private String log;

  //Lamp State Machines
  public enum StateMachine1 { topLevel }
  public enum StateMachine1TopLevel { Null, thread1 }
  private StateMachine1 stateMachine1;
  private StateMachine1TopLevel stateMachine1TopLevel;
  public enum StateMachine2 { topLevel }
  public enum StateMachine2TopLevel { Null, thread1 }
  private StateMachine2 stateMachine2;
  private StateMachine2TopLevel stateMachine2TopLevel;

  //Lamp Do Activity Threads
  Thread doActivityStateMachine1TopLevelThread1Thread = null;
  Thread doActivityStateMachine2TopLevelThread1Thread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Lamp(String aLog)
  {
    log = aLog;
    setStateMachine1TopLevel(StateMachine1TopLevel.Null);
    setStateMachine1(StateMachine1.topLevel);
    setStateMachine2TopLevel(StateMachine2TopLevel.Null);
    setStateMachine2(StateMachine2.topLevel);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setLog(String aLog)
  {
    boolean wasSet = false;
    log = aLog;
    wasSet = true;
    return wasSet;
  }

  public String getLog()
  {
    return log;
  }

  public String getStateMachine1FullName()
  {
    String answer = stateMachine1.toString();
    if (stateMachine1TopLevel != StateMachine1TopLevel.Null) { answer += "." + stateMachine1TopLevel.toString(); }
    return answer;
  }

  public String getStateMachine2FullName()
  {
    String answer = stateMachine2.toString();
    if (stateMachine2TopLevel != StateMachine2TopLevel.Null) { answer += "." + stateMachine2TopLevel.toString(); }
    return answer;
  }

  public StateMachine1 getStateMachine1()
  {
    return stateMachine1;
  }

  public StateMachine2 getStateMachine2()
  {
    return stateMachine2;
  }

  public StateMachine1TopLevel getStateMachine1TopLevel()
  {
    return stateMachine1TopLevel;
  }

  public StateMachine2TopLevel getStateMachine2TopLevel()
  {
    return stateMachine2TopLevel;
  }

  private void exitStateMachine1()
  {
    switch(stateMachine1)
    {
      case topLevel:
        exitStateMachine1TopLevel();
        break;
    }
  }

  private void setStateMachine1(StateMachine1 aStateMachine1)
  {
    stateMachine1 = aStateMachine1;

    // entry actions and do activities
    switch(stateMachine1)
    {
      case topLevel:
        if (stateMachine1TopLevel == StateMachine1TopLevel.Null) { setStateMachine1TopLevel(StateMachine1TopLevel.thread1); }
        break;
    }
  }

  private void exitStateMachine2()
  {
    switch(stateMachine2)
    {
      case topLevel:
        exitStateMachine2TopLevel();
        break;
    }
  }

  private void setStateMachine2(StateMachine2 aStateMachine2)
  {
    stateMachine2 = aStateMachine2;

    // entry actions and do activities
    switch(stateMachine2)
    {
      case topLevel:
        if (stateMachine2TopLevel == StateMachine2TopLevel.Null) { setStateMachine2TopLevel(StateMachine2TopLevel.thread1); }
        break;
    }
  }

  private void exitStateMachine1TopLevel()
  {
    switch(stateMachine1TopLevel)
    {
      case thread1:
        if (doActivityStateMachine1TopLevelThread1Thread != null) { doActivityStateMachine1TopLevelThread1Thread.interrupt(); }
        setStateMachine1TopLevel(StateMachine1TopLevel.Null);
        break;
    }
  }

  private void setStateMachine1TopLevel(StateMachine1TopLevel aStateMachine1TopLevel)
  {
    stateMachine1TopLevel = aStateMachine1TopLevel;
    if (stateMachine1 != StateMachine1.topLevel && aStateMachine1TopLevel != StateMachine1TopLevel.Null) { setStateMachine1(StateMachine1.topLevel); }

    // entry actions and do activities
    switch(stateMachine1TopLevel)
    {
      case thread1:
        doActivityStateMachine1TopLevelThread1Thread = new DoActivityThread(this,"doActivityStateMachine1TopLevelThread1");
        break;
    }
  }

  private void exitStateMachine2TopLevel()
  {
    switch(stateMachine2TopLevel)
    {
      case thread1:
        if (doActivityStateMachine2TopLevelThread1Thread != null) { doActivityStateMachine2TopLevelThread1Thread.interrupt(); }
        setStateMachine2TopLevel(StateMachine2TopLevel.Null);
        break;
    }
  }

  private void setStateMachine2TopLevel(StateMachine2TopLevel aStateMachine2TopLevel)
  {
    stateMachine2TopLevel = aStateMachine2TopLevel;
    if (stateMachine2 != StateMachine2.topLevel && aStateMachine2TopLevel != StateMachine2TopLevel.Null) { setStateMachine2(StateMachine2.topLevel); }

    // entry actions and do activities
    switch(stateMachine2TopLevel)
    {
      case thread1:
        doActivityStateMachine2TopLevelThread1Thread = new DoActivityThread(this,"doActivityStateMachine2TopLevelThread1");
        break;
    }
  }

  private void doActivityStateMachine1TopLevelThread1()
  {
    try
    {
      // line 6 "../activeObject.ump"
      log = "Active entry";
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private void doActivityStateMachine2TopLevelThread1()
  {
    try
    {
      // line 10 "../activeObject.ump"
      log = "Active entry";
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    Lamp controller;
    String doActivityMethodName;
    
    public DoActivityThread(Lamp aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivityStateMachine1TopLevelThread1".equals(doActivityMethodName))
      {
        controller.doActivityStateMachine1TopLevelThread1();
      }
        else if ("doActivityStateMachine2TopLevelThread1".equals(doActivityMethodName))
      {
        controller.doActivityStateMachine2TopLevelThread1();
      }
    }
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "log" + ":" + getLog()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "1600_guardsOnEntryAndExit.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  private Sm sm;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean hh()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean hhh()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        // line 8 "1600_guardsOnEntryAndExit.ump"
        if (!condition2)
        {
          System.out.println("s1 exit!");
        }
        break;
      case s2:
        // line 17 "1600_guardsOnEntryAndExit.ump"
        if (condition4)
        {
          System.out.println("s2 exit!");
        }
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        // line 4 "1600_guardsOnEntryAndExit.ump"
        if (condition)
        {
          System.out.println("s1 entry!");
        }
        break;
      case s2:
        // line 13 "1600_guardsOnEntryAndExit.ump"
        if (condition3)
        {
          System.out.println("s2 entry!");
        }
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "equivalentGuards.ump"
public class A
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //A State Machines
  public enum Status { s1, s2 }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public A()
  {
    setStatus(Status.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean test()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case s1:
        if (y>z)
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        if ((x+y)>z)
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        if ((5*2)<11)
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        if ((x+y)==z)
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        if (x.equals(y))
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        if ("test".equals(x))
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        if (x.equals("test"+"hello"))
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        if (((5*2)<=11))
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        if (((a>b)||(variable&&((b<a)||(c>=b)))))
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        if (((a-c)>(b*2))!=((a-c)>(b^2)))
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../doActivity.ump"
public class Switch
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Switch State Machines
  public enum Status { On, Off }
  private Status status;

  //Switch Do Activity Threads
  Thread doActivityStatusOffThread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Switch()
  {
    setStatus(Status.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean press()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case On:
        setStatus(Status.Off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitStatus()
  {
    switch(status)
    {
      case Off:
        if (doActivityStatusOffThread != null) { doActivityStatusOffThread.interrupt(); }
        break;
    }
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case Off:
        doActivityStatusOffThread = new DoActivityThread(this,"doActivityStatusOff");
        break;
    }
  }

  private void doActivityStatusOff()
  {
    try
    {
      // line 14 "../doActivity.ump"
      keepDoing();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    Switch controller;
    String doActivityMethodName;
    
    public DoActivityThread(Switch aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivityStatusOff".equals(doActivityMethodName))
      {
        controller.doActivityStatusOff();
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "multipleQSM_sameEvents.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2, s3, s4 }
  private Sm sm;
  public enum Sm2 { sm21, sm22 }
  private Sm2 sm2;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { ev1_M, ev5_M, ev2_M, ev3_M, ev4_M, ev7_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
    setSm2(Sm2.sm21);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public String getSm2FullName()
  {
    String answer = sm2.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm2 getSm2()
  {
    return sm2;
  }

  public boolean _ev1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    Sm2 aSm2 = sm2;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSm2)
    {
      case sm21:
        setSm2(Sm2.sm22);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev5()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev3()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s3:
        setSm(Sm.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev4()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s4:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _ev7()
  {
    boolean wasEventProcessed = false;
    
    Sm2 aSm2 = sm2;
    switch (aSm2)
    {
      case sm22:
        setSm2(Sm2.sm21);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;
  }

  private void setSm2(Sm2 aSm2)
  {
    sm2 = aSm2;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void ev1 ()
  {
    queue.put(new Message(MessageType.ev1_M, null));
  }

  public void ev5 ()
  {
    queue.put(new Message(MessageType.ev5_M, null));
  }

  public void ev2 ()
  {
    queue.put(new Message(MessageType.ev2_M, null));
  }

  public void ev3 ()
  {
    queue.put(new Message(MessageType.ev3_M, null));
  }

  public void ev4 ()
  {
    queue.put(new Message(MessageType.ev4_M, null));
  }

  public void ev7 ()
  {
    queue.put(new Message(MessageType.ev7_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case ev1_M:
          status = _ev1();
          break;
        case ev5_M:
          status = _ev5();
          break;
        case ev2_M:
          status = _ev2();
          break;
        case ev3_M:
          status = _ev3();
          break;
        case ev4_M:
          status = _ev4();
          break;
        case ev7_M:
          status = _ev7();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "multiplePooledStateMachine.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  private Sm sm;
  public enum Sm1 { s3, s4, s5 }
  private Sm1 sm1;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e2_M, e3_M, e4_M, null_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.e1_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.e2_M)));
    stateMessageMap.put(Sm1.s3,new HashSet<MessageType>(Arrays.asList(MessageType.e3_M)));
    stateMessageMap.put(Sm1.s4,new HashSet<MessageType>(Arrays.asList(MessageType.e4_M)));
    stateMessageMap.put(Sm1.s5,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
    setSm1(Sm1.s3);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s3:
        setSm1(Sm1.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e4()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s4:
        setSm1(Sm1.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        if(stateMessageMap.get(getSm1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    pool.put(new Message(MessageType.e1_M, null));
  }

  public void e2 ()
  {
    pool.put(new Message(MessageType.e2_M, null));
  }

  public void e3 ()
  {
    pool.put(new Message(MessageType.e3_M, null));
  }

  public void e4 ()
  {
    pool.put(new Message(MessageType.e4_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e2_M:
          status = _e2();
          break;
        case e3_M:
          status = _e3();
          break;
        case e4_M:
          status = _e4();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "guardNameBothAttributeAndMethod.ump"
public class A
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //A Attributes
  private boolean repeatCheck;

  //A State Machines
  public enum Status { s1, s2, s3 }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public A()
  {
    repeatCheck = false;
    setStatus(Status.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setRepeatCheck(boolean aRepeatCheck)
  {
    boolean wasSet = false;
    repeatCheck = aRepeatCheck;
    wasSet = true;
    return wasSet;
  }

  public boolean getRepeatCheck()
  {
    return repeatCheck;
  }
  /* Code from template attribute_IsBoolean */
  public boolean isRepeatCheck()
  {
    return repeatCheck;
  }

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case s1:
        if (repeatCheck())
        {
          setStatus(Status.s2);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;

    // entry actions and do activities
    switch(status)
    {
      case s1:
        __autotransition1__();
        break;
    }
  }

  public void delete()
  {}

  // line 15 "guardNameBothAttributeAndMethod.ump"
  public Boolean repeatCheck(){
    return true;
  }


  public String toString()
  {
    return super.toString() + "["+
            "repeatCheck" + ":" + getRepeatCheck()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "checkExternalTransitions_concurrentStateMachines.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS1A { Null, a }
  public enum SmS1AA { Null, t1, t2 }
  public enum SmS1B { Null, b }
  public enum SmS1BB { Null, t3, t4 }
  private Sm sm;
  private SmS1A smS1A;
  private SmS1AA smS1AA;
  private SmS1B smS1B;
  private SmS1BB smS1BB;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1A(SmS1A.Null);
    setSmS1AA(SmS1AA.Null);
    setSmS1B(SmS1B.Null);
    setSmS1BB(SmS1BB.Null);
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1A != SmS1A.Null) { answer += "." + smS1A.toString(); }
    if (smS1AA != SmS1AA.Null) { answer += "." + smS1AA.toString(); }
    if (smS1B != SmS1B.Null) { answer += "." + smS1B.toString(); }
    if (smS1BB != SmS1BB.Null) { answer += "." + smS1BB.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1A getSmS1A()
  {
    return smS1A;
  }

  public SmS1AA getSmS1AA()
  {
    return smS1AA;
  }

  public SmS1B getSmS1B()
  {
    return smS1B;
  }

  public SmS1BB getSmS1BB()
  {
    return smS1BB;
  }

  public boolean goToT2()
  {
    boolean wasEventProcessed = false;
    
    SmS1AA aSmS1AA = smS1AA;
    switch (aSmS1AA)
    {
      case t1:
        exitSmS1AA();
        setSmS1AA(SmS1AA.t2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToT4()
  {
    boolean wasEventProcessed = false;
    
    SmS1AA aSmS1AA = smS1AA;
    switch (aSmS1AA)
    {
      case t2:
        exitSmS1A();
        setSmS1BB(SmS1BB.t4);
        setSmS1A(SmS1A.a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean goToS2()
  {
    boolean wasEventProcessed = false;
    
    SmS1BB aSmS1BB = smS1BB;
    switch (aSmS1BB)
    {
      case t4:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1A();
        exitSmS1B();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1A == SmS1A.Null) { setSmS1A(SmS1A.a); }
        if (smS1B == SmS1B.Null) { setSmS1B(SmS1B.b); }
        break;
    }
  }

  private void exitSmS1A()
  {
    switch(smS1A)
    {
      case a:
        exitSmS1AA();
        // line 5 "checkExternalTransitions_concurrentStateMachines.ump"
        exit_a_action();
        setSmS1A(SmS1A.Null);
        break;
    }
  }

  private void setSmS1A(SmS1A aSmS1A)
  {
    smS1A = aSmS1A;
    if (sm != Sm.s1 && aSmS1A != SmS1A.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1A)
    {
      case a:
        if (smS1AA == SmS1AA.Null) { setSmS1AA(SmS1AA.t1); }
        break;
    }
  }

  private void exitSmS1AA()
  {
    switch(smS1AA)
    {
      case t1:
        setSmS1AA(SmS1AA.Null);
        break;
      case t2:
        setSmS1AA(SmS1AA.Null);
        break;
    }
  }

  private void setSmS1AA(SmS1AA aSmS1AA)
  {
    smS1AA = aSmS1AA;
    if (smS1A != SmS1A.a && aSmS1AA != SmS1AA.Null) { setSmS1A(SmS1A.a); }
  }

  private void exitSmS1B()
  {
    switch(smS1B)
    {
      case b:
        exitSmS1BB();
        // line 15 "checkExternalTransitions_concurrentStateMachines.ump"
        exit_b_action();
        setSmS1B(SmS1B.Null);
        break;
    }
  }

  private void setSmS1B(SmS1B aSmS1B)
  {
    smS1B = aSmS1B;
    if (sm != Sm.s1 && aSmS1B != SmS1B.Null) { setSm(Sm.s1); }

    // entry actions and do activities
    switch(smS1B)
    {
      case b:
        if (smS1BB == SmS1BB.Null) { setSmS1BB(SmS1BB.t3); }
        break;
    }
  }

  private void exitSmS1BB()
  {
    switch(smS1BB)
    {
      case t3:
        setSmS1BB(SmS1BB.Null);
        break;
      case t4:
        setSmS1BB(SmS1BB.Null);
        break;
    }
  }

  private void setSmS1BB(SmS1BB aSmS1BB)
  {
    smS1BB = aSmS1BB;
    if (smS1B != SmS1B.b && aSmS1BB != SmS1BB.Null) { setSmS1B(SmS1B.b); }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedStateMachine_autoTransition.ump"
public class Light implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Light State Machines
  public enum Bulb { Off, On }
  private Bulb bulb;
  
  //enumeration type of messages accepted by Light
  protected enum MessageType {  }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Light()
  {
    setBulb(Bulb.Off);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of Light
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case Off:
        __autotransition1__();
        break;
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      { 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "doActivityMultiMixin.ump"
// line 11 "doActivityMultiMixin.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  private Sm sm;

  //X Do Activity Threads
  Thread doActivity0SmS1Thread = null;
  Thread doActivity1SmS1Thread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm(Sm.s1);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        if (doActivity0SmS1Thread != null) { doActivity0SmS1Thread.interrupt(); }
        if (doActivity1SmS1Thread != null) { doActivity1SmS1Thread.interrupt(); }
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        doActivity0SmS1Thread = new DoActivityThread(this,"doActivity0SmS1");
        doActivity1SmS1Thread = new DoActivityThread(this,"doActivity1SmS1");
        break;
    }
  }

  private void doActivity0SmS1()
  {
    try
    {
      // line 4 "doActivityMultiMixin.ump"
      blah1();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private void doActivity1SmS1()
  {
    try
    {
      // line 14 "doActivityMultiMixin.ump"
      blah2();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    X controller;
    String doActivityMethodName;
    
    public DoActivityThread(X aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivity0SmS1".equals(doActivityMethodName))
      {
        controller.doActivity0SmS1();
      }
        else if ("doActivity1SmS1".equals(doActivityMethodName))
      {
        controller.doActivity1SmS1();
      }
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../entryExitTransitionActionWithGuard.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture State Machines
  public enum Bulb { On, Off }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    setBulb(Bulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean push()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case On:
        if (isTurnedOn)
        {
          exitBulb();
        // line 10 "../entryExitTransitionActionWithGuard.ump"
          doTransition();
          setBulb(Bulb.Off);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitBulb()
  {
    switch(bulb)
    {
      case On:
        // line 9 "../entryExitTransitionActionWithGuard.ump"
        doExit();
        break;
    }
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case On:
        // line 8 "../entryExitTransitionActionWithGuard.ump"
        doEntry();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "testPooledwithNestedStates_2.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2 }
  public enum SmS1 { Null, s1a, s1b }
  public enum SmS2 { Null, s2a, s2b }
  private Sm sm;
  private SmS1 smS1;
  private SmS2 smS2;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e4_M, e2_M, e3_M, e5_M, e6_M, null_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.e1_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.e4_M)));
    stateMessageMap.put(SmS1.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(SmS1.s1a,new HashSet<MessageType>(Arrays.asList(MessageType.e2_M)));
    stateMessageMap.put(SmS1.s1b,new HashSet<MessageType>(Arrays.asList(MessageType.e3_M)));
    stateMessageMap.put(SmS2.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(SmS2.s2a,new HashSet<MessageType>(Arrays.asList(MessageType.e5_M)));
    stateMessageMap.put(SmS2.s2b,new HashSet<MessageType>(Arrays.asList(MessageType.e6_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSmS2(SmS2.Null);
    setSm(Sm.s1);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    if (smS2 != SmS2.Null) { answer += "." + smS2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public SmS2 getSmS2()
  {
    return smS2;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSmS1();
        setSmS1(SmS1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e4()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1a:
        exitSmS1();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1b:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e5()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2a:
        exitSmS2();
        setSmS2(SmS2.s2b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e6()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2b:
        exitSmS2();
        setSmS2(SmS2.s2a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
      case s2:
        exitSmS2();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s1a); }
        break;
      case s2:
        if (smS2 == SmS2.Null) { setSmS2(SmS2.s2a); }
        break;
    }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s1a:
        setSmS1(SmS1.Null);
        break;
      case s1b:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }
  }

  private void exitSmS2()
  {
    switch(smS2)
    {
      case s2a:
        setSmS2(SmS2.Null);
        break;
      case s2b:
        setSmS2(SmS2.Null);
        break;
    }
  }

  private void setSmS2(SmS2 aSmS2)
  {
    smS2 = aSmS2;
    if (sm != Sm.s2 && aSmS2 != SmS2.Null) { setSm(Sm.s2); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSmS1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSmS2()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    pool.put(new Message(MessageType.e1_M, null));
  }

  public void e4 ()
  {
    pool.put(new Message(MessageType.e4_M, null));
  }

  public void e2 ()
  {
    pool.put(new Message(MessageType.e2_M, null));
  }

  public void e3 ()
  {
    pool.put(new Message(MessageType.e3_M, null));
  }

  public void e5 ()
  {
    pool.put(new Message(MessageType.e5_M, null));
  }

  public void e6 ()
  {
    pool.put(new Message(MessageType.e6_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e4_M:
          status = _e4();
          break;
        case e2_M:
          status = _e2();
          break;
        case e3_M:
          status = _e3();
          break;
        case e5_M:
          status = _e5();
          break;
        case e6_M:
          status = _e6();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "testPooledwithNestedStates_3.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { s1, s2, s3 }
  public enum SmS1 { Null, s1a, s1b }
  public enum SmS2 { Null, s2a, s2b }
  public enum SmS3 { Null, s3a, s3b }
  private Sm sm;
  private SmS1 smS1;
  private SmS2 smS2;
  private SmS3 smS3;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e1_M, e4_M, e7_M, e2_M, e3_M, e5_M, e6_M, e8_M, e9_M, null_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm.s1,new HashSet<MessageType>(Arrays.asList(MessageType.e1_M)));
    stateMessageMap.put(Sm.s2,new HashSet<MessageType>(Arrays.asList(MessageType.e4_M)));
    stateMessageMap.put(Sm.s3,new HashSet<MessageType>(Arrays.asList(MessageType.e7_M)));
    stateMessageMap.put(SmS1.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(SmS1.s1a,new HashSet<MessageType>(Arrays.asList(MessageType.e2_M)));
    stateMessageMap.put(SmS1.s1b,new HashSet<MessageType>(Arrays.asList(MessageType.e3_M)));
    stateMessageMap.put(SmS2.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(SmS2.s2a,new HashSet<MessageType>(Arrays.asList(MessageType.e5_M)));
    stateMessageMap.put(SmS2.s2b,new HashSet<MessageType>(Arrays.asList(MessageType.e6_M)));
    stateMessageMap.put(SmS3.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(SmS3.s3a,new HashSet<MessageType>(Arrays.asList(MessageType.e8_M)));
    stateMessageMap.put(SmS3.s3b,new HashSet<MessageType>(Arrays.asList(MessageType.e9_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmS1(SmS1.Null);
    setSmS2(SmS2.Null);
    setSmS3(SmS3.Null);
    setSm(Sm.s1);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smS1 != SmS1.Null) { answer += "." + smS1.toString(); }
    if (smS2 != SmS2.Null) { answer += "." + smS2.toString(); }
    if (smS3 != SmS3.Null) { answer += "." + smS3.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmS1 getSmS1()
  {
    return smS1;
  }

  public SmS2 getSmS2()
  {
    return smS2;
  }

  public SmS3 getSmS3()
  {
    return smS3;
  }

  public boolean _e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s1:
        exitSmS1();
        setSmS1(SmS1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e4()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s2:
        exitSm();
        setSm(Sm.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e7()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case s3:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e2()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1a:
        exitSmS1();
        setSmS1(SmS1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e3()
  {
    boolean wasEventProcessed = false;
    
    SmS1 aSmS1 = smS1;
    switch (aSmS1)
    {
      case s1b:
        exitSm();
        setSm(Sm.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e5()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2a:
        exitSmS2();
        setSmS2(SmS2.s2b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e6()
  {
    boolean wasEventProcessed = false;
    
    SmS2 aSmS2 = smS2;
    switch (aSmS2)
    {
      case s2b:
        exitSm();
        setSm(Sm.s3);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e8()
  {
    boolean wasEventProcessed = false;
    
    SmS3 aSmS3 = smS3;
    switch (aSmS3)
    {
      case s3a:
        exitSmS3();
        setSmS3(SmS3.s3b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _e9()
  {
    boolean wasEventProcessed = false;
    
    SmS3 aSmS3 = smS3;
    switch (aSmS3)
    {
      case s3b:
        exitSm();
        setSmS1(SmS1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case s1:
        exitSmS1();
        break;
      case s2:
        exitSmS2();
        break;
      case s3:
        exitSmS3();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case s1:
        if (smS1 == SmS1.Null) { setSmS1(SmS1.s1a); }
        break;
      case s2:
        if (smS2 == SmS2.Null) { setSmS2(SmS2.s2a); }
        break;
      case s3:
        if (smS3 == SmS3.Null) { setSmS3(SmS3.s3a); }
        break;
    }
  }

  private void exitSmS1()
  {
    switch(smS1)
    {
      case s1a:
        setSmS1(SmS1.Null);
        break;
      case s1b:
        setSmS1(SmS1.Null);
        break;
    }
  }

  private void setSmS1(SmS1 aSmS1)
  {
    smS1 = aSmS1;
    if (sm != Sm.s1 && aSmS1 != SmS1.Null) { setSm(Sm.s1); }
  }

  private void exitSmS2()
  {
    switch(smS2)
    {
      case s2a:
        setSmS2(SmS2.Null);
        break;
      case s2b:
        setSmS2(SmS2.Null);
        break;
    }
  }

  private void setSmS2(SmS2 aSmS2)
  {
    smS2 = aSmS2;
    if (sm != Sm.s2 && aSmS2 != SmS2.Null) { setSm(Sm.s2); }
  }

  private void exitSmS3()
  {
    switch(smS3)
    {
      case s3a:
        setSmS3(SmS3.Null);
        break;
      case s3b:
        setSmS3(SmS3.Null);
        break;
    }
  }

  private void setSmS3(SmS3 aSmS3)
  {
    smS3 = aSmS3;
    if (sm != Sm.s3 && aSmS3 != SmS3.Null) { setSm(Sm.s3); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSmS1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSmS2()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSmS3()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e1 ()
  {
    pool.put(new Message(MessageType.e1_M, null));
  }

  public void e4 ()
  {
    pool.put(new Message(MessageType.e4_M, null));
  }

  public void e7 ()
  {
    pool.put(new Message(MessageType.e7_M, null));
  }

  public void e2 ()
  {
    pool.put(new Message(MessageType.e2_M, null));
  }

  public void e3 ()
  {
    pool.put(new Message(MessageType.e3_M, null));
  }

  public void e5 ()
  {
    pool.put(new Message(MessageType.e5_M, null));
  }

  public void e6 ()
  {
    pool.put(new Message(MessageType.e6_M, null));
  }

  public void e8 ()
  {
    pool.put(new Message(MessageType.e8_M, null));
  }

  public void e9 ()
  {
    pool.put(new Message(MessageType.e9_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e1_M:
          status = _e1();
          break;
        case e4_M:
          status = _e4();
          break;
        case e7_M:
          status = _e7();
          break;
        case e2_M:
          status = _e2();
          break;
        case e3_M:
          status = _e3();
          break;
        case e5_M:
          status = _e5();
          break;
        case e6_M:
          status = _e6();
          break;
        case e8_M:
          status = _e8();
          break;
        case e9_M:
          status = _e9();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/


import java.util.*;
import java.lang.Thread;

// line 1 "testPooledwithNestedStates_4.ump"
public class X implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm1 { s1, s2 }
  public enum Sm1S1 { Null, s1a, s1b }
  public enum Sm1S2 { Null, s2a, s2b }
  public enum Sm1S2S2b { Null, s2b1, s2b2 }
  private Sm1 sm1;
  private Sm1S1 sm1S1;
  private Sm1S2 sm1S2;
  private Sm1S2S2b sm1S2S2b;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by X
  protected enum MessageType { e_M, f_M, g_M, h_M, i_M, k_M, j_M, m_M, null_M }

  // Map for a X pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Sm1.s1,new HashSet<MessageType>(Arrays.asList(MessageType.e_M)));
    stateMessageMap.put(Sm1.s2,new HashSet<MessageType>(Arrays.asList(MessageType.e_M)));
    stateMessageMap.put(Sm1S1.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(Sm1S1.s1a,new HashSet<MessageType>(Arrays.asList(MessageType.f_M, MessageType.g_M)));
    stateMessageMap.put(Sm1S1.s1b,new HashSet<MessageType>(Arrays.asList(MessageType.h_M, MessageType.i_M, MessageType.k_M)));
    stateMessageMap.put(Sm1S2.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(Sm1S2.s2a,new HashSet<MessageType>(Arrays.asList(MessageType.i_M, MessageType.j_M)));
    stateMessageMap.put(Sm1S2.s2b,new HashSet<MessageType>(Arrays.asList(MessageType.h_M, MessageType.k_M)));
    stateMessageMap.put(Sm1S2S2b.Null,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(Sm1S2S2b.s2b1,new HashSet<MessageType>(Arrays.asList(MessageType.m_M)));
    stateMessageMap.put(Sm1S2S2b.s2b2,new HashSet<MessageType>(Arrays.asList(MessageType.m_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSm1S1(Sm1S1.Null);
    setSm1S2(Sm1S2.Null);
    setSm1S2S2b(Sm1S2S2b.Null);
    setSm1(Sm1.s1);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of X
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSm1FullName()
  {
    String answer = sm1.toString();
    if (sm1S1 != Sm1S1.Null) { answer += "." + sm1S1.toString(); }
    if (sm1S2 != Sm1S2.Null) { answer += "." + sm1S2.toString(); }
    if (sm1S2S2b != Sm1S2S2b.Null) { answer += "." + sm1S2S2b.toString(); }
    return answer;
  }

  public Sm1 getSm1()
  {
    return sm1;
  }

  public Sm1S1 getSm1S1()
  {
    return sm1S1;
  }

  public Sm1S2 getSm1S2()
  {
    return sm1S2;
  }

  public Sm1S2S2b getSm1S2S2b()
  {
    return sm1S2S2b;
  }

  public boolean _e()
  {
    boolean wasEventProcessed = false;
    
    Sm1 aSm1 = sm1;
    switch (aSm1)
    {
      case s1:
        exitSm1();
        setSm1(Sm1.s2);
        wasEventProcessed = true;
        break;
      case s2:
        exitSm1();
        setSm1(Sm1.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _f()
  {
    boolean wasEventProcessed = false;
    
    Sm1S1 aSm1S1 = sm1S1;
    switch (aSm1S1)
    {
      case s1a:
        exitSm1();
        setSm1S2(Sm1S2.s2b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _g()
  {
    boolean wasEventProcessed = false;
    
    Sm1S1 aSm1S1 = sm1S1;
    switch (aSm1S1)
    {
      case s1a:
        exitSm1S1();
        setSm1S1(Sm1S1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _h()
  {
    boolean wasEventProcessed = false;
    
    Sm1S1 aSm1S1 = sm1S1;
    Sm1S2 aSm1S2 = sm1S2;
    switch (aSm1S1)
    {
      case s1b:
        exitSm1S1();
        setSm1S1(Sm1S1.s1a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSm1S2)
    {
      case s2b:
        exitSm1S2();
        setSm1S2(Sm1S2.s2a);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _i()
  {
    boolean wasEventProcessed = false;
    
    Sm1S1 aSm1S1 = sm1S1;
    Sm1S2 aSm1S2 = sm1S2;
    switch (aSm1S1)
    {
      case s1b:
        exitSm1();
        setSm1S2(Sm1S2.s2b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSm1S2)
    {
      case s2a:
        exitSm1S2();
        setSm1S2(Sm1S2.s2b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _k()
  {
    boolean wasEventProcessed = false;
    
    Sm1S1 aSm1S1 = sm1S1;
    Sm1S2 aSm1S2 = sm1S2;
    switch (aSm1S1)
    {
      case s1b:
        exitSm1();
        setSm1(Sm1.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSm1S2)
    {
      case s2b:
        exitSm1();
        setSm1(Sm1.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _j()
  {
    boolean wasEventProcessed = false;
    
    Sm1S2 aSm1S2 = sm1S2;
    switch (aSm1S2)
    {
      case s2a:
        exitSm1();
        setSm1S1(Sm1S1.s1b);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _m()
  {
    boolean wasEventProcessed = false;
    
    Sm1S2S2b aSm1S2S2b = sm1S2S2b;
    switch (aSm1S2S2b)
    {
      case s2b1:
        exitSm1S2S2b();
        setSm1S2S2b(Sm1S2S2b.s2b2);
        wasEventProcessed = true;
        break;
      case s2b2:
        exitSm1S2S2b();
        setSm1S2S2b(Sm1S2S2b.s2b1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm1()
  {
    switch(sm1)
    {
      case s1:
        exitSm1S1();
        break;
      case s2:
        exitSm1S2();
        break;
    }
  }

  private void setSm1(Sm1 aSm1)
  {
    sm1 = aSm1;

    // entry actions and do activities
    switch(sm1)
    {
      case s1:
        if (sm1S1 == Sm1S1.Null) { setSm1S1(Sm1S1.s1a); }
        break;
      case s2:
        if (sm1S2 == Sm1S2.Null) { setSm1S2(Sm1S2.s2a); }
        break;
    }
  }

  private void exitSm1S1()
  {
    switch(sm1S1)
    {
      case s1a:
        setSm1S1(Sm1S1.Null);
        break;
      case s1b:
        setSm1S1(Sm1S1.Null);
        break;
    }
  }

  private void setSm1S1(Sm1S1 aSm1S1)
  {
    sm1S1 = aSm1S1;
    if (sm1 != Sm1.s1 && aSm1S1 != Sm1S1.Null) { setSm1(Sm1.s1); }
  }

  private void exitSm1S2()
  {
    switch(sm1S2)
    {
      case s2a:
        setSm1S2(Sm1S2.Null);
        break;
      case s2b:
        exitSm1S2S2b();
        setSm1S2(Sm1S2.Null);
        break;
    }
  }

  private void setSm1S2(Sm1S2 aSm1S2)
  {
    sm1S2 = aSm1S2;
    if (sm1 != Sm1.s2 && aSm1S2 != Sm1S2.Null) { setSm1(Sm1.s2); }

    // entry actions and do activities
    switch(sm1S2)
    {
      case s2b:
        if (sm1S2S2b == Sm1S2S2b.Null) { setSm1S2S2b(Sm1S2S2b.s2b1); }
        break;
    }
  }

  private void exitSm1S2S2b()
  {
    switch(sm1S2S2b)
    {
      case s2b1:
        setSm1S2S2b(Sm1S2S2b.Null);
        break;
      case s2b2:
        setSm1S2S2b(Sm1S2S2b.Null);
        break;
    }
  }

  private void setSm1S2S2b(Sm1S2S2b aSm1S2S2b)
  {
    sm1S2S2b = aSm1S2S2b;
    if (sm1S2 != Sm1S2.s2b && aSm1S2S2b != Sm1S2S2b.Null) { setSm1S2(Sm1S2.s2b); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getSm1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSm1S1()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSm1S2()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
        else if(stateMessageMap.get(getSm1S2S2b()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void e ()
  {
    pool.put(new Message(MessageType.e_M, null));
  }

  public void f ()
  {
    pool.put(new Message(MessageType.f_M, null));
  }

  public void g ()
  {
    pool.put(new Message(MessageType.g_M, null));
  }

  public void h ()
  {
    pool.put(new Message(MessageType.h_M, null));
  }

  public void i ()
  {
    pool.put(new Message(MessageType.i_M, null));
  }

  public void k ()
  {
    pool.put(new Message(MessageType.k_M, null));
  }

  public void j ()
  {
    pool.put(new Message(MessageType.j_M, null));
  }

  public void m ()
  {
    pool.put(new Message(MessageType.m_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case e_M:
          status = _e();
          break;
        case f_M:
          status = _f();
          break;
        case g_M:
          status = _g();
          break;
        case h_M:
          status = _h();
          break;
        case i_M:
          status = _i();
          break;
        case k_M:
          status = _k();
          break;
        case j_M:
          status = _j();
          break;
        case m_M:
          status = _m();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 4 "../AutoEventTransition.ump"
public class Light
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Light State Machines
  public enum Bulb { Off, On }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Light()
  {
    setBulb(Bulb.Off);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case Off:
        __autotransition1__();
        break;
    }
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../nestedStatesOfQSMwithSameEventNames.ump"
public class NestedStatesWthSameEventNames implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //NestedStatesWthSameEventNames State Machines
  public enum Sm { nestedState1, nestedState2, state5 }
  public enum SmNestedState1 { Null, state1, state2 }
  public enum SmNestedState2 { Null, state3, state4 }
  private Sm sm;
  private SmNestedState1 smNestedState1;
  private SmNestedState2 smNestedState2;
  
  //enumeration type of messages accepted by NestedStatesWthSameEventNames
  protected enum MessageType { moveTo_M, transit_M }
  
  MessageQueue queue;
  Thread removal;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public NestedStatesWthSameEventNames()
  {
    setSmNestedState1(SmNestedState1.Null);
    setSmNestedState2(SmNestedState2.Null);
    setSm(Sm.nestedState1);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of NestedStatesWthSameEventNames
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smNestedState1 != SmNestedState1.Null) { answer += "." + smNestedState1.toString(); }
    if (smNestedState2 != SmNestedState2.Null) { answer += "." + smNestedState2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmNestedState1 getSmNestedState1()
  {
    return smNestedState1;
  }

  public SmNestedState2 getSmNestedState2()
  {
    return smNestedState2;
  }

  public boolean _moveTo()
  {
    boolean wasEventProcessed = false;
    
    SmNestedState1 aSmNestedState1 = smNestedState1;
    SmNestedState2 aSmNestedState2 = smNestedState2;
    switch (aSmNestedState1)
    {
      case state1:
        exitSmNestedState1();
        setSmNestedState1(SmNestedState1.state2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSmNestedState2)
    {
      case state3:
        exitSmNestedState2();
        setSmNestedState2(SmNestedState2.state4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean _transit()
  {
    boolean wasEventProcessed = false;
    
    SmNestedState1 aSmNestedState1 = smNestedState1;
    SmNestedState2 aSmNestedState2 = smNestedState2;
    switch (aSmNestedState1)
    {
      case state2:
        exitSm();
        setSm(Sm.state5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    switch (aSmNestedState2)
    {
      case state4:
        exitSm();
        setSm(Sm.state5);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case nestedState1:
        exitSmNestedState1();
        break;
      case nestedState2:
        exitSmNestedState2();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case nestedState1:
        if (smNestedState1 == SmNestedState1.Null) { setSmNestedState1(SmNestedState1.state1); }
        break;
      case nestedState2:
        if (smNestedState2 == SmNestedState2.Null) { setSmNestedState2(SmNestedState2.state3); }
        break;
    }
  }

  private void exitSmNestedState1()
  {
    switch(smNestedState1)
    {
      case state1:
        setSmNestedState1(SmNestedState1.Null);
        break;
      case state2:
        setSmNestedState1(SmNestedState1.Null);
        break;
    }
  }

  private void setSmNestedState1(SmNestedState1 aSmNestedState1)
  {
    smNestedState1 = aSmNestedState1;
    if (sm != Sm.nestedState1 && aSmNestedState1 != SmNestedState1.Null) { setSm(Sm.nestedState1); }
  }

  private void exitSmNestedState2()
  {
    switch(smNestedState2)
    {
      case state3:
        setSmNestedState2(SmNestedState2.Null);
        break;
      case state4:
        setSmNestedState2(SmNestedState2.Null);
        break;
    }
  }

  private void setSmNestedState2(SmNestedState2 aSmNestedState2)
  {
    smNestedState2 = aSmNestedState2;
    if (sm != Sm.nestedState2 && aSmNestedState2 != SmNestedState2.Null) { setSm(Sm.nestedState2); }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void moveTo ()
  {
    queue.put(new Message(MessageType.moveTo_M, null));
  }

  public void transit ()
  {
    queue.put(new Message(MessageType.transit_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case moveTo_M:
          status = _moveTo();
          break;
        case transit_M:
          status = _transit();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/



// line 1 "checkExternalTransitions_noExitActions_1.ump"
public class X
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //X State Machines
  public enum Sm { on, off }
  public enum SmOn { Null, s1, s2 }
  public enum SmOnS1 { Null, m1, m2 }
  public enum SmOff { Null, s3, s4 }
  private Sm sm;
  private SmOn smOn;
  private SmOnS1 smOnS1;
  private SmOff smOff;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public X()
  {
    setSmOn(SmOn.Null);
    setSmOnS1(SmOnS1.Null);
    setSmOff(SmOff.Null);
    setSm(Sm.on);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smOn != SmOn.Null) { answer += "." + smOn.toString(); }
    if (smOnS1 != SmOnS1.Null) { answer += "." + smOnS1.toString(); }
    if (smOff != SmOff.Null) { answer += "." + smOff.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmOn getSmOn()
  {
    return smOn;
  }

  public SmOnS1 getSmOnS1()
  {
    return smOnS1;
  }

  public SmOff getSmOff()
  {
    return smOff;
  }

  public boolean e1()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case on:
        exitSm();
        setSm(Sm.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e2()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case on:
        exitSm();
        setSm(Sm.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e3()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSmOn();
        setSmOn(SmOn.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e4()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSmOn();
        setSmOn(SmOn.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e5()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSm();
        setSm(Sm.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e6()
  {
    boolean wasEventProcessed = false;
    
    SmOn aSmOn = smOn;
    switch (aSmOn)
    {
      case s1:
        exitSm();
        setSm(Sm.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e7()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOnS1();
        setSmOnS1(SmOnS1.m2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e8()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOnS1();
        setSmOnS1(SmOnS1.m1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e9()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOn();
        setSmOn(SmOn.s1);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e10()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSmOn();
        setSmOn(SmOn.s2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e11()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSm();
        setSm(Sm.on);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e12()
  {
    boolean wasEventProcessed = false;
    
    SmOnS1 aSmOnS1 = smOnS1;
    switch (aSmOnS1)
    {
      case m1:
        exitSm();
        setSm(Sm.off);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  public boolean e13()
  {
    boolean wasEventProcessed = false;
    
    SmOff aSmOff = smOff;
    switch (aSmOff)
    {
      case s3:
        exitSmOff();
        setSmOff(SmOff.s4);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case on:
        exitSmOn();
        break;
      case off:
        exitSmOff();
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case on:
        // line 4 "checkExternalTransitions_noExitActions_1.ump"
        on_entry_action();
        if (smOn == SmOn.Null) { setSmOn(SmOn.s1); }
        break;
      case off:
        if (smOff == SmOff.Null) { setSmOff(SmOff.s3); }
        break;
    }
  }

  private void exitSmOn()
  {
    switch(smOn)
    {
      case s1:
        exitSmOnS1();
        setSmOn(SmOn.Null);
        break;
      case s2:
        setSmOn(SmOn.Null);
        break;
    }
  }

  private void setSmOn(SmOn aSmOn)
  {
    smOn = aSmOn;
    if (sm != Sm.on && aSmOn != SmOn.Null) { setSm(Sm.on); }

    // entry actions and do activities
    switch(smOn)
    {
      case s1:
        // line 8 "checkExternalTransitions_noExitActions_1.ump"
        s1_entry_action();
        if (smOnS1 == SmOnS1.Null) { setSmOnS1(SmOnS1.m1); }
        break;
    }
  }

  private void exitSmOnS1()
  {
    switch(smOnS1)
    {
      case m1:
        setSmOnS1(SmOnS1.Null);
        break;
      case m2:
        setSmOnS1(SmOnS1.Null);
        break;
    }
  }

  private void setSmOnS1(SmOnS1 aSmOnS1)
  {
    smOnS1 = aSmOnS1;
    if (smOn != SmOn.s1 && aSmOnS1 != SmOnS1.Null) { setSmOn(SmOn.s1); }

    // entry actions and do activities
    switch(smOnS1)
    {
      case m1:
        // line 14 "checkExternalTransitions_noExitActions_1.ump"
        m1_entry_action();
        break;
    }
  }

  private void exitSmOff()
  {
    switch(smOff)
    {
      case s3:
        setSmOff(SmOff.Null);
        break;
      case s4:
        setSmOff(SmOff.Null);
        break;
    }
  }

  private void setSmOff(SmOff aSmOff)
  {
    smOff = aSmOff;
    if (sm != Sm.off && aSmOff != SmOff.Null) { setSm(Sm.off); }
  }

  public void delete()
  {}

  // line 34 "checkExternalTransitions_noExitActions_1.ump"
  public void on_entry_action(){
    
  }

  // line 35 "checkExternalTransitions_noExitActions_1.ump"
  public void s1_entry_action(){
    
  }

  // line 36 "checkExternalTransitions_noExitActions_1.ump"
  public void m1_entry_action(){
    
  }

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 20 "../SimpleStateMachine.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open, Full }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean setStatus(Status aStatus)
  {
    status = aStatus;
    return true;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 3 "../oneGuard.ump"
public class LightFixture
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //LightFixture Attributes
  private int brightness;

  //LightFixture State Machines
  public enum Bulb { On, Off }
  private Bulb bulb;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public LightFixture()
  {
    brightness = 0;
    setBulb(Bulb.On);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setBrightness(int aBrightness)
  {
    boolean wasSet = false;
    brightness = aBrightness;
    wasSet = true;
    return wasSet;
  }

  public int getBrightness()
  {
    return brightness;
  }

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  public boolean push()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case On:
        if (getBrightness()<1)
        {
          setBulb(Bulb.Off);
          wasEventProcessed = true;
          break;
        }
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;
  }

  public void delete()
  {}


  public String toString()
  {
    return super.toString() + "["+
            "brightness" + ":" + getBrightness()+ "]";
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../queuedSMwithConcurrentStatesTest_2.ump"
public class QueuedSMwithConcurrentStates_2 implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //QueuedSMwithConcurrentStates_2 State Machines
  public enum Sm { state1, state2, state3 }
  public enum SmState1SubState1 { Null, subState1 }
  public enum SmState1SubState2 { Null, subState2 }
  private Sm sm;
  private SmState1SubState1 smState1SubState1;
  private SmState1SubState2 smState1SubState2;
  
  //enumeration type of messages accepted by QueuedSMwithConcurrentStates_2
  protected enum MessageType { transit_M }
  
  MessageQueue queue;
  Thread removal;

  //QueuedSMwithConcurrentStates_2 Do Activity Threads
  Thread doActivitySmState2Thread = null;
  Thread doActivitySmState3Thread = null;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public QueuedSMwithConcurrentStates_2()
  {
    setSmState1SubState1(SmState1SubState1.Null);
    setSmState1SubState2(SmState1SubState2.Null);
    setSm(Sm.state1);
    queue = new MessageQueue();
    removal=new Thread(this);
    //start the thread of QueuedSMwithConcurrentStates_2
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getSmFullName()
  {
    String answer = sm.toString();
    if (smState1SubState1 != SmState1SubState1.Null) { answer += "." + smState1SubState1.toString(); }
    if (smState1SubState2 != SmState1SubState2.Null) { answer += "." + smState1SubState2.toString(); }
    return answer;
  }

  public Sm getSm()
  {
    return sm;
  }

  public SmState1SubState1 getSmState1SubState1()
  {
    return smState1SubState1;
  }

  public SmState1SubState2 getSmState1SubState2()
  {
    return smState1SubState2;
  }

  public boolean _transit()
  {
    boolean wasEventProcessed = false;
    
    Sm aSm = sm;
    switch (aSm)
    {
      case state1:
        exitSm();
        setSm(Sm.state2);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void exitSm()
  {
    switch(sm)
    {
      case state1:
        exitSmState1SubState1();
        exitSmState1SubState2();
        break;
      case state2:
        if (doActivitySmState2Thread != null) { doActivitySmState2Thread.interrupt(); }
        break;
      case state3:
        if (doActivitySmState3Thread != null) { doActivitySmState3Thread.interrupt(); }
        break;
    }
  }

  private void setSm(Sm aSm)
  {
    sm = aSm;

    // entry actions and do activities
    switch(sm)
    {
      case state1:
        if (smState1SubState1 == SmState1SubState1.Null) { setSmState1SubState1(SmState1SubState1.subState1); }
        if (smState1SubState2 == SmState1SubState2.Null) { setSmState1SubState2(SmState1SubState2.subState2); }
        break;
      case state2:
        doActivitySmState2Thread = new DoActivityThread(this,"doActivitySmState2");
        break;
      case state3:
        doActivitySmState3Thread = new DoActivityThread(this,"doActivitySmState3");
        break;
    }
  }

  private void exitSmState1SubState1()
  {
    switch(smState1SubState1)
    {
      case subState1:
        setSmState1SubState1(SmState1SubState1.Null);
        break;
    }
  }

  private void setSmState1SubState1(SmState1SubState1 aSmState1SubState1)
  {
    smState1SubState1 = aSmState1SubState1;
    if (sm != Sm.state1 && aSmState1SubState1 != SmState1SubState1.Null) { setSm(Sm.state1); }
  }

  private void exitSmState1SubState2()
  {
    switch(smState1SubState2)
    {
      case subState2:
        setSmState1SubState2(SmState1SubState2.Null);
        break;
    }
  }

  private void setSmState1SubState2(SmState1SubState2 aSmState1SubState2)
  {
    smState1SubState2 = aSmState1SubState2;
    if (sm != Sm.state1 && aSmState1SubState2 != SmState1SubState2.Null) { setSm(Sm.state1); }
  }

  private void doActivitySmState2()
  {
    try
    {
      // line 17 "../queuedSMwithConcurrentStatesTest_2.ump"
      doTransition1();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private void doActivitySmState3()
  {
    try
    {
      // line 21 "../queuedSMwithConcurrentStatesTest_2.ump"
      doTransition2();
      Thread.sleep(1);
    }
    catch (InterruptedException e)
    {

    }
  }

  private static class DoActivityThread extends Thread
  {
    QueuedSMwithConcurrentStates_2 controller;
    String doActivityMethodName;
    
    public DoActivityThread(QueuedSMwithConcurrentStates_2 aController,String aDoActivityMethodName)
    {
      controller = aController;
      doActivityMethodName = aDoActivityMethodName;
      start();
    }
    
    public void run()
    {
      if ("doActivitySmState2".equals(doActivityMethodName))
      {
        controller.doActivitySmState2();
      }
        else if ("doActivitySmState3".equals(doActivityMethodName))
      {
        controller.doActivitySmState3();
      }
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessageQueue {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      try {
        while (messages.isEmpty()) 
        {
          wait();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      //The element to be removed
      Message m = messages.remove(); 
      return (m);
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  public void transit ()
  {
    queue.put(new Message(MessageType.transit_M, null));
  }

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = queue.getNext();
      if(m == null)  return;
      
      switch (m.type)
      {
        case transit_M:
          status = _transit();
          break; 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 12 "../SimpleStateMachine.ump"
public class Student
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Student State Machines
  public enum Grade { Pass }
  private Grade grade;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Student()
  {
    setGrade(Grade.Pass);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getGradeFullName()
  {
    String answer = grade.toString();
    return answer;
  }

  public Grade getGrade()
  {
    return grade;
  }

  public boolean setGrade(Grade aGrade)
  {
    grade = aGrade;
    return true;
  }

  public void delete()
  {}

}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;
import java.util.*;
import java.lang.Thread;

// line 3 "../pooledStateMachine_autoTransition.ump"
public class Light implements Runnable
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Light State Machines
  public enum Bulb { Off, On }
  private Bulb bulb;
  
  MessagePool pool;
  Thread removal;
  
  //enumeration type of messages accepted by Light
  protected enum MessageType { null_M }

  // Map for a Light pooled state machine that allows querying which events are possible in each map

  public static final Map<Object, HashSet<MessageType>> stateMessageMap = new HashMap<Object, HashSet<MessageType>>();
  static {
    stateMessageMap.put(Bulb.Off,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
    stateMessageMap.put(Bulb.On,new HashSet<MessageType>(Arrays.asList(MessageType.null_M)));
  }

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Light()
  {
    setBulb(Bulb.Off);
    pool = new MessagePool();
    removal=new Thread(this);
    //start the thread of Light
    removal.start();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getBulbFullName()
  {
    String answer = bulb.toString();
    return answer;
  }

  public Bulb getBulb()
  {
    return bulb;
  }

  private boolean __autotransition1__()
  {
    boolean wasEventProcessed = false;
    
    Bulb aBulb = bulb;
    switch (aBulb)
    {
      case Off:
        setBulb(Bulb.On);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setBulb(Bulb aBulb)
  {
    bulb = aBulb;

    // entry actions and do activities
    switch(bulb)
    {
      case Off:
        __autotransition1__();
        break;
    }
  }

  public void delete()
  {
    removal.interrupt();
  }

  protected class Message
  {
    MessageType type;
    
    //Message parameters
    Vector<Object> param;
    
    public Message(MessageType t, Vector<Object> p)
    {
      type = t; 
      param = p;
    }

    @Override
    public String toString()
    {
      return type + "," + param;
    }
  }
  
  protected class MessagePool {
    Queue<Message> messages = new LinkedList<Message>();
    
    public synchronized void put(Message m)
    {
      messages.add(m); 
      notify();
    }

    public synchronized Message getNext()
    {
      Message message=null;

      try {
        message=getNextProcessableMessage();
        while (message==null)
        {
          wait();
          message=getNextProcessableMessage();
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return null;
      }

      // return the message
      return (message);
    }

    public Message getNextProcessableMessage()
    {
      // Iterate through messages and remove the first message that matches one of the Messages list
      // otherwise return null
      for (Message msg: messages)
      {
        if(stateMessageMap.get(getBulb()).contains(msg.type))
        {
          //The element to be removed
          messages.remove(msg);
          return (msg);
        }
      }
      return null;
    }
  }

  //------------------------------
  //messages accepted 
  //------------------------------

  
  @Override
  public void run ()
  {
    boolean status=false;
    while (true) 
    {
      Message m = pool.getNext();
      if(m == null)  return;
      
      switch (m.type)
      { 
        default:
      }
      if(!status)
      {
        // Error message is written or  exception is raised
      }
    }
  }
}
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.31.1.5860.78bb27cc6 modeling language!*/

package example;

// line 4 "../EventTransition.ump"
public class Course
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Course State Machines
  public enum Status { Open }
  private Status status;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Course()
  {
    setStatus(Status.Open);
  }

  //------------------------
  // INTERFACE
  //------------------------

  public String getStatusFullName()
  {
    String answer = status.toString();
    return answer;
  }

  public Status getStatus()
  {
    return status;
  }

  public boolean register()
  {
    boolean wasEventProcessed = false;
    
    Status aStatus = status;
    switch (aStatus)
    {
      case Open:
        setStatus(Status.Open);
        wasEventProcessed = true;
        break;
      default:
        // Other states do respond to this event
    }

    return wasEventProcessed;
  }

  private void setStatus(Status aStatus)
  {
    status = aStatus;
  }

  public void delete()
  {}

}
]]></system-out>
  <system-err><![CDATA[]]></system-err>
</testsuite>
